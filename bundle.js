
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.head.appendChild(r) })(document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        if (value != null || input.value) {
            input.value = value;
        }
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(html, anchor = null) {
            this.e = element('div');
            this.a = anchor;
            this.u(html);
        }
        m(target, anchor = null) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(target, this.n[i], anchor);
            }
            this.t = target;
        }
        u(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        p(html) {
            this.d();
            this.u(html);
            this.m(this.t, this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch$1(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch$1(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch$1(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch$1(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch$1(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch$1(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch$1(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch$1(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next, lookup.has(block.key));
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error(`Cannot have duplicate keys in a keyed each`);
            }
            keys.add(key);
        }
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if ($$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.22.2' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe,
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function regexparam (str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules\svelte-spa-router\Router.svelte generated by Svelte v3.22.2 */

    const { Error: Error_1, Object: Object_1, console: console_1 } = globals;

    // (209:0) {:else}
    function create_else_block(ctx) {
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[10]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(209:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (207:0) {#if componentParams}
    function create_if_block(ctx) {
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		return {
    			props: { params: /*componentParams*/ ctx[1] },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[9]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*componentParams*/ 2) switch_instance_changes.params = /*componentParams*/ ctx[1];

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[9]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(207:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap(route, userData, ...conditions) {
    	// Check if we don't have userData
    	if (userData && typeof userData == "function") {
    		conditions = conditions && conditions.length ? conditions : [];
    		conditions.unshift(userData);
    		userData = undefined;
    	}

    	// Parameter route and each item of conditions must be functions
    	if (!route || typeof route != "function") {
    		throw Error("Invalid parameter route");
    	}

    	if (conditions && conditions.length) {
    		for (let i = 0; i < conditions.length; i++) {
    			if (!conditions[i] || typeof conditions[i] != "function") {
    				throw Error("Invalid parameter conditions[" + i + "]");
    			}
    		}
    	}

    	// Returns an object that contains all the functions to execute too
    	const obj = { route, userData };

    	if (conditions && conditions.length) {
    		obj.conditions = conditions;
    	}

    	// The _sveltesparouter flag is to confirm the object was created by this router
    	Object.defineProperty(obj, "_sveltesparouter", { value: true });

    	return obj;
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf("#/");

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: "/";

    	// Check if there's a querystring
    	const qsPosition = location.indexOf("?");

    	let querystring = "";

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(getLocation(), // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener("hashchange", update, false);

    	return function stop() {
    		window.removeEventListener("hashchange", update, false);
    	};
    });

    const location$1 = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);

    function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	return nextTickPromise(() => {
    		window.location.hash = (location.charAt(0) == "#" ? "" : "#") + location;
    	});
    }

    function pop() {
    	// Execute this code when the current call stack is complete
    	return nextTickPromise(() => {
    		window.history.back();
    	});
    }

    function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	return nextTickPromise(() => {
    		const dest = (location.charAt(0) == "#" ? "" : "#") + location;

    		try {
    			window.history.replaceState(undefined, undefined, dest);
    		} catch(e) {
    			// eslint-disable-next-line no-console
    			console.warn("Caught exception while replacing the current page. If you're running this in the Svelte REPL, please note that the `replace` method might not work in this environment.");
    		}

    		// The method above doesn't trigger the hashchange event, so let's do that manually
    		window.dispatchEvent(new Event("hashchange"));
    	});
    }

    function link(node) {
    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != "a") {
    		throw Error("Action \"link\" can only be used with <a> tags");
    	}

    	// Destination must start with '/'
    	const href = node.getAttribute("href");

    	if (!href || href.length < 1 || href.charAt(0) != "/") {
    		throw Error("Invalid value for \"href\" attribute");
    	}

    	// Add # to every href attribute
    	node.setAttribute("href", "#" + href);
    }

    function nextTickPromise(cb) {
    	return new Promise(resolve => {
    			setTimeout(
    				() => {
    					resolve(cb());
    				},
    				0
    			);
    		});
    }

    function instance($$self, $$props, $$invalidate) {
    	let $loc,
    		$$unsubscribe_loc = noop;

    	validate_store(loc, "loc");
    	component_subscribe($$self, loc, $$value => $$invalidate(4, $loc = $$value));
    	$$self.$$.on_destroy.push(() => $$unsubscribe_loc());
    	let { routes = {} } = $$props;
    	let { prefix = "" } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent} component - Svelte component for the route
     */
    		constructor(path, component) {
    			if (!component || typeof component != "function" && (typeof component != "object" || component._sveltesparouter !== true)) {
    				throw Error("Invalid component object");
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == "string" && (path.length < 1 || path.charAt(0) != "/" && path.charAt(0) != "*") || typeof path == "object" && !(path instanceof RegExp)) {
    				throw Error("Invalid value for \"path\" argument");
    			}

    			const { pattern, keys } = regexparam(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == "object" && component._sveltesparouter === true) {
    				this.component = component.route;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    			} else {
    				this.component = component;
    				this.conditions = [];
    				this.userData = undefined;
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, remove it before we run the matching
    			if (prefix && path.startsWith(prefix)) {
    				path = path.substr(prefix.length) || "/";
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				out[this._keys[i]] = matches[++i] || null;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {SvelteComponent} component - Svelte component
     * @property {string} name - Name of the Svelte component
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {Object} [userData] - Custom data passed by the user
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {bool} Returns true if all the conditions succeeded
     */
    		checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	const dispatchNextTick = (name, detail) => {
    		// Execute this code when the current call stack is complete
    		setTimeout(
    			() => {
    				dispatch(name, detail);
    			},
    			0
    		);
    	};

    	const writable_props = ["routes", "prefix"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Router", $$slots, []);

    	function routeEvent_handler(event) {
    		bubble($$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("routes" in $$props) $$invalidate(2, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(3, prefix = $$props.prefix);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		derived,
    		wrap,
    		getLocation,
    		loc,
    		location: location$1,
    		querystring,
    		push,
    		pop,
    		replace,
    		link,
    		nextTickPromise,
    		createEventDispatcher,
    		regexparam,
    		routes,
    		prefix,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		dispatch,
    		dispatchNextTick,
    		$loc
    	});

    	$$self.$inject_state = $$props => {
    		if ("routes" in $$props) $$invalidate(2, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(3, prefix = $$props.prefix);
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("componentParams" in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*component, $loc*/ 17) {
    			// Handle hash change events
    			// Listen to changes in the $loc store and update the page
    			 {
    				// Find a route matching the location
    				$$invalidate(0, component = null);

    				let i = 0;

    				while (!component && i < routesList.length) {
    					const match = routesList[i].match($loc.location);

    					if (match) {
    						const detail = {
    							component: routesList[i].component,
    							name: routesList[i].component.name,
    							location: $loc.location,
    							querystring: $loc.querystring,
    							userData: routesList[i].userData
    						};

    						// Check if the route can be loaded - if all conditions succeed
    						if (!routesList[i].checkConditions(detail)) {
    							// Trigger an event to notify the user
    							dispatchNextTick("conditionsFailed", detail);

    							break;
    						}

    						$$invalidate(0, component = routesList[i].component);

    						// Set componentParams onloy if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    						// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    						if (match && typeof match == "object" && Object.keys(match).length) {
    							$$invalidate(1, componentParams = match);
    						} else {
    							$$invalidate(1, componentParams = null);
    						}

    						dispatchNextTick("routeLoaded", detail);
    					}

    					i++;
    				}
    			}
    		}
    	};

    	return [
    		component,
    		componentParams,
    		routes,
    		prefix,
    		$loc,
    		RouteItem,
    		routesList,
    		dispatch,
    		dispatchNextTick,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, { routes: 2, prefix: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var PouchDb;

    PouchDb = (function() {
      class PouchDb {
        stopSync() {
          var that;
          that = this;
          if (that.notifier != null) {
            that.notifier("Sync completed");
          }
          that.is_syncing = false;
          console.log("stop sync");
          if (that.sync_store != null) {
            that.sync_store.set(false);
          }
          if (that.sync_pending) {
            console.error("sync pending, resyncing");
            that.sync_pending = false;
            // sync again
            return that.sync(that);
          }
        }

        sync(scope) {
          var delayedEnd, that;
          console.log("PouchDb.sync");
          console.log(this.remote_db);
          if (scope != null) {
            that = scope;
          } else {
            that = this;
          }
          console.log(`current sync status: ${that.is_syncing}`);
          if (that.is_syncing) {
            console.error("CURRENTLY SYNCING");
            if (!that.sync_pending) {
              that.sync_pending = true;
              console.error("already pending, will not re-pend");
            }
            that.notifier("Currently syncing, will resync after current sync is complete.");
            return console.log("Currently syncing, will resync after current sync is complete.");
          } else {
            if (that.notifier != null) {
              that.notifier("Starting sync");
            }
            this.is_syncing = true;
            console.log(this.sync_store);
            this.sync_store.set(true);
            delayedEnd = function() {
              return that.stopSync();
            };
            if (this.remote_db != null) {
              console.log(`syncing to remote db ${this.is_syncing}`);
              return db.sync(this.remote_db, {
                retry: true
              }).on('complete', function() {
                console.log(`complete! ${that.is_syncing}`);
                return delayedEnd.delay(1000);
              }).on('change', function(change) {
                // yo, something changed!
                console.log("sync change");
                return console.log(change);
              }).on('paused', function(info) {
                // replication was paused, usually because of a lost connection
                console.log("sync paused");
                console.log(info);
                return delayedEnd.delay(1000);
              }).on('active', function(info) {
                // replication was resumed
                console.log("sync active");
                return console.log(info);
              }).on('error', function(err) {
                console.log("sync error");
                console.log(err);
                return delayedEnd.delay(1000);
              });
            }
          }
        }

        init() {
          if (localStorage.getItem("sync") != null) {
            this.sync_db = localStorage.getItem("sync") === "true";
            if (localStorage.getItem("sync") === "true") {
              console.log("Syncing enabled...");
              if (localStorage.getItem("remote_db") != null) {
                this.remote_db = localStorage.getItem("remote_db");
                console.log(`Trying to add remote db ${this.remote_db}`);
                if (this.remote_db.length > 0 && this.remote_db.startsWith("http")) {
                  console.log("declare remote_db");
                  window.remote_db = new PouchDB(this.remote_db);
                  console.log(this.remote_db);
                  return console.log(`Found to ${this.remote_db}`);
                } else {
                  return console.error("Remote db doesn't appear to be a URL");
                }
              } else {
                return console.error("remote_db not defined, even though sync is enabled");
              }
            } else {
              return console.warn("Syncing disabled");
            }
          } else {
            console.warn("Sync setting null, set to 'false'");
            return localStorage.setItem("sync", "false");
          }
        }

        constructor(local_db) {
          this.local_db = local_db;
          this.init();
        }

      }
      // todo: DRY this up
      PouchDb.prototype.local_db = void 0;

      PouchDb.prototype.remote_db = void 0;

      PouchDb.prototype.sync_pending = false; // in case a sync is running and another one needs to happen again

      PouchDb.prototype.sync_db = false;

      PouchDb.prototype.is_syncing = false;

      PouchDb.prototype.sync_store = void 0;

      PouchDb.prototype.notifier = void 0;

      return PouchDb;

    }).call(commonjsGlobal);

    var pouch_db = PouchDb;

    var createDatabaseInstance;

    createDatabaseInstance = function() {
      var cb;
      cb = function() {
        return console.log("Code mirror modes initialized");
      };
      const { subscribe, set, update } = writable(null);
      return new pouch_db(subscribe, set, update, cb);
    };

    const loader = createDatabaseInstance();

    const isSyncing = writable(false);

    /* src\svelte\components\FourOFour.svelte generated by Svelte v3.22.2 */

    const file = "src\\svelte\\components\\FourOFour.svelte";

    function create_fragment$1(ctx) {
    	let article;
    	let h1;
    	let p0;
    	let t1_value = JSON.stringify(/*params*/ ctx[0]) + "";
    	let t1;
    	let t2;
    	let p1;
    	let a;

    	const block = {
    		c: function create() {
    			article = element("article");
    			h1 = element("h1");
    			h1.textContent = "404!!!";
    			p0 = element("p");
    			t1 = text(t1_value);
    			t2 = text(" is an invalid path");
    			p1 = element("p");
    			a = element("a");
    			a.textContent = "Go home";
    			add_location(h1, file, 12, 9, 189);
    			attr_dev(p0, "class", "svelte-ylsox3");
    			add_location(p0, file, 12, 25, 205);
    			attr_dev(a, "href", "#/");
    			add_location(a, file, 12, 78, 258);
    			attr_dev(p1, "class", "svelte-ylsox3");
    			add_location(p1, file, 12, 75, 255);
    			attr_dev(article, "class", "svelte-ylsox3");
    			add_location(article, file, 12, 0, 180);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, article, anchor);
    			append_dev(article, h1);
    			append_dev(article, p0);
    			append_dev(p0, t1);
    			append_dev(p0, t2);
    			append_dev(article, p1);
    			append_dev(p1, a);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*params*/ 1 && t1_value !== (t1_value = JSON.stringify(/*params*/ ctx[0]) + "")) set_data_dev(t1, t1_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(article);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { params = {} } = $$props;
    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FourOFour> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FourOFour", $$slots, []);

    	$$self.$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({ params });

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [params];
    }

    class FourOFour extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FourOFour",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get params() {
    		throw new Error("<FourOFour>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<FourOFour>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Layout\LeftSplit.svelte generated by Svelte v3.22.2 */

    const file$1 = "src\\svelte\\components\\Layout\\LeftSplit.svelte";
    const get_nav_slot_changes = dirty => ({});
    const get_nav_slot_context = ctx => ({});

    // (40:69) nav
    function fallback_block_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("nav");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(40:69) nav",
    		ctx
    	});

    	return block;
    }

    // (41:40) content
    function fallback_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("content");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(41:40) content",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let main;
    	let nav;
    	let nav_class_value;
    	let t;
    	let section;
    	let section_class_value;
    	let current;
    	const nav_slot_template = /*$$slots*/ ctx[8].nav;
    	const nav_slot = create_slot(nav_slot_template, ctx, /*$$scope*/ ctx[7], get_nav_slot_context);
    	const nav_slot_or_fallback = nav_slot || fallback_block_1(ctx);
    	const default_slot_template = /*$$slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			nav = element("nav");
    			if (nav_slot_or_fallback) nav_slot_or_fallback.c();
    			t = space();
    			section = element("section");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(nav, "class", nav_class_value = "" + (null_to_empty(/*navClasses*/ ctx[1]) + " svelte-1mm6pew"));
    			set_style(nav, "width", /*navWidth*/ ctx[0]);
    			add_location(nav, file$1, 39, 2, 804);
    			attr_dev(section, "class", section_class_value = "" + (null_to_empty(/*contentClasses*/ ctx[2]) + " svelte-1mm6pew"));
    			add_location(section, file$1, 40, 2, 891);
    			attr_dev(main, "class", "svelte-1mm6pew");
    			add_location(main, file$1, 38, 0, 794);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, nav);

    			if (nav_slot_or_fallback) {
    				nav_slot_or_fallback.m(nav, null);
    			}

    			append_dev(main, t);
    			append_dev(main, section);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(section, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (nav_slot) {
    				if (nav_slot.p && dirty & /*$$scope*/ 128) {
    					nav_slot.p(get_slot_context(nav_slot_template, ctx, /*$$scope*/ ctx[7], get_nav_slot_context), get_slot_changes(nav_slot_template, /*$$scope*/ ctx[7], dirty, get_nav_slot_changes));
    				}
    			}

    			if (!current || dirty & /*navClasses*/ 2 && nav_class_value !== (nav_class_value = "" + (null_to_empty(/*navClasses*/ ctx[1]) + " svelte-1mm6pew"))) {
    				attr_dev(nav, "class", nav_class_value);
    			}

    			if (!current || dirty & /*navWidth*/ 1) {
    				set_style(nav, "width", /*navWidth*/ ctx[0]);
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[7], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null));
    				}
    			}

    			if (!current || dirty & /*contentClasses*/ 4 && section_class_value !== (section_class_value = "" + (null_to_empty(/*contentClasses*/ ctx[2]) + " svelte-1mm6pew"))) {
    				attr_dev(section, "class", section_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nav_slot_or_fallback, local);
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nav_slot_or_fallback, local);
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (nav_slot_or_fallback) nav_slot_or_fallback.d(detaching);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	var { headerSize = "100px" } = $$props;
    	var { footerSize = "100px" } = $$props;
    	var { contentScrollable = true } = $$props;
    	var { navWidth = "56px" } = $$props;
    	var { navClasses = void 0 } = $$props;
    	var { contentClasses = void 0 } = $$props;

    	const writable_props = [
    		"headerSize",
    		"footerSize",
    		"contentScrollable",
    		"navWidth",
    		"navClasses",
    		"contentClasses"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LeftSplit> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LeftSplit", $$slots, ['nav','default']);

    	$$self.$set = $$props => {
    		if ("headerSize" in $$props) $$invalidate(3, headerSize = $$props.headerSize);
    		if ("footerSize" in $$props) $$invalidate(4, footerSize = $$props.footerSize);
    		if ("contentScrollable" in $$props) $$invalidate(5, contentScrollable = $$props.contentScrollable);
    		if ("navWidth" in $$props) $$invalidate(0, navWidth = $$props.navWidth);
    		if ("navClasses" in $$props) $$invalidate(1, navClasses = $$props.navClasses);
    		if ("contentClasses" in $$props) $$invalidate(2, contentClasses = $$props.contentClasses);
    		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		headerSize,
    		footerSize,
    		contentScrollable,
    		navWidth,
    		navClasses,
    		contentClasses,
    		contentStyle
    	});

    	$$self.$inject_state = $$props => {
    		if ("headerSize" in $$props) $$invalidate(3, headerSize = $$props.headerSize);
    		if ("footerSize" in $$props) $$invalidate(4, footerSize = $$props.footerSize);
    		if ("contentScrollable" in $$props) $$invalidate(5, contentScrollable = $$props.contentScrollable);
    		if ("navWidth" in $$props) $$invalidate(0, navWidth = $$props.navWidth);
    		if ("navClasses" in $$props) $$invalidate(1, navClasses = $$props.navClasses);
    		if ("contentClasses" in $$props) $$invalidate(2, contentClasses = $$props.contentClasses);
    		if ("contentStyle" in $$props) contentStyle = $$props.contentStyle;
    	};

    	let contentStyle;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*contentScrollable*/ 32) {
    			 contentStyle = contentScrollable
    			? "overflow-y: scroll"
    			: "overflow-y: hidden";
    		}
    	};

    	return [
    		navWidth,
    		navClasses,
    		contentClasses,
    		headerSize,
    		footerSize,
    		contentScrollable,
    		contentStyle,
    		$$scope,
    		$$slots
    	];
    }

    class LeftSplit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
    			headerSize: 3,
    			footerSize: 4,
    			contentScrollable: 5,
    			navWidth: 0,
    			navClasses: 1,
    			contentClasses: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LeftSplit",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get headerSize() {
    		throw new Error("<LeftSplit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set headerSize(value) {
    		throw new Error("<LeftSplit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get footerSize() {
    		throw new Error("<LeftSplit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set footerSize(value) {
    		throw new Error("<LeftSplit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contentScrollable() {
    		throw new Error("<LeftSplit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contentScrollable(value) {
    		throw new Error("<LeftSplit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get navWidth() {
    		throw new Error("<LeftSplit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navWidth(value) {
    		throw new Error("<LeftSplit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get navClasses() {
    		throw new Error("<LeftSplit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set navClasses(value) {
    		throw new Error("<LeftSplit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contentClasses() {
    		throw new Error("<LeftSplit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contentClasses(value) {
    		throw new Error("<LeftSplit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function cubicInOut(t) {
        return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
    }
    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }
    function sineInOut(t) {
        return -0.5 * (Math.cos(Math.PI * t) - 1);
    }

    function fade(node, { delay = 0, duration = 400, easing = identity }) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }
    function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
            delay,
            duration,
            easing,
            css: t => `overflow: hidden;` +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `height: ${t * height}px;` +
                `padding-top: ${t * padding_top}px;` +
                `padding-bottom: ${t * padding_bottom}px;` +
                `margin-top: ${t * margin_top}px;` +
                `margin-bottom: ${t * margin_bottom}px;` +
                `border-top-width: ${t * border_top_width}px;` +
                `border-bottom-width: ${t * border_bottom_width}px;`
        };
    }
    function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 }) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const sd = 1 - start;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
        };
    }
    function draw(node, { delay = 0, speed, duration, easing = cubicInOut }) {
        const len = node.getTotalLength();
        if (duration === undefined) {
            if (speed === undefined) {
                duration = 800;
            }
            else {
                duration = len / speed;
            }
        }
        else if (typeof duration === 'function') {
            duration = duration(len);
        }
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `stroke-dasharray: ${t * len} ${u * len}`
        };
    }

    /* src\svelte\components\Toast\Toast.svelte generated by Svelte v3.22.2 */

    const { console: console_1$1 } = globals;
    const file$2 = "src\\svelte\\components\\Toast\\Toast.svelte";

    // (45:0) {#if show}
    function create_if_block$1(ctx) {
    	let div;
    	let div_intro;
    	let div_outro;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(div, "message", /*message*/ ctx[1]);
    			attr_dev(div, "class", "svelte-1h0fgoe");
    			add_location(div, file$2, 45, 1, 768);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[5], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null));
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*message*/ 2) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty & /*message*/ 2) {
    				attr_dev(div, "message", /*message*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);

    			add_render_callback(() => {
    				if (div_outro) div_outro.end(1);
    				if (!div_intro) div_intro = create_in_transition(div, fly, { y: 200, duration: 1000 });
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			if (div_intro) div_intro.invalidate();
    			div_outro = create_out_transition(div, fly, { y: 200, duration: 1000 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			if (detaching && div_outro) div_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(45:0) {#if show}",
    		ctx
    	});

    	return block;
    }

    // (47:8) {@html message}
    function fallback_block$1(ctx) {
    	let html_tag;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag(/*message*/ ctx[1], null);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(target, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*message*/ 2) html_tag.p(/*message*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(47:8) {@html message}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*show*/ ctx[0] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*show*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*show*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	var debouncedHide, hide;
    	var { show = false } = $$props;
    	var { message = "Flies in flies out" } = $$props;
    	var { delay = 6 } = $$props;

    	hide = function () {
    		$$invalidate(0, show = false);
    		return console.log(`HIDE: ${show}`);
    	};

    	debouncedHide = hide.debounce(delay.sToMilliseconds());

    	afterUpdate(function () {
    		console.log(`update ${show}`);

    		if (show) {
    			return debouncedHide();
    		}
    	});

    	const writable_props = ["show", "message", "delay"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Toast> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Toast", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("show" in $$props) $$invalidate(0, show = $$props.show);
    		if ("message" in $$props) $$invalidate(1, message = $$props.message);
    		if ("delay" in $$props) $$invalidate(2, delay = $$props.delay);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		debouncedHide,
    		hide,
    		fade,
    		fly,
    		afterUpdate,
    		show,
    		message,
    		delay
    	});

    	$$self.$inject_state = $$props => {
    		if ("debouncedHide" in $$props) debouncedHide = $$props.debouncedHide;
    		if ("hide" in $$props) hide = $$props.hide;
    		if ("show" in $$props) $$invalidate(0, show = $$props.show);
    		if ("message" in $$props) $$invalidate(1, message = $$props.message);
    		if ("delay" in $$props) $$invalidate(2, delay = $$props.delay);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [show, message, delay, debouncedHide, hide, $$scope, $$slots];
    }

    class Toast extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { show: 0, message: 1, delay: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Toast",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get show() {
    		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show(value) {
    		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get message() {
    		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get delay() {
    		throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set delay(value) {
    		throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Overlay\Popover\Popover.svelte generated by Svelte v3.22.2 */

    const { console: console_1$2 } = globals;
    const file$3 = "src\\svelte\\components\\Overlay\\Popover\\Popover.svelte";

    // (121:0) {#if show}
    function create_if_block$2(ctx) {
    	let div;
    	let div_transition;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[23].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[22], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "menu", "");
    			attr_dev(div, "id", /*menuId*/ ctx[2]);
    			attr_dev(div, "style", /*style*/ ctx[6]);
    			attr_dev(div, "align", /*align*/ ctx[1]);
    			attr_dev(div, "class", "svelte-6mt2ws");
    			add_location(div, file$3, 121, 2, 2727);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[24](div);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div,
    				"dragstart",
    				stop_propagation(prevent_default(function () {
    					if (is_function(/*noop*/ ctx[4])) /*noop*/ ctx[4].apply(this, arguments);
    				})),
    				false,
    				true,
    				true
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4194304) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[22], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[22], dirty, null));
    				}
    			}

    			if (!current || dirty & /*menuId*/ 4) {
    				attr_dev(div, "id", /*menuId*/ ctx[2]);
    			}

    			if (!current || dirty & /*style*/ 64) {
    				attr_dev(div, "style", /*style*/ ctx[6]);
    			}

    			if (!current || dirty & /*align*/ 2) {
    				attr_dev(div, "align", /*align*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 75 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 75 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[24](null);
    			if (detaching && div_transition) div_transition.end();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(121:0) {#if show}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let div;
    	let t;
    	let if_block_anchor;
    	let current;
    	let dispose;
    	let if_block = /*show*/ ctx[0] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(div, "type", "overlay");
    			attr_dev(div, "clear", "");
    			attr_dev(div, "open", /*show*/ ctx[0]);
    			attr_dev(div, "draggable", "false");
    			add_location(div, file$3, 119, 0, 2632);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div,
    				"click",
    				function () {
    					if (is_function(/*overlayClick*/ ctx[5])) /*overlayClick*/ ctx[5].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (!current || dirty & /*show*/ 1) {
    				attr_dev(div, "open", /*show*/ ctx[0]);
    			}

    			if (/*show*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*show*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	var changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		highlightedIndex,
    		menuId,
    		menuRef,
    		noop,
    		overlayClick,
    		style;

    	dispatch = createEventDispatcher();
    	var { disabled = false } = $$props;
    	var { id = uuid() } = $$props;
    	var { width = "200px" } = $$props;
    	var { selectedIndex = -1 } = $$props;
    	var { size = void 0 } = $$props;
    	var { value = "" } = $$props;
    	var { blankSlate = "" } = $$props;
    	var { labelKey = "label" } = $$props;
    	var { idKey = "id" } = $$props;
    	var { show = false } = $$props;
    	var { align = "left" } = $$props;
    	var { trigger = void 0 } = $$props;
    	style = void 0;
    	menuRef = void 0;
    	hasfocus = false;
    	highlightedIndex = -1;

    	changeIndex = function (direction) {
    		var index;
    		index = highlightedIndex + direction;

    		if (index < 0) {
    			index = items.length - 1;
    		} else if (index >= items.length) {
    			index = 0;
    		}

    		return highlightedIndex = index;
    	};

    	menuId = uuid();

    	onMount(function () {
    		
    	});

    	checkTrigger = function (i) {
    		var right, triggerContainerWidth, triggerCoords;

    		if (i != null) {
    			if (align === "left") {
    				return $$invalidate(6, style = `width: ${width};top: ${i.offsetParent.clientHeight + 4}px;`);
    			} else {
    				if (i.offsetParent != null) {
    					// console.log "offsetparent"
    					triggerContainerWidth = i.offsetParent.clientWidth;

    					triggerCoords = i.getBoundingClientRect();
    					right = triggerContainerWidth - triggerCoords.width;
    					return $$invalidate(6, style = `width: ${width};top: ${i.offsetParent.clientHeight + 4}px; right: ${right}px`);
    				} else {
    					// console.log "#{Date.create()} nooffsetparent"
    					// console.log i
    					// console.log u(i)
    					triggerContainerWidth = i.clientWidth;

    					triggerCoords = i.getBoundingClientRect();
    					right = triggerContainerWidth - triggerCoords.width;
    					return $$invalidate(6, style = `width: ${width};top: ${i.clientHeight + 4}px; right: ${right}px`);
    				}
    			}
    		}
    	};

    	overlayClick = function () {
    		$$invalidate(0, show = false);
    		return dispatch("close");
    	};

    	noop = function (e) {
    		return console.log(e);
    	};

    	const writable_props = [
    		"disabled",
    		"id",
    		"width",
    		"selectedIndex",
    		"size",
    		"value",
    		"blankSlate",
    		"labelKey",
    		"idKey",
    		"show",
    		"align",
    		"trigger"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Popover> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Popover", $$slots, ['default']);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(3, menuRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("disabled" in $$props) $$invalidate(7, disabled = $$props.disabled);
    		if ("id" in $$props) $$invalidate(8, id = $$props.id);
    		if ("width" in $$props) $$invalidate(9, width = $$props.width);
    		if ("selectedIndex" in $$props) $$invalidate(10, selectedIndex = $$props.selectedIndex);
    		if ("size" in $$props) $$invalidate(11, size = $$props.size);
    		if ("value" in $$props) $$invalidate(12, value = $$props.value);
    		if ("blankSlate" in $$props) $$invalidate(13, blankSlate = $$props.blankSlate);
    		if ("labelKey" in $$props) $$invalidate(14, labelKey = $$props.labelKey);
    		if ("idKey" in $$props) $$invalidate(15, idKey = $$props.idKey);
    		if ("show" in $$props) $$invalidate(0, show = $$props.show);
    		if ("align" in $$props) $$invalidate(1, align = $$props.align);
    		if ("trigger" in $$props) $$invalidate(16, trigger = $$props.trigger);
    		if ("$$scope" in $$props) $$invalidate(22, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		highlightedIndex,
    		menuId,
    		menuRef,
    		noop,
    		overlayClick,
    		style,
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		slide,
    		disabled,
    		id,
    		width,
    		selectedIndex,
    		size,
    		value,
    		blankSlate,
    		labelKey,
    		idKey,
    		show,
    		align,
    		trigger
    	});

    	$$self.$inject_state = $$props => {
    		if ("changeIndex" in $$props) changeIndex = $$props.changeIndex;
    		if ("checkTrigger" in $$props) $$invalidate(18, checkTrigger = $$props.checkTrigger);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("hasfocus" in $$props) hasfocus = $$props.hasfocus;
    		if ("highlightedIndex" in $$props) highlightedIndex = $$props.highlightedIndex;
    		if ("menuId" in $$props) $$invalidate(2, menuId = $$props.menuId);
    		if ("menuRef" in $$props) $$invalidate(3, menuRef = $$props.menuRef);
    		if ("noop" in $$props) $$invalidate(4, noop = $$props.noop);
    		if ("overlayClick" in $$props) $$invalidate(5, overlayClick = $$props.overlayClick);
    		if ("style" in $$props) $$invalidate(6, style = $$props.style);
    		if ("disabled" in $$props) $$invalidate(7, disabled = $$props.disabled);
    		if ("id" in $$props) $$invalidate(8, id = $$props.id);
    		if ("width" in $$props) $$invalidate(9, width = $$props.width);
    		if ("selectedIndex" in $$props) $$invalidate(10, selectedIndex = $$props.selectedIndex);
    		if ("size" in $$props) $$invalidate(11, size = $$props.size);
    		if ("value" in $$props) $$invalidate(12, value = $$props.value);
    		if ("blankSlate" in $$props) $$invalidate(13, blankSlate = $$props.blankSlate);
    		if ("labelKey" in $$props) $$invalidate(14, labelKey = $$props.labelKey);
    		if ("idKey" in $$props) $$invalidate(15, idKey = $$props.idKey);
    		if ("show" in $$props) $$invalidate(0, show = $$props.show);
    		if ("align" in $$props) $$invalidate(1, align = $$props.align);
    		if ("trigger" in $$props) $$invalidate(16, trigger = $$props.trigger);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*checkTrigger, trigger*/ 327680) {
    			 checkTrigger(trigger);
    		}
    	};

    	return [
    		show,
    		align,
    		menuId,
    		menuRef,
    		noop,
    		overlayClick,
    		style,
    		disabled,
    		id,
    		width,
    		selectedIndex,
    		size,
    		value,
    		blankSlate,
    		labelKey,
    		idKey,
    		trigger,
    		changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		highlightedIndex,
    		$$scope,
    		$$slots,
    		div_binding
    	];
    }

    class Popover extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			disabled: 7,
    			id: 8,
    			width: 9,
    			selectedIndex: 10,
    			size: 11,
    			value: 12,
    			blankSlate: 13,
    			labelKey: 14,
    			idKey: 15,
    			show: 0,
    			align: 1,
    			trigger: 16
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Popover",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get disabled() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedIndex() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedIndex(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blankSlate() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blankSlate(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelKey() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelKey(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get idKey() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set idKey(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get show() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trigger() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trigger(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function getBoundingClientRect(element) {
      var rect = element.getBoundingClientRect();
      return {
        width: rect.width,
        height: rect.height,
        top: rect.top,
        right: rect.right,
        bottom: rect.bottom,
        left: rect.left,
        x: rect.left,
        y: rect.top
      };
    }

    /*:: import type { Window } from '../types'; */

    /*:: declare function getWindow(node: Node | Window): Window; */
    function getWindow(node) {
      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView : window;
      }

      return node;
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    /*:: declare function isElement(node: mixed): boolean %checks(node instanceof
      Element); */

    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }
    /*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof
      HTMLElement); */


    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getDocumentElement(element) {
      // $FlowFixMe: assume body is always available
      return (isElement(element) ? element.ownerDocument : element.document).documentElement;
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    // Composite means it takes into account transforms as well as layout.

    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement);
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    // Returns the layout rect of an element relative to its offsetParent. Layout
    // means it doesn't take into account transforms.
    function getLayoutRect(element) {
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: element.offsetWidth,
        height: element.offsetHeight
      };
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || // DOM Element detected
        // $FlowFixMe: need a better way to handle this...
        element.host || // ShadowRoot detected
        // $FlowFixMe: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the 
    reference element's position.
    */

    function listScrollParents(element, list) {
      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = getNodeName(scrollParent) === 'body';
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }

      var offsetParent = element.offsetParent;

      if (offsetParent) {
        var html = getDocumentElement(offsetParent);

        if (getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && getComputedStyle$1(html).position !== 'static') {
          return html;
        }
      }

      return offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var currentNode = getParentNode(element);

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.

        if (css.transform !== 'none' || css.perspective !== 'none' || css.willChange && css.willChange !== 'auto') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static') {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function format(str) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return [].concat(args).reduce(function (p, c) {
        return p.replace(/%s/, c);
      }, str);
    }

    var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
    var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
    var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
    function validateModifiers(modifiers) {
      modifiers.forEach(function (modifier) {
        Object.keys(modifier).forEach(function (key) {
          switch (key) {
            case 'name':
              if (typeof modifier.name !== 'string') {
                console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
              }

              break;

            case 'enabled':
              if (typeof modifier.enabled !== 'boolean') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
              }

            case 'phase':
              if (modifierPhases.indexOf(modifier.phase) < 0) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
              }

              break;

            case 'fn':
              if (typeof modifier.fn !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'effect':
              if (typeof modifier.effect !== 'function') {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
              }

              break;

            case 'requires':
              if (!Array.isArray(modifier.requires)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
              }

              break;

            case 'requiresIfExists':
              if (!Array.isArray(modifier.requiresIfExists)) {
                console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
              }

              break;

            case 'options':
            case 'data':
              break;

            default:
              console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
                return "\"" + s + "\"";
              }).join(', ') + "; but \"" + key + "\" was provided.");
          }

          modifier.requires && modifier.requires.forEach(function (requirement) {
            if (modifiers.find(function (mod) {
              return mod.name === requirement;
            }) == null) {
              console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
            }
          });
        });
      });
    }

    function uniqueBy(arr, fn) {
      var identifiers = new Set();
      return arr.filter(function (item) {
        var identifier = fn(item);

        if (!identifiers.has(identifier)) {
          identifiers.add(identifier);
          return true;
        }
      });
    }

    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign(Object.assign(Object.assign({}, existing), current), {}, {
          options: Object.assign(Object.assign({}, existing.options), current.options),
          data: Object.assign(Object.assign({}, existing.data), current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    function getViewportRect(element) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
      // can be obscured underneath it.
      // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
      // if it isn't open, so if this isn't available, the popper will be detected
      // to overflow the bottom of the screen too early.

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
        // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
        // errors due to floating point numbers, so we need to check precision.
        // Safari returns a number <= 0, usually < -1 when pinch-zoomed
        // Feature detection fails in mobile emulation mode in Chrome.
        // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
        // 0.001
        // Fallback here: "Not Safari" userAgent

        if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = element.ownerDocument.body;
      var width = Math.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = Math.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += Math.max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function contains(parent, child) {
      // $FlowFixMe: hasOwnProperty doesn't seem to work in tests
      var isShadow = Boolean(child.getRootNode && child.getRootNode().host); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (isShadow) {
          var next = child;

          do {
            if (next && parent.isSameNode(next)) {
              return true;
            } // $FlowFixMe: need a better way to handle this...


            next = next.parentNode || next.host;
          } while (next);
        } // Give up, the result is false


      return false;
    }

    function rectToClientRect(rect) {
      return Object.assign(Object.assign({}, rect), {}, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element) {
      var rect = getBoundingClientRect(element);
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement(clipperElement)) {
        return [];
      } // $FlowFixMe: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent);
        accRect.top = Math.max(rect.top, accRect.top);
        accRect.right = Math.min(rect.right, accRect.right);
        accRect.bottom = Math.min(rect.bottom, accRect.bottom);
        accRect.left = Math.max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start:
            offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign(Object.assign({}, getFreshSideObject()), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var referenceElement = state.elements.reference;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
      var referenceClientRect = getBoundingClientRect(referenceElement);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
    var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(options) {
            cleanupModifierEffects();
            state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options);
            state.scrollParents = {
              reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned
            // if one of the modifiers is invalid for any reason

            {
              var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
                var name = _ref.name;
                return name;
              });
              validateModifiers(modifiers);

              if (getBasePlacement(state.options.placement) === auto) {
                var flipModifier = state.orderedModifiers.find(function (_ref2) {
                  var name = _ref2.name;
                  return name === 'flip';
                });

                if (!flipModifier) {
                  console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
                }
              }

              var _getComputedStyle = getComputedStyle$1(popper),
                  marginTop = _getComputedStyle.marginTop,
                  marginRight = _getComputedStyle.marginRight,
                  marginBottom = _getComputedStyle.marginBottom,
                  marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
              // cause bugs with positioning, so we'll warn the consumer


              if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
                return parseFloat(margin);
              })) {
                console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
              }
            }

            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {
              {
                console.error(INVALID_ELEMENT_ERROR);
              }

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            var __debug_loops__ = 0;

            for (var index = 0; index < state.orderedModifiers.length; index++) {
              {
                __debug_loops__ += 1;

                if (__debug_loops__ > 100) {
                  console.error(INFINITE_LOOP_ERROR);
                  break;
                }
              }

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {
          {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name;
      // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsets(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: Math.round(x * dpr) / dpr || 0,
        y: Math.round(y * dpr) / dpr || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive;

      var _roundOffsets = roundOffsets(offsets),
          x = _roundOffsets.x,
          y = _roundOffsets.y;

      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);
        } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

        /*:: offsetParent = (offsetParent: Element); */


        if (placement === top) {
          sideY = bottom;
          y -= offsetParent.clientHeight - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left) {
          sideX = right;
          x -= offsetParent.clientWidth - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref3) {
      var state = _ref3.state,
          options = _ref3.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive;

      {
        var transitionProperty = getComputedStyle$1(state.elements.popper).transitionProperty || '';

        if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
          return transitionProperty.indexOf(property) >= 0;
        })) {
          console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
        }
      }

      var commonStyles = {
        placement: getBasePlacement(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false
        })));
      }

      state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$1(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          } // Flow doesn't support to extend this property, but it's the most
          // effective way to apply styles to an HTMLElement
          // $FlowFixMe


          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$1,
      requires: ['computeStyles']
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign(Object.assign({}, rects), {}, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash$2 = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash$2[matched];
      });
    }

    /*:: type OverflowsMap = { [ComputedPlacement]: number }; */

    /*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */
    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements; // $FlowFixMe

      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;

        {
          console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
        }
      } // $FlowFixMe: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement(placement);

        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function within(min, value, max) {
      return Math.max(min, Math.min(value, max));
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign(Object.assign({}, state.rects), {}, {
        placement: state.placement
      })) : tetherOffset;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis) {
        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min = popperOffsets[mainAxis] + overflow[mainSide];
        var max = popperOffsets[mainAxis] - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
        var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
      }

      if (checkAltAxis) {
        var _mainSide = mainAxis === 'x' ? top : left;

        var _altSide = mainAxis === 'x' ? bottom : right;

        var _offset = popperOffsets[altAxis];

        var _min = _offset + overflow[_mainSide];

        var _max = _offset - overflow[_altSide];

        var _preventedOffset = within(_min, _offset, _max);

        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = state.modifiersData[name + "#persistent"].padding;
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$2(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,
          _options$padding = options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      {
        if (!isHTMLElement(arrowElement)) {
          console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
        }
      }

      if (!contains(state.elements.popper, arrowElement)) {
        {
          console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
        }

        return;
      }

      state.elements.arrow = arrowElement;
      state.modifiersData[name + "#persistent"] = {
        padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))
      };
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$2,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    /**!
    * tippy.js v6.2.5
    * (c) 2017-2020 atomiks
    * MIT License
    */
    var BOX_CLASS = "tippy-box";
    var CONTENT_CLASS = "tippy-content";
    var BACKDROP_CLASS = "tippy-backdrop";
    var ARROW_CLASS = "tippy-arrow";
    var SVG_ARROW_CLASS = "tippy-svg-arrow";
    var TOUCH_OPTIONS = {
      passive: true,
      capture: true
    };

    function hasOwnProperty(obj, key) {
      return {}.hasOwnProperty.call(obj, key);
    }
    function getValueAtIndexOrReturn(value, index, defaultValue) {
      if (Array.isArray(value)) {
        var v = value[index];
        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
      }

      return value;
    }
    function isType(value, type) {
      var str = {}.toString.call(value);
      return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
    }
    function invokeWithArgsOrReturn(value, args) {
      return typeof value === 'function' ? value.apply(void 0, args) : value;
    }
    function debounce$1(fn, ms) {
      // Avoid wrapping in `setTimeout` if ms is 0 anyway
      if (ms === 0) {
        return fn;
      }

      var timeout;
      return function (arg) {
        clearTimeout(timeout);
        timeout = setTimeout(function () {
          fn(arg);
        }, ms);
      };
    }
    function removeProperties(obj, keys) {
      var clone = Object.assign({}, obj);
      keys.forEach(function (key) {
        delete clone[key];
      });
      return clone;
    }
    function splitBySpaces(value) {
      return value.split(/\s+/).filter(Boolean);
    }
    function normalizeToArray(value) {
      return [].concat(value);
    }
    function pushIfUnique(arr, value) {
      if (arr.indexOf(value) === -1) {
        arr.push(value);
      }
    }
    function unique(arr) {
      return arr.filter(function (item, index) {
        return arr.indexOf(item) === index;
      });
    }
    function getBasePlacement$1(placement) {
      return placement.split('-')[0];
    }
    function arrayFrom(value) {
      return [].slice.call(value);
    }
    function removeUndefinedProps(obj) {
      return Object.keys(obj).reduce(function (acc, key) {
        if (obj[key] !== undefined) {
          acc[key] = obj[key];
        }

        return acc;
      }, {});
    }

    function div() {
      return document.createElement('div');
    }
    function isElement$1(value) {
      return ['Element', 'Fragment'].some(function (type) {
        return isType(value, type);
      });
    }
    function isNodeList(value) {
      return isType(value, 'NodeList');
    }
    function isMouseEvent(value) {
      return isType(value, 'MouseEvent');
    }
    function isReferenceElement(value) {
      return !!(value && value._tippy && value._tippy.reference === value);
    }
    function getArrayOfElements(value) {
      if (isElement$1(value)) {
        return [value];
      }

      if (isNodeList(value)) {
        return arrayFrom(value);
      }

      if (Array.isArray(value)) {
        return value;
      }

      return arrayFrom(document.querySelectorAll(value));
    }
    function setTransitionDuration(els, value) {
      els.forEach(function (el) {
        if (el) {
          el.style.transitionDuration = value + "ms";
        }
      });
    }
    function setVisibilityState(els, state) {
      els.forEach(function (el) {
        if (el) {
          el.setAttribute('data-state', state);
        }
      });
    }
    function getOwnerDocument(elementOrElements) {
      var _normalizeToArray = normalizeToArray(elementOrElements),
          element = _normalizeToArray[0];

      return element ? element.ownerDocument || document : document;
    }
    function isCursorOutsideInteractiveBorder(popperTreeData, event) {
      var clientX = event.clientX,
          clientY = event.clientY;
      return popperTreeData.every(function (_ref) {
        var popperRect = _ref.popperRect,
            popperState = _ref.popperState,
            props = _ref.props;
        var interactiveBorder = props.interactiveBorder;
        var basePlacement = getBasePlacement$1(popperState.placement);
        var offsetData = popperState.modifiersData.offset;

        if (!offsetData) {
          return true;
        }

        var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
        var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
        var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
        var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
      });
    }
    function updateTransitionEndListener(box, action, listener) {
      var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
      // `webkitTransitionEnd`...

      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
        box[method](event, listener);
      });
    }

    var currentInput = {
      isTouch: false
    };
    var lastMouseMoveTime = 0;
    /**
     * When a `touchstart` event is fired, it's assumed the user is using touch
     * input. We'll bind a `mousemove` event listener to listen for mouse input in
     * the future. This way, the `isTouch` property is fully dynamic and will handle
     * hybrid devices that use a mix of touch + mouse input.
     */

    function onDocumentTouchStart() {
      if (currentInput.isTouch) {
        return;
      }

      currentInput.isTouch = true;

      if (window.performance) {
        document.addEventListener('mousemove', onDocumentMouseMove);
      }
    }
    /**
     * When two `mousemove` event are fired consecutively within 20ms, it's assumed
     * the user is using mouse input again. `mousemove` can fire on touch devices as
     * well, but very rarely that quickly.
     */

    function onDocumentMouseMove() {
      var now = performance.now();

      if (now - lastMouseMoveTime < 20) {
        currentInput.isTouch = false;
        document.removeEventListener('mousemove', onDocumentMouseMove);
      }

      lastMouseMoveTime = now;
    }
    /**
     * When an element is in focus and has a tippy, leaving the tab/window and
     * returning causes it to show again. For mouse users this is unexpected, but
     * for keyboard use it makes sense.
     * TODO: find a better technique to solve this problem
     */

    function onWindowBlur() {
      var activeElement = document.activeElement;

      if (isReferenceElement(activeElement)) {
        var instance = activeElement._tippy;

        if (activeElement.blur && !instance.state.isVisible) {
          activeElement.blur();
        }
      }
    }
    function bindGlobalEventListeners() {
      document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
      window.addEventListener('blur', onWindowBlur);
    }

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
    var ua = isBrowser ? navigator.userAgent : '';
    var isIE = /MSIE |Trident\//.test(ua);

    function createMemoryLeakWarning(method) {
      var txt = method === 'destroy' ? 'n already-' : ' ';
      return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", 'indicates a potential memory leak.'].join(' ');
    }
    function clean(value) {
      var spacesAndTabs = /[ \t]{2,}/g;
      var lineStartWithSpaces = /^[ \t]*/gm;
      return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
    }

    function getDevMessage(message) {
      return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
    }

    function getFormattedMessage(message) {
      return [getDevMessage(message), // title
      'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
      'line-height: 1.5', // footer
      'color: #a6a095;'];
    } // Assume warnings and errors never have the same message

    var visitedMessages;

    {
      resetVisitedMessages();
    }

    function resetVisitedMessages() {
      visitedMessages = new Set();
    }
    function warnWhen(condition, message) {
      if (condition && !visitedMessages.has(message)) {
        var _console;

        visitedMessages.add(message);

        (_console = console).warn.apply(_console, getFormattedMessage(message));
      }
    }
    function errorWhen(condition, message) {
      if (condition && !visitedMessages.has(message)) {
        var _console2;

        visitedMessages.add(message);

        (_console2 = console).error.apply(_console2, getFormattedMessage(message));
      }
    }
    function validateTargets(targets) {
      var didPassFalsyValue = !targets;
      var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
      errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));
      errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));
    }

    var pluginProps = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    };
    var renderProps = {
      allowHTML: false,
      animation: 'fade',
      arrow: true,
      content: '',
      inertia: false,
      maxWidth: 350,
      role: 'tooltip',
      theme: '',
      zIndex: 9999
    };
    var defaultProps = Object.assign({
      appendTo: function appendTo() {
        return document.body;
      },
      aria: {
        content: 'auto',
        expanded: 'auto'
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: '',
      offset: [0, 10],
      onAfterUpdate: function onAfterUpdate() {},
      onBeforeUpdate: function onBeforeUpdate() {},
      onCreate: function onCreate() {},
      onDestroy: function onDestroy() {},
      onHidden: function onHidden() {},
      onHide: function onHide() {},
      onMount: function onMount() {},
      onShow: function onShow() {},
      onShown: function onShown() {},
      onTrigger: function onTrigger() {},
      onUntrigger: function onUntrigger() {},
      onClickOutside: function onClickOutside() {},
      placement: 'top',
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: 'mouseenter focus',
      triggerTarget: null
    }, pluginProps, {}, renderProps);
    var defaultKeys = Object.keys(defaultProps);
    var setDefaultProps = function setDefaultProps(partialProps) {
      /* istanbul ignore else */
      {
        validateProps(partialProps, []);
      }

      var keys = Object.keys(partialProps);
      keys.forEach(function (key) {
        defaultProps[key] = partialProps[key];
      });
    };
    function getExtendedPassedProps(passedProps) {
      var plugins = passedProps.plugins || [];
      var pluginProps = plugins.reduce(function (acc, plugin) {
        var name = plugin.name,
            defaultValue = plugin.defaultValue;

        if (name) {
          acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
        }

        return acc;
      }, {});
      return Object.assign({}, passedProps, {}, pluginProps);
    }
    function getDataAttributeProps(reference, plugins) {
      var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
        plugins: plugins
      }))) : defaultKeys;
      var props = propKeys.reduce(function (acc, key) {
        var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

        if (!valueAsString) {
          return acc;
        }

        if (key === 'content') {
          acc[key] = valueAsString;
        } else {
          try {
            acc[key] = JSON.parse(valueAsString);
          } catch (e) {
            acc[key] = valueAsString;
          }
        }

        return acc;
      }, {});
      return props;
    }
    function evaluateProps(reference, props) {
      var out = Object.assign({}, props, {
        content: invokeWithArgsOrReturn(props.content, [reference])
      }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
      out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
      out.aria = {
        expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
        content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
      };
      return out;
    }
    function validateProps(partialProps, plugins) {
      if (partialProps === void 0) {
        partialProps = {};
      }

      if (plugins === void 0) {
        plugins = [];
      }

      var keys = Object.keys(partialProps);
      keys.forEach(function (prop) {
        var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
        var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

        if (didPassUnknownProp) {
          didPassUnknownProp = plugins.filter(function (plugin) {
            return plugin.name === prop;
          }).length === 0;
        }

        warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", 'a plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));
      });
    }

    var innerHTML = function innerHTML() {
      return 'innerHTML';
    };

    function dangerouslySetInnerHTML(element, html) {
      element[innerHTML()] = html;
    }

    function createArrowElement(value) {
      var arrow = div();

      if (value === true) {
        arrow.className = ARROW_CLASS;
      } else {
        arrow.className = SVG_ARROW_CLASS;

        if (isElement$1(value)) {
          arrow.appendChild(value);
        } else {
          dangerouslySetInnerHTML(arrow, value);
        }
      }

      return arrow;
    }

    function setContent(content, props) {
      if (isElement$1(props.content)) {
        dangerouslySetInnerHTML(content, '');
        content.appendChild(props.content);
      } else if (typeof props.content !== 'function') {
        if (props.allowHTML) {
          dangerouslySetInnerHTML(content, props.content);
        } else {
          content.textContent = props.content;
        }
      }
    }
    function getChildren(popper) {
      var box = popper.firstElementChild;
      var boxChildren = arrayFrom(box.children);
      return {
        box: box,
        content: boxChildren.find(function (node) {
          return node.classList.contains(CONTENT_CLASS);
        }),
        arrow: boxChildren.find(function (node) {
          return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
        }),
        backdrop: boxChildren.find(function (node) {
          return node.classList.contains(BACKDROP_CLASS);
        })
      };
    }
    function render(instance) {
      var popper = div();
      var box = div();
      box.className = BOX_CLASS;
      box.setAttribute('data-state', 'hidden');
      box.setAttribute('tabindex', '-1');
      var content = div();
      content.className = CONTENT_CLASS;
      content.setAttribute('data-state', 'hidden');
      setContent(content, instance.props);
      popper.appendChild(box);
      box.appendChild(content);
      onUpdate(instance.props, instance.props);

      function onUpdate(prevProps, nextProps) {
        var _getChildren = getChildren(popper),
            box = _getChildren.box,
            content = _getChildren.content,
            arrow = _getChildren.arrow;

        if (nextProps.theme) {
          box.setAttribute('data-theme', nextProps.theme);
        } else {
          box.removeAttribute('data-theme');
        }

        if (typeof nextProps.animation === 'string') {
          box.setAttribute('data-animation', nextProps.animation);
        } else {
          box.removeAttribute('data-animation');
        }

        if (nextProps.inertia) {
          box.setAttribute('data-inertia', '');
        } else {
          box.removeAttribute('data-inertia');
        }

        box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

        if (nextProps.role) {
          box.setAttribute('role', nextProps.role);
        } else {
          box.removeAttribute('role');
        }

        if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
          setContent(content, instance.props);
        }

        if (nextProps.arrow) {
          if (!arrow) {
            box.appendChild(createArrowElement(nextProps.arrow));
          } else if (prevProps.arrow !== nextProps.arrow) {
            box.removeChild(arrow);
            box.appendChild(createArrowElement(nextProps.arrow));
          }
        } else if (arrow) {
          box.removeChild(arrow);
        }
      }

      return {
        popper: popper,
        onUpdate: onUpdate
      };
    } // Runtime check to identify if the render function is the default one; this
    // way we can apply default CSS transitions logic and it can be tree-shaken away

    render.$$tippy = true;

    var idCounter = 1;
    var mouseMoveListeners = []; // Used by `hideAll()`

    var mountedInstances = [];
    function createTippy(reference, passedProps) {
      var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
      // 🔒 Private members
      // ===========================================================================

      var showTimeout;
      var hideTimeout;
      var scheduleHideAnimationFrame;
      var isVisibleFromClick = false;
      var didHideDueToDocumentMouseDown = false;
      var didTouchMove = false;
      var ignoreOnFirstUpdate = false;
      var lastTriggerEvent;
      var currentTransitionEndListener;
      var onFirstUpdate;
      var listeners = [];
      var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce);
      var currentTarget;
      var doc = getOwnerDocument(props.triggerTarget || reference); // ===========================================================================
      // 🔑 Public members
      // ===========================================================================

      var id = idCounter++;
      var popperInstance = null;
      var plugins = unique(props.plugins);
      var state = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      };
      var instance = {
        // properties
        id: id,
        reference: reference,
        popper: div(),
        popperInstance: popperInstance,
        props: props,
        state: state,
        plugins: plugins,
        // methods
        clearDelayTimeouts: clearDelayTimeouts,
        setProps: setProps,
        setContent: setContent,
        show: show,
        hide: hide,
        hideWithInteractivity: hideWithInteractivity,
        enable: enable,
        disable: disable,
        unmount: unmount,
        destroy: destroy
      }; // TODO: Investigate why this early return causes a TDZ error in the tests —
      // it doesn't seem to happen in the browser

      /* istanbul ignore if */

      if (!props.render) {
        {
          errorWhen(true, 'render() function has not been supplied.');
        }

        return instance;
      } // ===========================================================================
      // Initial mutations
      // ===========================================================================


      var _props$render = props.render(instance),
          popper = _props$render.popper,
          onUpdate = _props$render.onUpdate;

      popper.setAttribute('data-tippy-root', '');
      popper.id = "tippy-" + instance.id;
      instance.popper = popper;
      reference._tippy = instance;
      popper._tippy = instance;
      var pluginsHooks = plugins.map(function (plugin) {
        return plugin.fn(instance);
      });
      var hasAriaExpanded = reference.hasAttribute('aria-expanded');
      addListeners();
      handleAriaExpandedAttribute();
      handleStyles();
      invokeHook('onCreate', [instance]);

      if (props.showOnCreate) {
        scheduleShow();
      } // Prevent a tippy with a delay from hiding if the cursor left then returned
      // before it started hiding


      popper.addEventListener('mouseenter', function () {
        if (instance.props.interactive && instance.state.isVisible) {
          instance.clearDelayTimeouts();
        }
      });
      popper.addEventListener('mouseleave', function (event) {
        if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
          doc.addEventListener('mousemove', debouncedOnMouseMove);
          debouncedOnMouseMove(event);
        }
      });
      return instance; // ===========================================================================
      // 🔒 Private methods
      // ===========================================================================

      function getNormalizedTouchSettings() {
        var touch = instance.props.touch;
        return Array.isArray(touch) ? touch : [touch, 0];
      }

      function getIsCustomTouchBehavior() {
        return getNormalizedTouchSettings()[0] === 'hold';
      }

      function getIsDefaultRenderFn() {
        var _instance$props$rende;

        // @ts-ignore
        return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
      }

      function getCurrentTarget() {
        return currentTarget || reference;
      }

      function getDefaultTemplateChildren() {
        return getChildren(popper);
      }

      function getDelay(isShow) {
        // For touch or keyboard input, force `0` delay for UX reasons
        // Also if the instance is mounted but not visible (transitioning out),
        // ignore delay
        if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
          return 0;
        }

        return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
      }

      function handleStyles() {
        popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? '' : 'none';
        popper.style.zIndex = "" + instance.props.zIndex;
      }

      function invokeHook(hook, args, shouldInvokePropsHook) {
        if (shouldInvokePropsHook === void 0) {
          shouldInvokePropsHook = true;
        }

        pluginsHooks.forEach(function (pluginHooks) {
          if (pluginHooks[hook]) {
            pluginHooks[hook].apply(void 0, args);
          }
        });

        if (shouldInvokePropsHook) {
          var _instance$props;

          (_instance$props = instance.props)[hook].apply(_instance$props, args);
        }
      }

      function handleAriaContentAttribute() {
        var aria = instance.props.aria;

        if (!aria.content) {
          return;
        }

        var attr = "aria-" + aria.content;
        var id = popper.id;
        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          var currentValue = node.getAttribute(attr);

          if (instance.state.isVisible) {
            node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
          } else {
            var nextValue = currentValue && currentValue.replace(id, '').trim();

            if (nextValue) {
              node.setAttribute(attr, nextValue);
            } else {
              node.removeAttribute(attr);
            }
          }
        });
      }

      function handleAriaExpandedAttribute() {
        if (hasAriaExpanded || !instance.props.aria.expanded) {
          return;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          if (instance.props.interactive) {
            node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
          } else {
            node.removeAttribute('aria-expanded');
          }
        });
      }

      function cleanupInteractiveMouseListeners() {
        doc.removeEventListener('mousemove', debouncedOnMouseMove);
        mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
          return listener !== debouncedOnMouseMove;
        });
      }

      function onDocumentPress(event) {
        // Moved finger to scroll instead of an intentional tap outside
        if (currentInput.isTouch) {
          if (didTouchMove || event.type === 'mousedown') {
            return;
          }
        } // Clicked on interactive popper


        if (instance.props.interactive && popper.contains(event.target)) {
          return;
        } // Clicked on the event listeners target


        if (getCurrentTarget().contains(event.target)) {
          if (currentInput.isTouch) {
            return;
          }

          if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
            return;
          }
        } else {
          invokeHook('onClickOutside', [instance, event]);
        }

        if (instance.props.hideOnClick === true) {
          isVisibleFromClick = false;
          instance.clearDelayTimeouts();
          instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
          // currentTarget. This lets a tippy with `focus` trigger know that it
          // should not show

          didHideDueToDocumentMouseDown = true;
          setTimeout(function () {
            didHideDueToDocumentMouseDown = false;
          }); // The listener gets added in `scheduleShow()`, but this may be hiding it
          // before it shows, and hide()'s early bail-out behavior can prevent it
          // from being cleaned up

          if (!instance.state.isMounted) {
            removeDocumentPress();
          }
        }
      }

      function onTouchMove() {
        didTouchMove = true;
      }

      function onTouchStart() {
        didTouchMove = false;
      }

      function addDocumentPress() {
        doc.addEventListener('mousedown', onDocumentPress, true);
        doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function removeDocumentPress() {
        doc.removeEventListener('mousedown', onDocumentPress, true);
        doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function onTransitionedOut(duration, callback) {
        onTransitionEnd(duration, function () {
          if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
            callback();
          }
        });
      }

      function onTransitionedIn(duration, callback) {
        onTransitionEnd(duration, callback);
      }

      function onTransitionEnd(duration, callback) {
        var box = getDefaultTemplateChildren().box;

        function listener(event) {
          if (event.target === box) {
            updateTransitionEndListener(box, 'remove', listener);
            callback();
          }
        } // Make callback synchronous if duration is 0
        // `transitionend` won't fire otherwise


        if (duration === 0) {
          return callback();
        }

        updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
        updateTransitionEndListener(box, 'add', listener);
        currentTransitionEndListener = listener;
      }

      function on(eventType, handler, options) {
        if (options === void 0) {
          options = false;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          node.addEventListener(eventType, handler, options);
          listeners.push({
            node: node,
            eventType: eventType,
            handler: handler,
            options: options
          });
        });
      }

      function addListeners() {
        if (getIsCustomTouchBehavior()) {
          on('touchstart', onTrigger, {
            passive: true
          });
          on('touchend', onMouseLeave, {
            passive: true
          });
        }

        splitBySpaces(instance.props.trigger).forEach(function (eventType) {
          if (eventType === 'manual') {
            return;
          }

          on(eventType, onTrigger);

          switch (eventType) {
            case 'mouseenter':
              on('mouseleave', onMouseLeave);
              break;

            case 'focus':
              on(isIE ? 'focusout' : 'blur', onBlurOrFocusOut);
              break;

            case 'focusin':
              on('focusout', onBlurOrFocusOut);
              break;
          }
        });
      }

      function removeListeners() {
        listeners.forEach(function (_ref) {
          var node = _ref.node,
              eventType = _ref.eventType,
              handler = _ref.handler,
              options = _ref.options;
          node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
      }

      function onTrigger(event) {
        var _lastTriggerEvent;

        var shouldScheduleClickHide = false;

        if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
          return;
        }

        var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
        lastTriggerEvent = event;
        currentTarget = event.currentTarget;
        handleAriaExpandedAttribute();

        if (!instance.state.isVisible && isMouseEvent(event)) {
          // If scrolling, `mouseenter` events can be fired if the cursor lands
          // over a new target, but `mousemove` events don't get fired. This
          // causes interactive tooltips to get stuck open until the cursor is
          // moved
          mouseMoveListeners.forEach(function (listener) {
            return listener(event);
          });
        } // Toggle show/hide when clicking click-triggered tooltips


        if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
          shouldScheduleClickHide = true;
        } else {
          scheduleShow(event);
        }

        if (event.type === 'click') {
          isVisibleFromClick = !shouldScheduleClickHide;
        }

        if (shouldScheduleClickHide && !wasFocused) {
          scheduleHide(event);
        }
      }

      function onMouseMove(event) {
        var target = event.target;
        var isCursorOverReferenceOrPopper = reference.contains(target) || popper.contains(target);

        if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
          return;
        }

        var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
          var _instance$popperInsta;

          var instance = popper._tippy;
          var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

          if (state) {
            return {
              popperRect: popper.getBoundingClientRect(),
              popperState: state,
              props: props
            };
          }

          return null;
        }).filter(Boolean);

        if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
          cleanupInteractiveMouseListeners();
          scheduleHide(event);
        }
      }

      function onMouseLeave(event) {
        var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

        if (shouldBail) {
          return;
        }

        if (instance.props.interactive) {
          instance.hideWithInteractivity(event);
          return;
        }

        scheduleHide(event);
      }

      function onBlurOrFocusOut(event) {
        if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
          return;
        } // If focus was moved to within the popper


        if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
          return;
        }

        scheduleHide(event);
      }

      function isEventListenerStopped(event) {
        return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
      }

      function createPopperInstance() {
        destroyPopperInstance();
        var _instance$props2 = instance.props,
            popperOptions = _instance$props2.popperOptions,
            placement = _instance$props2.placement,
            offset = _instance$props2.offset,
            getReferenceClientRect = _instance$props2.getReferenceClientRect,
            moveTransition = _instance$props2.moveTransition;
        var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
        var computedReference = getReferenceClientRect ? {
          getBoundingClientRect: getReferenceClientRect,
          contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
        } : reference;
        var tippyModifier = {
          name: '$$tippy',
          enabled: true,
          phase: 'beforeWrite',
          requires: ['computeStyles'],
          fn: function fn(_ref2) {
            var state = _ref2.state;

            if (getIsDefaultRenderFn()) {
              var _getDefaultTemplateCh = getDefaultTemplateChildren(),
                  box = _getDefaultTemplateCh.box;

              ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
                if (attr === 'placement') {
                  box.setAttribute('data-placement', state.placement);
                } else {
                  if (state.attributes.popper["data-popper-" + attr]) {
                    box.setAttribute("data-" + attr, '');
                  } else {
                    box.removeAttribute("data-" + attr);
                  }
                }
              });
              state.attributes.popper = {};
            }
          }
        };
        var modifiers = [{
          name: 'offset',
          options: {
            offset: offset
          }
        }, {
          name: 'preventOverflow',
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: 'flip',
          options: {
            padding: 5
          }
        }, {
          name: 'computeStyles',
          options: {
            adaptive: !moveTransition
          }
        }, tippyModifier];

        if (getIsDefaultRenderFn() && arrow) {
          modifiers.push({
            name: 'arrow',
            options: {
              element: arrow,
              padding: 3
            }
          });
        }

        modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
        instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
          placement: placement,
          onFirstUpdate: onFirstUpdate,
          modifiers: modifiers
        }));
      }

      function destroyPopperInstance() {
        if (instance.popperInstance) {
          instance.popperInstance.destroy();
          instance.popperInstance = null;
        }
      }

      function mount() {
        var appendTo = instance.props.appendTo;
        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
        // it's directly after the reference element so the elements inside the
        // tippy can be tabbed to
        // If there are clipping issues, the user can specify a different appendTo
        // and ensure focus management is handled correctly manually

        var node = getCurrentTarget();

        if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
          parentNode = node.parentNode;
        } else {
          parentNode = invokeWithArgsOrReturn(appendTo, [node]);
        } // The popper element needs to exist on the DOM before its position can be
        // updated as Popper needs to read its dimensions


        if (!parentNode.contains(popper)) {
          parentNode.appendChild(popper);
        }

        createPopperInstance();
        /* istanbul ignore else */

        {
          // Accessibility check
          warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));
        }
      }

      function getNestedPopperTree() {
        return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
      }

      function scheduleShow(event) {
        instance.clearDelayTimeouts();

        if (event) {
          invokeHook('onTrigger', [instance, event]);
        }

        addDocumentPress();
        var delay = getDelay(true);

        var _getNormalizedTouchSe = getNormalizedTouchSettings(),
            touchValue = _getNormalizedTouchSe[0],
            touchDelay = _getNormalizedTouchSe[1];

        if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
          delay = touchDelay;
        }

        if (delay) {
          showTimeout = setTimeout(function () {
            instance.show();
          }, delay);
        } else {
          instance.show();
        }
      }

      function scheduleHide(event) {
        instance.clearDelayTimeouts();
        invokeHook('onUntrigger', [instance, event]);

        if (!instance.state.isVisible) {
          removeDocumentPress();
          return;
        } // For interactive tippies, scheduleHide is added to a document.body handler
        // from onMouseLeave so must intercept scheduled hides from mousemove/leave
        // events when trigger contains mouseenter and click, and the tip is
        // currently shown as a result of a click.


        if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
          return;
        }

        var delay = getDelay(false);

        if (delay) {
          hideTimeout = setTimeout(function () {
            if (instance.state.isVisible) {
              instance.hide();
            }
          }, delay);
        } else {
          // Fixes a `transitionend` problem when it fires 1 frame too
          // late sometimes, we don't want hide() to be called.
          scheduleHideAnimationFrame = requestAnimationFrame(function () {
            instance.hide();
          });
        }
      } // ===========================================================================
      // 🔑 Public methods
      // ===========================================================================


      function enable() {
        instance.state.isEnabled = true;
      }

      function disable() {
        // Disabling the instance should also hide it
        // https://github.com/atomiks/tippy.js-react/issues/106
        instance.hide();
        instance.state.isEnabled = false;
      }

      function clearDelayTimeouts() {
        clearTimeout(showTimeout);
        clearTimeout(hideTimeout);
        cancelAnimationFrame(scheduleHideAnimationFrame);
      }

      function setProps(partialProps) {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
        }

        if (instance.state.isDestroyed) {
          return;
        }

        invokeHook('onBeforeUpdate', [instance, partialProps]);
        removeListeners();
        var prevProps = instance.props;
        var nextProps = evaluateProps(reference, Object.assign({}, instance.props, {}, partialProps, {
          ignoreAttributes: true
        }));
        instance.props = nextProps;
        addListeners();

        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
          cleanupInteractiveMouseListeners();
          debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce);
        } // Ensure stale aria-expanded attributes are removed


        if (prevProps.triggerTarget && !nextProps.triggerTarget) {
          normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
            node.removeAttribute('aria-expanded');
          });
        } else if (nextProps.triggerTarget) {
          reference.removeAttribute('aria-expanded');
        }

        handleAriaExpandedAttribute();
        handleStyles();

        if (onUpdate) {
          onUpdate(prevProps, nextProps);
        }

        if (instance.popperInstance) {
          createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
          // and the nested ones get re-rendered first.
          // https://github.com/atomiks/tippyjs-react/issues/177
          // TODO: find a cleaner / more efficient solution(!)

          getNestedPopperTree().forEach(function (nestedPopper) {
            // React (and other UI libs likely) requires a rAF wrapper as it flushes
            // its work in one
            requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
          });
        }

        invokeHook('onAfterUpdate', [instance, partialProps]);
      }

      function setContent(content) {
        instance.setProps({
          content: content
        });
      }

      function show() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
        } // Early bail-out


        var isAlreadyVisible = instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
          return;
        } // Normalize `disabled` behavior across browsers.
        // Firefox allows events on disabled elements, but Chrome doesn't.
        // Using a wrapper element (i.e. <span>) is recommended.


        if (getCurrentTarget().hasAttribute('disabled')) {
          return;
        }

        invokeHook('onShow', [instance], false);

        if (instance.props.onShow(instance) === false) {
          return;
        }

        instance.state.isVisible = true;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'visible';
        }

        handleStyles();
        addDocumentPress();

        if (!instance.state.isMounted) {
          popper.style.transition = 'none';
        } // If flipping to the opposite side after hiding at least once, the
        // animation will use the wrong placement without resetting the duration


        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh2.box,
              content = _getDefaultTemplateCh2.content;

          setTransitionDuration([box, content], 0);
        }

        onFirstUpdate = function onFirstUpdate() {
          if (!instance.state.isVisible || ignoreOnFirstUpdate) {
            return;
          }

          ignoreOnFirstUpdate = true; // reflow

          void popper.offsetHeight;
          popper.style.transition = instance.props.moveTransition;

          if (getIsDefaultRenderFn() && instance.props.animation) {
            var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
                _box = _getDefaultTemplateCh3.box,
                _content = _getDefaultTemplateCh3.content;

            setTransitionDuration([_box, _content], duration);
            setVisibilityState([_box, _content], 'visible');
          }

          handleAriaContentAttribute();
          handleAriaExpandedAttribute();
          pushIfUnique(mountedInstances, instance);
          instance.state.isMounted = true;
          invokeHook('onMount', [instance]);

          if (instance.props.animation && getIsDefaultRenderFn()) {
            onTransitionedIn(duration, function () {
              instance.state.isShown = true;
              invokeHook('onShown', [instance]);
            });
          }
        };

        mount();
      }

      function hide() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
        } // Early bail-out


        var isAlreadyHidden = !instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

        if (isAlreadyHidden || isDestroyed || isDisabled) {
          return;
        }

        invokeHook('onHide', [instance], false);

        if (instance.props.onHide(instance) === false) {
          return;
        }

        instance.state.isVisible = false;
        instance.state.isShown = false;
        ignoreOnFirstUpdate = false;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'hidden';
        }

        cleanupInteractiveMouseListeners();
        removeDocumentPress();
        handleStyles();

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh4.box,
              content = _getDefaultTemplateCh4.content;

          if (instance.props.animation) {
            setTransitionDuration([box, content], duration);
            setVisibilityState([box, content], 'hidden');
          }
        }

        handleAriaContentAttribute();
        handleAriaExpandedAttribute();

        if (instance.props.animation) {
          if (getIsDefaultRenderFn()) {
            onTransitionedOut(duration, instance.unmount);
          }
        } else {
          instance.unmount();
        }
      }

      function hideWithInteractivity(event) {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
        }

        doc.addEventListener('mousemove', debouncedOnMouseMove);
        pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
        debouncedOnMouseMove(event);
      }

      function unmount() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
        }

        if (instance.state.isVisible) {
          instance.hide();
        }

        if (!instance.state.isMounted) {
          return;
        }

        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
        // tree by default. This seems mainly for interactive tippies, but we should
        // find a workaround if possible

        getNestedPopperTree().forEach(function (nestedPopper) {
          nestedPopper._tippy.unmount();
        });

        if (popper.parentNode) {
          popper.parentNode.removeChild(popper);
        }

        mountedInstances = mountedInstances.filter(function (i) {
          return i !== instance;
        });
        instance.state.isMounted = false;
        invokeHook('onHidden', [instance]);
      }

      function destroy() {
        /* istanbul ignore else */
        {
          warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
        }

        if (instance.state.isDestroyed) {
          return;
        }

        instance.clearDelayTimeouts();
        instance.unmount();
        removeListeners();
        delete reference._tippy;
        instance.state.isDestroyed = true;
        invokeHook('onDestroy', [instance]);
      }
    }

    function tippy(targets, optionalProps) {
      if (optionalProps === void 0) {
        optionalProps = {};
      }

      var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
      /* istanbul ignore else */

      {
        validateTargets(targets);
        validateProps(optionalProps, plugins);
      }

      bindGlobalEventListeners();
      var passedProps = Object.assign({}, optionalProps, {
        plugins: plugins
      });
      var elements = getArrayOfElements(targets);
      /* istanbul ignore else */

      {
        var isSingleContentElement = isElement$1(passedProps.content);
        var isMoreThanOneReferenceElement = elements.length > 1;
        warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
      }

      var instances = elements.reduce(function (acc, reference) {
        var instance = reference && createTippy(reference, passedProps);

        if (instance) {
          acc.push(instance);
        }

        return acc;
      }, []);
      return isElement$1(targets) ? instances[0] : instances;
    }

    tippy.defaultProps = defaultProps;
    tippy.setDefaultProps = setDefaultProps;
    tippy.currentInput = currentInput;

    tippy.setDefaultProps({
      render: render
    });

    /* src\svelte\components\Overlay\Tooltip\Tooltip.svelte generated by Svelte v3.22.2 */

    const { console: console_1$3 } = globals;
    const file$4 = "src\\svelte\\components\\Overlay\\Tooltip\\Tooltip.svelte";

    function create_fragment$5(ctx) {
    	let span;
    	let div;
    	let tooltip_action;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			span = element("span");
    			div = element("div");
    			if (default_slot) default_slot.c();
    			add_location(div, file$4, 30, 2, 647);
    			attr_dev(span, "data-tippy-content", "Tooltip");
    			add_location(span, file$4, 29, 0, 609);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, span, anchor);
    			append_dev(span, div);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    			if (remount) dispose();
    			dispose = action_destroyer(tooltip_action = /*tooltip*/ ctx[0].call(null, div));
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[3], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	var element, tooltip;
    	var { content = void 0 } = $$props;
    	element = void 0;

    	tooltip = function (element) {
    		tippy(element, { content, allowHTML: true });

    		return {
    			destroy() {
    				return console.log("destroyed");
    			}
    		};
    	};

    	const writable_props = ["content"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Tooltip> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Tooltip", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("content" in $$props) $$invalidate(1, content = $$props.content);
    		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		element,
    		tooltip,
    		onMount,
    		tippy,
    		content
    	});

    	$$self.$inject_state = $$props => {
    		if ("element" in $$props) element = $$props.element;
    		if ("tooltip" in $$props) $$invalidate(0, tooltip = $$props.tooltip);
    		if ("content" in $$props) $$invalidate(1, content = $$props.content);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [tooltip, content, element, $$scope, $$slots];
    }

    class Tooltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { content: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tooltip",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get content() {
    		throw new Error("<Tooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<Tooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\SideNavigator.svelte generated by Svelte v3.22.2 */

    const { console: console_1$4 } = globals;
    const file$5 = "src\\svelte\\pages\\_Common\\SideNavigator.svelte";

    // (67:4) <Tooltip position="right" content="Home">
    function create_default_slot_5(ctx) {
    	let a;
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			a = element("a");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M10,20V14H14V20H19V12H22L12,3L2,12H5V20H10Z");
    			attr_dev(path, "class", "svelte-jlwhz0");
    			add_location(path, file$5, 68, 91, 1527);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$5, 68, 8, 1444);
    			attr_dev(a, "href", "#/");
    			add_location(a, file$5, 67, 6, 1421);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, svg);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(67:4) <Tooltip position=\\\"right\\\" content=\\\"Home\\\">",
    		ctx
    	});

    	return block;
    }

    // (74:4) <Tooltip position="right" content="Collections">
    function create_default_slot_4(ctx) {
    	let a;
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			a = element("a");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M22,4H14L12,2H6A2,2 0 0,0 4,4V16A2,2 0 0,0 6,18H22A2,2 0 0,0 24,16V6A2,2 0 0,0 22,4M2,6H0V11H0V20A2,2 0 0,0 2,22H20V20H2V6Z");
    			attr_dev(path, "class", "svelte-jlwhz0");
    			add_location(path, file$5, 75, 89, 1836);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$5, 75, 6, 1753);
    			attr_dev(a, "href", "#/projects");
    			add_location(a, file$5, 74, 4, 1724);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, svg);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(74:4) <Tooltip position=\\\"right\\\" content=\\\"Collections\\\">",
    		ctx
    	});

    	return block;
    }

    // (81:4) <Tooltip position="right" content="Sync">
    function create_default_slot_3(ctx) {
    	let a;
    	let svg;
    	let path;
    	let svg_class_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M12,18A6,6 0 0,1 6,12C6,11 6.25,10.03 6.7,9.2L5.24,7.74C4.46,8.97 4,10.43 4,12A8,8 0 0,0 12,20V23L16,19L12,15M12,4V1L8,5L12,9V6A6,6 0 0,1 18,12C18,13 17.75,13.97 17.3,14.8L18.76,16.26C19.54,15.03 20,13.57 20,12A8,8 0 0,0 12,4Z");
    			attr_dev(path, "class", "svelte-jlwhz0");
    			add_location(path, file$5, 82, 118, 2237);
    			attr_dev(svg, "class", svg_class_value = "" + (null_to_empty(/*rotate*/ ctx[1]) + " svelte-jlwhz0"));
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$5, 82, 6, 2125);
    			attr_dev(a, "href", "#/sync");
    			add_location(a, file$5, 81, 4, 2100);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, svg);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rotate*/ 2 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*rotate*/ ctx[1]) + " svelte-jlwhz0"))) {
    				attr_dev(svg, "class", svg_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(81:4) <Tooltip position=\\\"right\\\" content=\\\"Sync\\\">",
    		ctx
    	});

    	return block;
    }

    // (88:4) <Tooltip position="right" content="Settings">
    function create_default_slot_2(ctx) {
    	let a;
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			a = element("a");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z");
    			attr_dev(path, "class", "svelte-jlwhz0");
    			add_location(path, file$5, 89, 91, 2729);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$5, 89, 8, 2646);
    			attr_dev(a, "href", "#/settings/");
    			add_location(a, file$5, 88, 6, 2614);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, svg);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(88:4) <Tooltip position=\\\"right\\\" content=\\\"Settings\\\">",
    		ctx
    	});

    	return block;
    }

    // (96:4) <Tooltip position="right" content="Toggle Dark Mode">
    function create_default_slot_1(ctx) {
    	let button;
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M12,8A4,4 0 0,0 8,12A4,4 0 0,0 12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8M12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31L23.31,12L20,8.69Z");
    			attr_dev(path, "class", "svelte-jlwhz0");
    			add_location(path, file$5, 97, 91, 3888);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$5, 97, 8, 3805);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$5, 96, 6, 3768);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(96:4) <Tooltip position=\\\"right\\\" content=\\\"Toggle Dark Mode\\\">",
    		ctx
    	});

    	return block;
    }

    // (105:4) <Tooltip position="right" content="Help">
    function create_default_slot(ctx) {
    	let a;
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			a = element("a");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M10,19H13V22H10V19M12,2C17.35,2.22 19.68,7.62 16.5,11.67C15.67,12.67 14.33,13.33 13.67,14.17C13,15 13,16 13,17H10C10,15.33 10,13.92 10.67,12.92C11.33,11.92 12.67,11.33 13.5,10.67C15.92,8.43 15.32,5.26 12,5A3,3 0 0,0 9,8H6A6,6 0 0,1 12,2Z");
    			attr_dev(path, "class", "svelte-jlwhz0");
    			add_location(path, file$5, 106, 93, 4397);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$5, 106, 10, 4314);
    			attr_dev(a, "href", "#/help/");
    			add_location(a, file$5, 105, 6, 4284);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, svg);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(105:4) <Tooltip position=\\\"right\\\" content=\\\"Help\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let ul;
    	let li0;
    	let li0_active_value;
    	let t0;
    	let li1;
    	let li1_active_value;
    	let t1;
    	let li2;
    	let li2_active_value;
    	let t2;
    	let li3;
    	let li3_active_value;
    	let t3;
    	let li4;
    	let t4;
    	let li5;
    	let li5_active_value;
    	let current;

    	const tooltip0 = new Tooltip({
    			props: {
    				position: "right",
    				content: "Home",
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const tooltip1 = new Tooltip({
    			props: {
    				position: "right",
    				content: "Collections",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const tooltip2 = new Tooltip({
    			props: {
    				position: "right",
    				content: "Sync",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const tooltip3 = new Tooltip({
    			props: {
    				position: "right",
    				content: "Settings",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const tooltip4 = new Tooltip({
    			props: {
    				position: "right",
    				content: "Toggle Dark Mode",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const tooltip5 = new Tooltip({
    			props: {
    				position: "right",
    				content: "Help",
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			create_component(tooltip0.$$.fragment);
    			t0 = space();
    			li1 = element("li");
    			create_component(tooltip1.$$.fragment);
    			t1 = space();
    			li2 = element("li");
    			create_component(tooltip2.$$.fragment);
    			t2 = space();
    			li3 = element("li");
    			create_component(tooltip3.$$.fragment);
    			t3 = space();
    			li4 = element("li");
    			create_component(tooltip4.$$.fragment);
    			t4 = space();
    			li5 = element("li");
    			create_component(tooltip5.$$.fragment);
    			attr_dev(li0, "active", li0_active_value = [""].includes(/*current*/ ctx[0]));
    			attr_dev(li0, "class", "svelte-jlwhz0");
    			add_location(li0, file$5, 65, 2, 1330);
    			attr_dev(li1, "active", li1_active_value = /*current*/ ctx[0] == "projects");
    			attr_dev(li1, "class", "svelte-jlwhz0");
    			add_location(li1, file$5, 72, 2, 1629);
    			attr_dev(li2, "active", li2_active_value = /*current*/ ctx[0] == "sync");
    			attr_dev(li2, "class", "svelte-jlwhz0");
    			add_location(li2, file$5, 79, 2, 2016);
    			attr_dev(li3, "active", li3_active_value = /*current*/ ctx[0] == "settings");
    			attr_dev(li3, "class", "svelte-jlwhz0");
    			add_location(li3, file$5, 86, 2, 2520);
    			attr_dev(li4, "class", "svelte-jlwhz0");
    			add_location(li4, file$5, 94, 2, 3697);
    			attr_dev(li5, "active", li5_active_value = /*current*/ ctx[0] == "help");
    			attr_dev(li5, "class", "svelte-jlwhz0");
    			add_location(li5, file$5, 103, 2, 4198);
    			attr_dev(ul, "class", "svelte-jlwhz0");
    			add_location(ul, file$5, 63, 0, 1320);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			mount_component(tooltip0, li0, null);
    			append_dev(ul, t0);
    			append_dev(ul, li1);
    			mount_component(tooltip1, li1, null);
    			append_dev(ul, t1);
    			append_dev(ul, li2);
    			mount_component(tooltip2, li2, null);
    			append_dev(ul, t2);
    			append_dev(ul, li3);
    			mount_component(tooltip3, li3, null);
    			append_dev(ul, t3);
    			append_dev(ul, li4);
    			mount_component(tooltip4, li4, null);
    			append_dev(ul, t4);
    			append_dev(ul, li5);
    			mount_component(tooltip5, li5, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tooltip0_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				tooltip0_changes.$$scope = { dirty, ctx };
    			}

    			tooltip0.$set(tooltip0_changes);

    			if (!current || dirty & /*current*/ 1 && li0_active_value !== (li0_active_value = [""].includes(/*current*/ ctx[0]))) {
    				attr_dev(li0, "active", li0_active_value);
    			}

    			const tooltip1_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				tooltip1_changes.$$scope = { dirty, ctx };
    			}

    			tooltip1.$set(tooltip1_changes);

    			if (!current || dirty & /*current*/ 1 && li1_active_value !== (li1_active_value = /*current*/ ctx[0] == "projects")) {
    				attr_dev(li1, "active", li1_active_value);
    			}

    			const tooltip2_changes = {};

    			if (dirty & /*$$scope, rotate*/ 66) {
    				tooltip2_changes.$$scope = { dirty, ctx };
    			}

    			tooltip2.$set(tooltip2_changes);

    			if (!current || dirty & /*current*/ 1 && li2_active_value !== (li2_active_value = /*current*/ ctx[0] == "sync")) {
    				attr_dev(li2, "active", li2_active_value);
    			}

    			const tooltip3_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				tooltip3_changes.$$scope = { dirty, ctx };
    			}

    			tooltip3.$set(tooltip3_changes);

    			if (!current || dirty & /*current*/ 1 && li3_active_value !== (li3_active_value = /*current*/ ctx[0] == "settings")) {
    				attr_dev(li3, "active", li3_active_value);
    			}

    			const tooltip4_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				tooltip4_changes.$$scope = { dirty, ctx };
    			}

    			tooltip4.$set(tooltip4_changes);
    			const tooltip5_changes = {};

    			if (dirty & /*$$scope*/ 64) {
    				tooltip5_changes.$$scope = { dirty, ctx };
    			}

    			tooltip5.$set(tooltip5_changes);

    			if (!current || dirty & /*current*/ 1 && li5_active_value !== (li5_active_value = /*current*/ ctx[0] == "help")) {
    				attr_dev(li5, "active", li5_active_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip0.$$.fragment, local);
    			transition_in(tooltip1.$$.fragment, local);
    			transition_in(tooltip2.$$.fragment, local);
    			transition_in(tooltip3.$$.fragment, local);
    			transition_in(tooltip4.$$.fragment, local);
    			transition_in(tooltip5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip0.$$.fragment, local);
    			transition_out(tooltip1.$$.fragment, local);
    			transition_out(tooltip2.$$.fragment, local);
    			transition_out(tooltip3.$$.fragment, local);
    			transition_out(tooltip4.$$.fragment, local);
    			transition_out(tooltip5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_component(tooltip0);
    			destroy_component(tooltip1);
    			destroy_component(tooltip2);
    			destroy_component(tooltip3);
    			destroy_component(tooltip4);
    			destroy_component(tooltip5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $location;
    	validate_store(location$1, "location");
    	component_subscribe($$self, location$1, $$value => $$invalidate(5, $location = $$value));
    	var dispatch, subscribe, syncing;
    	dispatch = createEventDispatcher();
    	console.log("isSyncing");
    	console.log(isSyncing);
    	syncing = void 0;

    	subscribe = isSyncing.subscribe(function (val) {
    		return $$invalidate(4, syncing = val);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<SideNavigator> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SideNavigator", $$slots, []);

    	$$self.$capture_state = () => ({
    		dispatch,
    		subscribe,
    		syncing,
    		location: location$1,
    		createEventDispatcher,
    		isSyncing,
    		Tooltip,
    		current,
    		$location,
    		rotate
    	});

    	$$self.$inject_state = $$props => {
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("subscribe" in $$props) subscribe = $$props.subscribe;
    		if ("syncing" in $$props) $$invalidate(4, syncing = $$props.syncing);
    		if ("current" in $$props) $$invalidate(0, current = $$props.current);
    		if ("rotate" in $$props) $$invalidate(1, rotate = $$props.rotate);
    	};

    	let current;
    	let rotate;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$location*/ 32) {
    			 $$invalidate(0, current = $location.split("/")[1]);
    		}

    		if ($$self.$$.dirty & /*syncing*/ 16) {
    			 $$invalidate(1, rotate = syncing ? "rotate" : null);
    		}
    	};

    	return [current, rotate];
    }

    class SideNavigator extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SideNavigator",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src\svelte\pages\_Common\PageContent.svelte generated by Svelte v3.22.2 */

    const file$6 = "src\\svelte\\pages\\_Common\\PageContent.svelte";

    function create_fragment$7(ctx) {
    	let section;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			section = element("section");
    			if (default_slot) default_slot.c();
    			attr_dev(section, "level", "root");
    			attr_dev(section, "class", "svelte-15x7fzu");
    			add_location(section, file$6, 5, 0, 46);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);

    			if (default_slot) {
    				default_slot.m(section, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[0], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PageContent> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("PageContent", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class PageContent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PageContent",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src\svelte\pages\_Common\PageHeader.svelte generated by Svelte v3.22.2 */

    const file$7 = "src\\svelte\\pages\\_Common\\PageHeader.svelte";
    const get_secondary_info_slot_changes = dirty => ({});
    const get_secondary_info_slot_context = ctx => ({});
    const get_icon_slot_changes = dirty => ({});
    const get_icon_slot_context = ctx => ({});
    const get_subtitle_slot_changes = dirty => ({});
    const get_subtitle_slot_context = ctx => ({});

    // (5:2) {#if subtitle}
    function create_if_block$3(ctx) {
    	let h6;
    	let t_value = /*subtitle*/ ctx[0].titleize().singularize() + "";
    	let t;

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			t = text(t_value);
    			attr_dev(h6, "class", "svelte-1rft5a4");
    			add_location(h6, file$7, 5, 2, 97);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			append_dev(h6, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*subtitle*/ 1 && t_value !== (t_value = /*subtitle*/ ctx[0].titleize().singularize() + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(5:2) {#if subtitle}",
    		ctx
    	});

    	return block;
    }

    // (10:42) <div style="width: 32px"/>
    function fallback_block$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_style(div, "width", "32px");
    			add_location(div, file$7, 9, 42, 239);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(10:42) <div style=\\\"width: 32px\\\"/>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let header;
    	let t0;
    	let t1;
    	let div2;
    	let div0;
    	let t2;
    	let div1;
    	let h1;
    	let t3;
    	let current;
    	let if_block = /*subtitle*/ ctx[0] && create_if_block$3(ctx);
    	const subtitle_slot_template = /*$$slots*/ ctx[2].subtitle;
    	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[1], get_subtitle_slot_context);
    	const icon_slot_template = /*$$slots*/ ctx[2].icon;
    	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[1], get_icon_slot_context);
    	const icon_slot_or_fallback = icon_slot || fallback_block$2(ctx);
    	const default_slot_template = /*$$slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);
    	const secondary_info_slot_template = /*$$slots*/ ctx[2]["secondary-info"];
    	const secondary_info_slot = create_slot(secondary_info_slot_template, ctx, /*$$scope*/ ctx[1], get_secondary_info_slot_context);

    	const block = {
    		c: function create() {
    			header = element("header");
    			if (if_block) if_block.c();
    			t0 = space();
    			if (subtitle_slot) subtitle_slot.c();
    			t1 = space();
    			div2 = element("div");
    			div0 = element("div");
    			if (icon_slot_or_fallback) icon_slot_or_fallback.c();
    			t2 = space();
    			div1 = element("div");
    			h1 = element("h1");
    			if (default_slot) default_slot.c();
    			t3 = space();
    			if (secondary_info_slot) secondary_info_slot.c();
    			attr_dev(div0, "flex", "initial");
    			attr_dev(div0, "class", "svelte-1rft5a4");
    			add_location(div0, file$7, 9, 4, 201);
    			attr_dev(h1, "class", "svelte-1rft5a4");
    			add_location(h1, file$7, 11, 6, 309);
    			attr_dev(div1, "flex", "");
    			attr_dev(div1, "ellipsis", "");
    			add_location(div1, file$7, 10, 4, 283);
    			attr_dev(div2, "layout", "row");
    			attr_dev(div2, "class", "svelte-1rft5a4");
    			add_location(div2, file$7, 8, 2, 178);
    			attr_dev(header, "class", "svelte-1rft5a4");
    			add_location(header, file$7, 3, 0, 69);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			if (if_block) if_block.m(header, null);
    			append_dev(header, t0);

    			if (subtitle_slot) {
    				subtitle_slot.m(header, null);
    			}

    			append_dev(header, t1);
    			append_dev(header, div2);
    			append_dev(div2, div0);

    			if (icon_slot_or_fallback) {
    				icon_slot_or_fallback.m(div0, null);
    			}

    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, h1);

    			if (default_slot) {
    				default_slot.m(h1, null);
    			}

    			append_dev(header, t3);

    			if (secondary_info_slot) {
    				secondary_info_slot.m(header, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*subtitle*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(header, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (subtitle_slot) {
    				if (subtitle_slot.p && dirty & /*$$scope*/ 2) {
    					subtitle_slot.p(get_slot_context(subtitle_slot_template, ctx, /*$$scope*/ ctx[1], get_subtitle_slot_context), get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[1], dirty, get_subtitle_slot_changes));
    				}
    			}

    			if (icon_slot) {
    				if (icon_slot.p && dirty & /*$$scope*/ 2) {
    					icon_slot.p(get_slot_context(icon_slot_template, ctx, /*$$scope*/ ctx[1], get_icon_slot_context), get_slot_changes(icon_slot_template, /*$$scope*/ ctx[1], dirty, get_icon_slot_changes));
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[1], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null));
    				}
    			}

    			if (secondary_info_slot) {
    				if (secondary_info_slot.p && dirty & /*$$scope*/ 2) {
    					secondary_info_slot.p(get_slot_context(secondary_info_slot_template, ctx, /*$$scope*/ ctx[1], get_secondary_info_slot_context), get_slot_changes(secondary_info_slot_template, /*$$scope*/ ctx[1], dirty, get_secondary_info_slot_changes));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(subtitle_slot, local);
    			transition_in(icon_slot_or_fallback, local);
    			transition_in(default_slot, local);
    			transition_in(secondary_info_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(subtitle_slot, local);
    			transition_out(icon_slot_or_fallback, local);
    			transition_out(default_slot, local);
    			transition_out(secondary_info_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			if (if_block) if_block.d();
    			if (subtitle_slot) subtitle_slot.d(detaching);
    			if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    			if (secondary_info_slot) secondary_info_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	var { subtitle = void 0 } = $$props;
    	const writable_props = ["subtitle"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PageHeader> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("PageHeader", $$slots, ['subtitle','icon','default','secondary-info']);

    	$$self.$set = $$props => {
    		if ("subtitle" in $$props) $$invalidate(0, subtitle = $$props.subtitle);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ subtitle });

    	$$self.$inject_state = $$props => {
    		if ("subtitle" in $$props) $$invalidate(0, subtitle = $$props.subtitle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [subtitle, $$scope, $$slots];
    }

    class PageHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { subtitle: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PageHeader",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get subtitle() {
    		throw new Error("<PageHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitle(value) {
    		throw new Error("<PageHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Indent.svelte generated by Svelte v3.22.2 */

    const file$8 = "src\\svelte\\pages\\_Common\\Indent.svelte";

    function create_fragment$9(ctx) {
    	let div;
    	let div_indent_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "indent", div_indent_value = /*indentation*/ ctx[0] || 0);
    			set_style(div, "width", /*indentation*/ ctx[0] + "px");
    			add_location(div, file$8, 6, 0, 129);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*indentation*/ 1 && div_indent_value !== (div_indent_value = /*indentation*/ ctx[0] || 0)) {
    				attr_dev(div, "indent", div_indent_value);
    			}

    			if (dirty & /*indentation*/ 1) {
    				set_style(div, "width", /*indentation*/ ctx[0] + "px");
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	var { level = void 0 } = $$props;
    	var { width = 24 } = $$props;
    	const writable_props = ["level", "width"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Indent> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Indent", $$slots, []);

    	$$self.$set = $$props => {
    		if ("level" in $$props) $$invalidate(1, level = $$props.level);
    		if ("width" in $$props) $$invalidate(2, width = $$props.width);
    	};

    	$$self.$capture_state = () => ({ level, width, indentation });

    	$$self.$inject_state = $$props => {
    		if ("level" in $$props) $$invalidate(1, level = $$props.level);
    		if ("width" in $$props) $$invalidate(2, width = $$props.width);
    		if ("indentation" in $$props) $$invalidate(0, indentation = $$props.indentation);
    	};

    	let indentation;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*level, width*/ 6) {
    			 $$invalidate(0, indentation = (level || 0) * width);
    		}
    	};

    	return [indentation, level, width];
    }

    class Indent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { level: 1, width: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Indent",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get level() {
    		throw new Error("<Indent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set level(value) {
    		throw new Error("<Indent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Indent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Indent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Overlay\Menu\ComposedMenu.svelte generated by Svelte v3.22.2 */
    const file$9 = "src\\svelte\\components\\Overlay\\Menu\\ComposedMenu.svelte";

    // (102:0) {#if showMenu}
    function create_if_block$4(ctx) {
    	let div;
    	let div_transition;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[25].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[24], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "menu", "");
    			attr_dev(div, "id", /*menuId*/ ctx[2]);
    			attr_dev(div, "style", /*style*/ ctx[5]);
    			attr_dev(div, "align", /*align*/ ctx[1]);
    			attr_dev(div, "class", "svelte-m27dee");
    			add_location(div, file$9, 102, 2, 2301);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[26](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16777216) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[24], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[24], dirty, null));
    				}
    			}

    			if (!current || dirty & /*menuId*/ 4) {
    				attr_dev(div, "id", /*menuId*/ ctx[2]);
    			}

    			if (!current || dirty & /*style*/ 32) {
    				attr_dev(div, "style", /*style*/ ctx[5]);
    			}

    			if (!current || dirty & /*align*/ 2) {
    				attr_dev(div, "align", /*align*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 75 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 75 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[26](null);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(102:0) {#if showMenu}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div;
    	let t;
    	let if_block_anchor;
    	let current;
    	let dispose;
    	let if_block = /*showMenu*/ ctx[0] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(div, "type", "overlay");
    			attr_dev(div, "clear", "");
    			attr_dev(div, "open", /*showMenu*/ ctx[0]);
    			add_location(div, file$9, 100, 0, 2216);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div,
    				"click",
    				function () {
    					if (is_function(/*overlayClick*/ ctx[4])) /*overlayClick*/ ctx[4].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (!current || dirty & /*showMenu*/ 1) {
    				attr_dev(div, "open", /*showMenu*/ ctx[0]);
    			}

    			if (/*showMenu*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showMenu*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	var changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		highlightedIndex,
    		menuId,
    		menuItemClick,
    		menuRef,
    		overlayClick,
    		style;

    	dispatch = createEventDispatcher();
    	var { disabled = false } = $$props;
    	var { id = uuid() } = $$props;
    	var { items = [] } = $$props;
    	var { width = "200px" } = $$props;
    	var { selectedIndex = -1 } = $$props;
    	var { size = void 0 } = $$props;
    	var { value = "" } = $$props;
    	var { blankSlate = "" } = $$props;
    	var { labelKey = "label" } = $$props;
    	var { idKey = "id" } = $$props;
    	var { showMenu = false } = $$props;
    	var { align = "left" } = $$props;
    	var { trigger = void 0 } = $$props;
    	var { matchTrigger = false } = $$props;
    	style = void 0;
    	menuRef = void 0;
    	hasfocus = false;
    	highlightedIndex = -1;

    	changeIndex = function (direction) {
    		var index;
    		index = highlightedIndex + direction;

    		if (index < 0) {
    			index = items.length - 1;
    		} else if (index >= items.length) {
    			index = 0;
    		}

    		return highlightedIndex = index;
    	};

    	menuId = uuid();

    	checkTrigger = function (i) {
    		var right, triggerContainerWidth, triggerCoords;

    		if (trigger != null) {
    			if (matchTrigger) {
    				return $$invalidate(5, style = `width: ${width};top: ${trigger.clientHeight + 4}px; width: ${trigger.clientWidth + 2}px`);
    			} else {
    				if (align === "left") {
    					//console.log trigger.offsetParent
    					//console.log trigger.offsetParent.clientHeight
    					return $$invalidate(5, style = `width: ${width};top: ${trigger.offsetParent.clientHeight + 4}px;`);
    				} else {
    					//console.log style
    					triggerContainerWidth = trigger.offsetParent.clientWidth;

    					triggerCoords = trigger.getBoundingClientRect();
    					right = triggerContainerWidth - triggerCoords.width;
    					return $$invalidate(5, style = `width: ${width};top: ${trigger.offsetParent.clientHeight + 4}px; right: ${right}px`);
    				}
    			}
    		}
    	};

    	menuItemClick = function (item, index) {
    		$$invalidate(0, showMenu = false);
    		return dispatch("click", item);
    	};

    	overlayClick = function () {
    		return $$invalidate(0, showMenu = false);
    	};

    	const writable_props = [
    		"disabled",
    		"id",
    		"items",
    		"width",
    		"selectedIndex",
    		"size",
    		"value",
    		"blankSlate",
    		"labelKey",
    		"idKey",
    		"showMenu",
    		"align",
    		"trigger",
    		"matchTrigger"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComposedMenu> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComposedMenu", $$slots, ['default']);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(3, menuRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("disabled" in $$props) $$invalidate(6, disabled = $$props.disabled);
    		if ("id" in $$props) $$invalidate(7, id = $$props.id);
    		if ("items" in $$props) $$invalidate(8, items = $$props.items);
    		if ("width" in $$props) $$invalidate(9, width = $$props.width);
    		if ("selectedIndex" in $$props) $$invalidate(10, selectedIndex = $$props.selectedIndex);
    		if ("size" in $$props) $$invalidate(11, size = $$props.size);
    		if ("value" in $$props) $$invalidate(12, value = $$props.value);
    		if ("blankSlate" in $$props) $$invalidate(13, blankSlate = $$props.blankSlate);
    		if ("labelKey" in $$props) $$invalidate(14, labelKey = $$props.labelKey);
    		if ("idKey" in $$props) $$invalidate(15, idKey = $$props.idKey);
    		if ("showMenu" in $$props) $$invalidate(0, showMenu = $$props.showMenu);
    		if ("align" in $$props) $$invalidate(1, align = $$props.align);
    		if ("trigger" in $$props) $$invalidate(16, trigger = $$props.trigger);
    		if ("matchTrigger" in $$props) $$invalidate(17, matchTrigger = $$props.matchTrigger);
    		if ("$$scope" in $$props) $$invalidate(24, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		highlightedIndex,
    		menuId,
    		menuItemClick,
    		menuRef,
    		overlayClick,
    		style,
    		createEventDispatcher,
    		slide,
    		disabled,
    		id,
    		items,
    		width,
    		selectedIndex,
    		size,
    		value,
    		blankSlate,
    		labelKey,
    		idKey,
    		showMenu,
    		align,
    		trigger,
    		matchTrigger
    	});

    	$$self.$inject_state = $$props => {
    		if ("changeIndex" in $$props) changeIndex = $$props.changeIndex;
    		if ("checkTrigger" in $$props) $$invalidate(19, checkTrigger = $$props.checkTrigger);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("hasfocus" in $$props) hasfocus = $$props.hasfocus;
    		if ("highlightedIndex" in $$props) highlightedIndex = $$props.highlightedIndex;
    		if ("menuId" in $$props) $$invalidate(2, menuId = $$props.menuId);
    		if ("menuItemClick" in $$props) menuItemClick = $$props.menuItemClick;
    		if ("menuRef" in $$props) $$invalidate(3, menuRef = $$props.menuRef);
    		if ("overlayClick" in $$props) $$invalidate(4, overlayClick = $$props.overlayClick);
    		if ("style" in $$props) $$invalidate(5, style = $$props.style);
    		if ("disabled" in $$props) $$invalidate(6, disabled = $$props.disabled);
    		if ("id" in $$props) $$invalidate(7, id = $$props.id);
    		if ("items" in $$props) $$invalidate(8, items = $$props.items);
    		if ("width" in $$props) $$invalidate(9, width = $$props.width);
    		if ("selectedIndex" in $$props) $$invalidate(10, selectedIndex = $$props.selectedIndex);
    		if ("size" in $$props) $$invalidate(11, size = $$props.size);
    		if ("value" in $$props) $$invalidate(12, value = $$props.value);
    		if ("blankSlate" in $$props) $$invalidate(13, blankSlate = $$props.blankSlate);
    		if ("labelKey" in $$props) $$invalidate(14, labelKey = $$props.labelKey);
    		if ("idKey" in $$props) $$invalidate(15, idKey = $$props.idKey);
    		if ("showMenu" in $$props) $$invalidate(0, showMenu = $$props.showMenu);
    		if ("align" in $$props) $$invalidate(1, align = $$props.align);
    		if ("trigger" in $$props) $$invalidate(16, trigger = $$props.trigger);
    		if ("matchTrigger" in $$props) $$invalidate(17, matchTrigger = $$props.matchTrigger);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*checkTrigger, trigger*/ 589824) {
    			// console.log style
    			 checkTrigger(trigger);
    		}
    	};

    	return [
    		showMenu,
    		align,
    		menuId,
    		menuRef,
    		overlayClick,
    		style,
    		disabled,
    		id,
    		items,
    		width,
    		selectedIndex,
    		size,
    		value,
    		blankSlate,
    		labelKey,
    		idKey,
    		trigger,
    		matchTrigger,
    		changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		highlightedIndex,
    		menuItemClick,
    		$$scope,
    		$$slots,
    		div_binding
    	];
    }

    class ComposedMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			disabled: 6,
    			id: 7,
    			items: 8,
    			width: 9,
    			selectedIndex: 10,
    			size: 11,
    			value: 12,
    			blankSlate: 13,
    			labelKey: 14,
    			idKey: 15,
    			showMenu: 0,
    			align: 1,
    			trigger: 16,
    			matchTrigger: 17
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComposedMenu",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get disabled() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedIndex() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedIndex(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blankSlate() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blankSlate(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelKey() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelKey(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get idKey() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set idKey(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showMenu() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showMenu(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trigger() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trigger(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get matchTrigger() {
    		throw new Error("<ComposedMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set matchTrigger(value) {
    		throw new Error("<ComposedMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Overlay\Modal\ModalGeneric.svelte generated by Svelte v3.22.2 */
    const file$a = "src\\svelte\\components\\Overlay\\Modal\\ModalGeneric.svelte";
    const get_footer_slot_changes = dirty => ({});
    const get_footer_slot_context = ctx => ({});
    const get_header_slot_changes = dirty => ({});
    const get_header_slot_context = ctx => ({});

    function create_fragment$b(ctx) {
    	let modal_background;
    	let t0;
    	let modal_1;
    	let modal_header;
    	let t1;
    	let modal_body;
    	let t2;
    	let modal_footer;
    	let current;
    	let dispose;
    	const header_slot_template = /*$$slots*/ ctx[4].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[3], get_header_slot_context);
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	const footer_slot_template = /*$$slots*/ ctx[4].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[3], get_footer_slot_context);

    	const block = {
    		c: function create() {
    			modal_background = element("modal-background");
    			t0 = space();
    			modal_1 = element("modal");
    			modal_header = element("modal-header");
    			if (header_slot) header_slot.c();
    			t1 = space();
    			modal_body = element("modal-body");
    			if (default_slot) default_slot.c();
    			t2 = space();
    			modal_footer = element("modal-footer");
    			if (footer_slot) footer_slot.c();
    			set_custom_element_data(modal_background, "class", "svelte-1p5lauf");
    			add_location(modal_background, file$a, 79, 0, 1368);
    			set_custom_element_data(modal_header, "class", "svelte-1p5lauf");
    			add_location(modal_header, file$a, 81, 4, 1468);
    			set_custom_element_data(modal_body, "class", "svelte-1p5lauf");
    			add_location(modal_body, file$a, 84, 4, 1543);
    			set_custom_element_data(modal_footer, "class", "svelte-1p5lauf");
    			add_location(modal_footer, file$a, 87, 4, 1600);
    			attr_dev(modal_1, "role", "dialog");
    			attr_dev(modal_1, "aria-modal", "true");
    			attr_dev(modal_1, "class", "svelte-1p5lauf");
    			add_location(modal_1, file$a, 80, 0, 1406);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, modal_background, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, modal_1, anchor);
    			append_dev(modal_1, modal_header);

    			if (header_slot) {
    				header_slot.m(modal_header, null);
    			}

    			append_dev(modal_1, t1);
    			append_dev(modal_1, modal_body);

    			if (default_slot) {
    				default_slot.m(modal_body, null);
    			}

    			append_dev(modal_1, t2);
    			append_dev(modal_1, modal_footer);

    			if (footer_slot) {
    				footer_slot.m(modal_footer, null);
    			}

    			/*modal_1_binding*/ ctx[5](modal_1);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				window,
    				"keydown",
    				function () {
    					if (is_function(/*handle_keydown*/ ctx[1])) /*handle_keydown*/ ctx[1].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (header_slot) {
    				if (header_slot.p && dirty & /*$$scope*/ 8) {
    					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[3], get_header_slot_context), get_slot_changes(header_slot_template, /*$$scope*/ ctx[3], dirty, get_header_slot_changes));
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[3], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null));
    				}
    			}

    			if (footer_slot) {
    				if (footer_slot.p && dirty & /*$$scope*/ 8) {
    					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[3], get_footer_slot_context), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[3], dirty, get_footer_slot_changes));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			transition_in(default_slot, local);
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			transition_out(default_slot, local);
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(modal_background);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(modal_1);
    			if (header_slot) header_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    			if (footer_slot) footer_slot.d(detaching);
    			/*modal_1_binding*/ ctx[5](null);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	document.body.style = "overflow:hidden";

    	onDestroy(() => {
    		document.body.style = "";
    	});

    	let modal;
    	var handle_keydown, previously_focused;

    	handle_keydown = function (e) {

    		if (e.key === "Escape") {
    			close();
    			return;
    		}
    	};

    	previously_focused = typeof document !== "undefined" && document.activeElement;

    	if (previously_focused) {
    		onDestroy(function () {
    			return previously_focused.focus();
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ModalGeneric> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ModalGeneric", $$slots, ['header','default','footer']);

    	function modal_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(0, modal = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onDestroy,
    		modal,
    		handle_keydown,
    		previously_focused
    	});

    	$$self.$inject_state = $$props => {
    		if ("modal" in $$props) $$invalidate(0, modal = $$props.modal);
    		if ("handle_keydown" in $$props) $$invalidate(1, handle_keydown = $$props.handle_keydown);
    		if ("previously_focused" in $$props) previously_focused = $$props.previously_focused;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [modal, handle_keydown, previously_focused, $$scope, $$slots, modal_1_binding];
    }

    class ModalGeneric extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ModalGeneric",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src\svelte\components\Overlay\Modal\DeleteConfirmation.svelte generated by Svelte v3.22.2 */
    const file$b = "src\\svelte\\components\\Overlay\\Modal\\DeleteConfirmation.svelte";

    // (24:2) <div slot="header">
    function create_header_slot(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("Delete this ");
    			t1 = text(/*entity*/ ctx[0]);
    			t2 = text("?");
    			attr_dev(div, "slot", "header");
    			add_location(div, file$b, 23, 2, 354);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*entity*/ 1) set_data_dev(t1, /*entity*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot.name,
    		type: "slot",
    		source: "(24:2) <div slot=\\\"header\\\">",
    		ctx
    	});

    	return block;
    }

    // (25:2) <div slot="footer">
    function create_footer_slot(ctx) {
    	let div0;
    	let div1;
    	let button0;
    	let t1;
    	let button1;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div1 = element("div");
    			button0 = element("button");
    			button0.textContent = "Cancel";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "Delete";
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "normal", "");
    			add_location(button0, file$b, 26, 6, 445);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "normal", "");
    			attr_dev(button1, "critical", "");
    			attr_dev(button1, "margin-left", "s");
    			add_location(button1, file$b, 27, 6, 517);
    			attr_dev(div1, "a", "r");
    			add_location(div1, file$b, 25, 4, 427);
    			attr_dev(div0, "slot", "footer");
    			add_location(div0, file$b, 24, 2, 403);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, div1);
    			append_dev(div1, button0);
    			append_dev(div1, t1);
    			append_dev(div1, button1);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					button0,
    					"click",
    					function () {
    						if (is_function(/*cancel*/ ctx[1])) /*cancel*/ ctx[1].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button1,
    					"click",
    					function () {
    						if (is_function(/*destroy*/ ctx[2])) /*destroy*/ ctx[2].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_footer_slot.name,
    		type: "slot",
    		source: "(25:2) <div slot=\\\"footer\\\">",
    		ctx
    	});

    	return block;
    }

    // (23:0) <Modal>
    function create_default_slot$1(ctx) {
    	let t0;
    	let t1;
    	let div;

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			div = element("div");
    			div.textContent = "Are you sure you want to do this?";
    			add_location(div, file$b, 30, 2, 630);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(23:0) <Modal>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let current;

    	const modal = new ModalGeneric({
    			props: {
    				$$slots: {
    					default: [create_default_slot$1],
    					footer: [create_footer_slot],
    					header: [create_header_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const modal_changes = {};

    			if (dirty & /*$$scope, destroy, cancel, entity*/ 23) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	var cancel, destroy, dispatch;
    	dispatch = createEventDispatcher();
    	var { entity = "item" } = $$props;

    	destroy = function () {
    		return dispatch("destroy");
    	};

    	cancel = function () {
    		return dispatch("cancel");
    	};

    	const writable_props = ["entity"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DeleteConfirmation> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DeleteConfirmation", $$slots, []);

    	$$self.$set = $$props => {
    		if ("entity" in $$props) $$invalidate(0, entity = $$props.entity);
    	};

    	$$self.$capture_state = () => ({
    		cancel,
    		destroy,
    		dispatch,
    		createEventDispatcher,
    		Modal: ModalGeneric,
    		entity
    	});

    	$$self.$inject_state = $$props => {
    		if ("cancel" in $$props) $$invalidate(1, cancel = $$props.cancel);
    		if ("destroy" in $$props) $$invalidate(2, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("entity" in $$props) $$invalidate(0, entity = $$props.entity);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [entity, cancel, destroy];
    }

    class DeleteConfirmation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { entity: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DeleteConfirmation",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get entity() {
    		throw new Error("<DeleteConfirmation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set entity(value) {
    		throw new Error("<DeleteConfirmation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Menus\Project.svelte generated by Svelte v3.22.2 */

    const { console: console_1$5 } = globals;
    const file$c = "src\\svelte\\pages\\_Common\\Menus\\Project.svelte";

    // (90:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align="right" {width}>
    function create_default_slot$2(ctx) {
    	let ul;
    	let li;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li = element("li");
    			button = element("button");
    			button.textContent = "Delete Item";
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "svelte-4m5bbt");
    			add_location(button, file$c, 93, 6, 2450);
    			attr_dev(li, "class", "svelte-4m5bbt");
    			add_location(li, file$c, 92, 4, 2439);
    			attr_dev(ul, "class", "svelte-4m5bbt");
    			add_location(ul, file$c, 90, 2, 2429);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li);
    			append_dev(li, button);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*deleteConfirmation*/ ctx[0])) /*deleteConfirmation*/ ctx[0].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(90:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align=\\\"right\\\" {width}>",
    		ctx
    	});

    	return block;
    }

    // (98:0) {#if showDeleteConfirmation}
    function create_if_block$5(ctx) {
    	let current;
    	const deleteconfirmation = new DeleteConfirmation({ $$inline: true });

    	deleteconfirmation.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[2])) /*destroy*/ ctx[2].apply(this, arguments);
    	});

    	deleteconfirmation.$on("cancel", function () {
    		if (is_function(/*deleteConfirmationCancel*/ ctx[1])) /*deleteConfirmationCancel*/ ctx[1].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(deleteconfirmation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deleteconfirmation, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteconfirmation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteconfirmation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deleteconfirmation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(98:0) {#if showDeleteConfirmation}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let button;
    	let svg;
    	let path;
    	let t0;
    	let updating_showMenu;
    	let t1;
    	let if_block_anchor;
    	let current;
    	let dispose;

    	function menu_showMenu_binding(value) {
    		/*menu_showMenu_binding*/ ctx[13].call(null, value);
    	}

    	let menu_props = {
    		trigger: /*menuButtonRef*/ ctx[3],
    		align: "right",
    		width: /*width*/ ctx[7],
    		$$slots: { default: [create_default_slot$2] },
    		$$scope: { ctx }
    	};

    	if (/*showMenu*/ ctx[6] !== void 0) {
    		menu_props.showMenu = /*showMenu*/ ctx[6];
    	}

    	const menu = new ComposedMenu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "showMenu", menu_showMenu_binding));
    	let if_block = /*showDeleteConfirmation*/ ctx[5] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t0 = space();
    			create_component(menu.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(path, "d", "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z");
    			add_location(path, file$c, 87, 112, 2114);
    			attr_dev(svg, "class", "menu");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$c, 87, 2, 2004);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$c, 86, 0, 1928);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			/*button_binding*/ ctx[12](button);
    			insert_dev(target, t0, anchor);
    			mount_component(menu, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*openMenu*/ ctx[4])) /*openMenu*/ ctx[4].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const menu_changes = {};
    			if (dirty & /*menuButtonRef*/ 8) menu_changes.trigger = /*menuButtonRef*/ ctx[3];
    			if (dirty & /*width*/ 128) menu_changes.width = /*width*/ ctx[7];

    			if (dirty & /*$$scope, deleteConfirmation*/ 16385) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_showMenu && dirty & /*showMenu*/ 64) {
    				updating_showMenu = true;
    				menu_changes.showMenu = /*showMenu*/ ctx[6];
    				add_flush_callback(() => updating_showMenu = false);
    			}

    			menu.$set(menu_changes);

    			if (/*showDeleteConfirmation*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showDeleteConfirmation*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			/*button_binding*/ ctx[12](null);
    			if (detaching) detach_dev(t0);
    			destroy_component(menu, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	var closeMenu,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		indent,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	menuButtonRef = void 0;
    	showMenu = false;

    	openMenu = function () {
    		return $$invalidate(6, showMenu = true);
    	};

    	closeMenu = function () {
    		return $$invalidate(6, showMenu = false);
    	};

    	width = "189px";

    	destroy = function () {
    		dispatch("destroy", item);
    		return closeMenu();
    	};

    	indent = function (indentLevel) {
    		console.log("indent");
    		dispatch("update", { id: item.id, indent: indentLevel });
    		return closeMenu();
    	};

    	showDeleteConfirmation = false;

    	deleteConfirmation = function () {
    		closeMenu();
    		return $$invalidate(5, showDeleteConfirmation = true);
    	};

    	deleteConfirmationCancel = function () {
    		return $$invalidate(5, showDeleteConfirmation = false);
    	};

    	destroy = function () {
    		dispatch("destroy", item);
    		return $$invalidate(5, showDeleteConfirmation = false);
    	};

    	const writable_props = ["item"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<Project> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Project", $$slots, []);

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(3, menuButtonRef = $$value);
    		});
    	}

    	function menu_showMenu_binding(value) {
    		showMenu = value;
    		$$invalidate(6, showMenu);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(8, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({
    		closeMenu,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		indent,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width,
    		createEventDispatcher,
    		Menu: ComposedMenu,
    		DeleteConfirmation,
    		item
    	});

    	$$self.$inject_state = $$props => {
    		if ("closeMenu" in $$props) closeMenu = $$props.closeMenu;
    		if ("deleteConfirmation" in $$props) $$invalidate(0, deleteConfirmation = $$props.deleteConfirmation);
    		if ("deleteConfirmationCancel" in $$props) $$invalidate(1, deleteConfirmationCancel = $$props.deleteConfirmationCancel);
    		if ("destroy" in $$props) $$invalidate(2, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("indent" in $$props) indent = $$props.indent;
    		if ("menuButtonRef" in $$props) $$invalidate(3, menuButtonRef = $$props.menuButtonRef);
    		if ("openMenu" in $$props) $$invalidate(4, openMenu = $$props.openMenu);
    		if ("showDeleteConfirmation" in $$props) $$invalidate(5, showDeleteConfirmation = $$props.showDeleteConfirmation);
    		if ("showMenu" in $$props) $$invalidate(6, showMenu = $$props.showMenu);
    		if ("width" in $$props) $$invalidate(7, width = $$props.width);
    		if ("item" in $$props) $$invalidate(8, item = $$props.item);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width,
    		item,
    		closeMenu,
    		dispatch,
    		indent,
    		button_binding,
    		menu_showMenu_binding
    	];
    }

    class Project extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { item: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Project",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get item() {
    		throw new Error("<Project>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Project>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Form\InlineInput\InlineInput.svelte generated by Svelte v3.22.2 */
    const file$d = "src\\svelte\\components\\Form\\InlineInput\\InlineInput.svelte";
    const get_default_slot_changes = dirty => ({ label: dirty & /*label*/ 16384 });
    const get_default_slot_context = ctx => ({ label: /*label*/ ctx[14] });

    // (156:0) {:else}
    function create_else_block$1(ctx) {
    	let div;
    	let span;
    	let div_class_value;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[28].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[27], get_default_slot_context);
    	const default_slot_or_fallback = default_slot || fallback_block$3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(span, "ellipsis", "");
    			attr_dev(span, "class", "svelte-5kit38");
    			add_location(span, file$d, 160, 4, 2816);
    			attr_dev(div, "id", /*id*/ ctx[8]);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*labelClasses*/ ctx[6]) + " svelte-5kit38"));
    			attr_dev(div, "ellipsis", "");
    			attr_dev(div, "style", /*style*/ ctx[2]);
    			add_location(div, file$d, 156, 2, 2747);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(span, null);
    			}

    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				span,
    				"click",
    				function () {
    					if (is_function(/*click*/ ctx[9])) /*click*/ ctx[9].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, label*/ 134234112) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[27], get_default_slot_context), get_slot_changes(default_slot_template, /*$$scope*/ ctx[27], dirty, get_default_slot_changes));
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 16384) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty & /*id*/ 256) {
    				attr_dev(div, "id", /*id*/ ctx[8]);
    			}

    			if (!current || dirty & /*labelClasses*/ 64 && div_class_value !== (div_class_value = "" + (null_to_empty(/*labelClasses*/ ctx[6]) + " svelte-5kit38"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty & /*style*/ 4) {
    				attr_dev(div, "style", /*style*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(156:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (144:0) {#if editing && (isText || isNumber)}
    function create_if_block$6(ctx) {
    	let input;
    	let input_class_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "class", input_class_value = "" + (null_to_empty(/*inputClasses*/ ctx[7]) + " svelte-5kit38"));
    			attr_dev(input, "style", /*inputStyle*/ ctx[3]);
    			attr_dev(input, "type", /*type*/ ctx[4]);
    			input.value = /*value*/ ctx[0];
    			attr_dev(input, "placeholder", /*placeholder*/ ctx[5]);
    			add_location(input, file$d, 144, 2, 2496);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, input, anchor);
    			/*input_binding*/ ctx[30](input);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(input, "click", stop_propagation(/*click_handler*/ ctx[29]), false, false, true),
    				listen_dev(
    					input,
    					"input",
    					function () {
    						if (is_function(/*handleInput*/ ctx[11])) /*handleInput*/ ctx[11].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					input,
    					"keyup",
    					function () {
    						if (is_function(/*handleKeyup*/ ctx[12])) /*handleKeyup*/ ctx[12].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					input,
    					"blur",
    					function () {
    						if (is_function(/*handleBlur*/ ctx[10])) /*handleBlur*/ ctx[10].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*inputClasses*/ 128 && input_class_value !== (input_class_value = "" + (null_to_empty(/*inputClasses*/ ctx[7]) + " svelte-5kit38"))) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if (dirty & /*inputStyle*/ 8) {
    				attr_dev(input, "style", /*inputStyle*/ ctx[3]);
    			}

    			if (dirty & /*type*/ 16) {
    				attr_dev(input, "type", /*type*/ ctx[4]);
    			}

    			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				prop_dev(input, "value", /*value*/ ctx[0]);
    			}

    			if (dirty & /*placeholder*/ 32) {
    				attr_dev(input, "placeholder", /*placeholder*/ ctx[5]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding*/ ctx[30](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(144:0) {#if editing && (isText || isNumber)}",
    		ctx
    	});

    	return block;
    }

    // (161:50) <span ellipsis>
    function fallback_block$3(ctx) {
    	let span1;
    	let t;
    	let span0;

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			t = text(/*label*/ ctx[14]);
    			span0 = element("span");
    			attr_dev(span0, "spacer", "");
    			attr_dev(span0, "class", "svelte-5kit38");
    			add_location(span0, file$d, 160, 72, 2884);
    			attr_dev(span1, "ellipsis", "");
    			attr_dev(span1, "class", "svelte-5kit38");
    			add_location(span1, file$d, 160, 50, 2862);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, t);
    			append_dev(span1, span0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 16384) set_data_dev(t, /*label*/ ctx[14]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$3.name,
    		type: "fallback",
    		source: "(161:50) <span ellipsis>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$6, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*editing*/ ctx[1] && (/*isText*/ ctx[15] || /*isNumber*/ ctx[16])) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	var click,
    		clickCount,
    		clickReset,
    		delayedReset,
    		dispatch,
    		double,
    		handleBlur,
    		handleInput,
    		handleKeyup,
    		inputEl,
    		label,
    		originalValue,
    		single;

    	dispatch = createEventDispatcher();
    	var { value = "" } = $$props;
    	var { style = void 0 } = $$props;
    	var { inputStyle = void 0 } = $$props;
    	var { type = "text" } = $$props;
    	var { placeholder = "" } = $$props;
    	var { labelClasses = "" } = $$props;
    	var { inputClasses = "" } = $$props;
    	var { doubleClick = true } = $$props;
    	var { id = void 0 } = $$props;
    	var { delay = 250 } = $$props;
    	var { editing = false } = $$props;
    	inputEl = void 0;
    	label = void 0;
    	originalValue = void 0;

    	const toggle = async _ => {
    		$$invalidate(1, editing = !editing);
    		originalValue = value;

    		if (editing) {
    			await tick();
    			inputEl.focus();
    		}
    	};

    	handleInput = function (e) {
    		if (isNumber) {
    			$$invalidate(0, value = +e.target.value);
    		}

    		return $$invalidate(0, value = e.target.value);
    	};

    	handleKeyup = function (e) {
    		dispatch("keyup", value);

    		switch (e.keyCode) {
    			case 13:
    				return inputEl.blur();
    			case 27:
    				$$invalidate(0, value = originalValue);
    				return inputEl.blur();
    		}
    	};

    	// }
    	handleBlur = function (_) {
    		var unchanged;
    		unchanged = value === originalValue;
    		toggle();

    		if (!unchanged) {
    			return dispatch("update", value);
    		}
    	};

    	// Click tracking
    	clickCount = 0;

    	clickReset = function () {
    		switch (clickCount) {
    			case 1:
    				return single();
    			case 2:
    				return double();
    			default:
    				return clickCount = 0;
    		}
    	};

    	// }
    	delayedReset = clickReset.debounce(delay);

    	single = function () {
    		clickCount = 0;

    		if (!doubleClick) {
    			toggle();
    		}

    		return dispatch("clicked", id);
    	};

    	double = function () {
    		clickCount = 0;

    		if (doubleClick) {
    			toggle();
    		}

    		return dispatch("doubleclicked", id);
    	};

    	click = function () {
    		clickCount++;
    		return delayedReset();
    	};

    	const writable_props = [
    		"value",
    		"style",
    		"inputStyle",
    		"type",
    		"placeholder",
    		"labelClasses",
    		"inputClasses",
    		"doubleClick",
    		"id",
    		"delay",
    		"editing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InlineInput> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("InlineInput", $$slots, ['default']);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(13, inputEl = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("style" in $$props) $$invalidate(2, style = $$props.style);
    		if ("inputStyle" in $$props) $$invalidate(3, inputStyle = $$props.inputStyle);
    		if ("type" in $$props) $$invalidate(4, type = $$props.type);
    		if ("placeholder" in $$props) $$invalidate(5, placeholder = $$props.placeholder);
    		if ("labelClasses" in $$props) $$invalidate(6, labelClasses = $$props.labelClasses);
    		if ("inputClasses" in $$props) $$invalidate(7, inputClasses = $$props.inputClasses);
    		if ("doubleClick" in $$props) $$invalidate(17, doubleClick = $$props.doubleClick);
    		if ("id" in $$props) $$invalidate(8, id = $$props.id);
    		if ("delay" in $$props) $$invalidate(18, delay = $$props.delay);
    		if ("editing" in $$props) $$invalidate(1, editing = $$props.editing);
    		if ("$$scope" in $$props) $$invalidate(27, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		click,
    		clickCount,
    		clickReset,
    		delayedReset,
    		dispatch,
    		double,
    		handleBlur,
    		handleInput,
    		handleKeyup,
    		inputEl,
    		label,
    		originalValue,
    		single,
    		tick,
    		createEventDispatcher,
    		value,
    		style,
    		inputStyle,
    		type,
    		placeholder,
    		labelClasses,
    		inputClasses,
    		doubleClick,
    		id,
    		delay,
    		editing,
    		toggle,
    		isText,
    		isNumber
    	});

    	$$self.$inject_state = $$props => {
    		if ("click" in $$props) $$invalidate(9, click = $$props.click);
    		if ("clickCount" in $$props) clickCount = $$props.clickCount;
    		if ("clickReset" in $$props) clickReset = $$props.clickReset;
    		if ("delayedReset" in $$props) delayedReset = $$props.delayedReset;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("double" in $$props) double = $$props.double;
    		if ("handleBlur" in $$props) $$invalidate(10, handleBlur = $$props.handleBlur);
    		if ("handleInput" in $$props) $$invalidate(11, handleInput = $$props.handleInput);
    		if ("handleKeyup" in $$props) $$invalidate(12, handleKeyup = $$props.handleKeyup);
    		if ("inputEl" in $$props) $$invalidate(13, inputEl = $$props.inputEl);
    		if ("label" in $$props) $$invalidate(14, label = $$props.label);
    		if ("originalValue" in $$props) originalValue = $$props.originalValue;
    		if ("single" in $$props) single = $$props.single;
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("style" in $$props) $$invalidate(2, style = $$props.style);
    		if ("inputStyle" in $$props) $$invalidate(3, inputStyle = $$props.inputStyle);
    		if ("type" in $$props) $$invalidate(4, type = $$props.type);
    		if ("placeholder" in $$props) $$invalidate(5, placeholder = $$props.placeholder);
    		if ("labelClasses" in $$props) $$invalidate(6, labelClasses = $$props.labelClasses);
    		if ("inputClasses" in $$props) $$invalidate(7, inputClasses = $$props.inputClasses);
    		if ("doubleClick" in $$props) $$invalidate(17, doubleClick = $$props.doubleClick);
    		if ("id" in $$props) $$invalidate(8, id = $$props.id);
    		if ("delay" in $$props) $$invalidate(18, delay = $$props.delay);
    		if ("editing" in $$props) $$invalidate(1, editing = $$props.editing);
    		if ("isText" in $$props) $$invalidate(15, isText = $$props.isText);
    		if ("isNumber" in $$props) $$invalidate(16, isNumber = $$props.isNumber);
    	};

    	let isText;
    	let isNumber;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*type*/ 16) {
    			// Computed
    			 $$invalidate(15, isText = type === "text");
    		}

    		if ($$self.$$.dirty & /*type*/ 16) {
    			 $$invalidate(16, isNumber = type === "number");
    		}

    		if ($$self.$$.dirty & /*isNumber, value, placeholder, isText*/ 98337) {
    			 if (isNumber) {
    				$$invalidate(14, label = value === "" ? placeholder : value);
    			} else if (isText) {
    				$$invalidate(14, label = value ? value : placeholder);
    			}
    		}
    	};

    	return [
    		value,
    		editing,
    		style,
    		inputStyle,
    		type,
    		placeholder,
    		labelClasses,
    		inputClasses,
    		id,
    		click,
    		handleBlur,
    		handleInput,
    		handleKeyup,
    		inputEl,
    		label,
    		isText,
    		isNumber,
    		doubleClick,
    		delay,
    		clickCount,
    		clickReset,
    		delayedReset,
    		dispatch,
    		double,
    		originalValue,
    		single,
    		toggle,
    		$$scope,
    		$$slots,
    		click_handler,
    		input_binding
    	];
    }

    class InlineInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			value: 0,
    			style: 2,
    			inputStyle: 3,
    			type: 4,
    			placeholder: 5,
    			labelClasses: 6,
    			inputClasses: 7,
    			doubleClick: 17,
    			id: 8,
    			delay: 18,
    			editing: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InlineInput",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get value() {
    		throw new Error("<InlineInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<InlineInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<InlineInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<InlineInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputStyle() {
    		throw new Error("<InlineInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputStyle(value) {
    		throw new Error("<InlineInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<InlineInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<InlineInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<InlineInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<InlineInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelClasses() {
    		throw new Error("<InlineInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelClasses(value) {
    		throw new Error("<InlineInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputClasses() {
    		throw new Error("<InlineInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputClasses(value) {
    		throw new Error("<InlineInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get doubleClick() {
    		throw new Error("<InlineInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set doubleClick(value) {
    		throw new Error("<InlineInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<InlineInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<InlineInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get delay() {
    		throw new Error("<InlineInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set delay(value) {
    		throw new Error("<InlineInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get editing() {
    		throw new Error("<InlineInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set editing(value) {
    		throw new Error("<InlineInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Flex\Row.svelte generated by Svelte v3.22.2 */

    const file$e = "src\\svelte\\components\\Flex\\Row.svelte";

    function create_fragment$f(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "layout", "row");
    			attr_dev(div, "style", /*style*/ ctx[0]);
    			attr_dev(div, "id", /*id*/ ctx[1]);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*classes*/ ctx[2]) + " svelte-7n8vym"));
    			add_location(div, file$e, 18, 0, 326);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[3], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null));
    				}
    			}

    			if (!current || dirty & /*style*/ 1) {
    				attr_dev(div, "style", /*style*/ ctx[0]);
    			}

    			if (!current || dirty & /*id*/ 2) {
    				attr_dev(div, "id", /*id*/ ctx[1]);
    			}

    			if (!current || dirty & /*classes*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty(/*classes*/ ctx[2]) + " svelte-7n8vym"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	var { style = void 0 } = $$props;
    	var { id = void 0 } = $$props;
    	var { classes = void 0 } = $$props;
    	const writable_props = ["style", "id", "classes"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Row> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Row", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("style" in $$props) $$invalidate(0, style = $$props.style);
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    		if ("classes" in $$props) $$invalidate(2, classes = $$props.classes);
    		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ style, id, classes });

    	$$self.$inject_state = $$props => {
    		if ("style" in $$props) $$invalidate(0, style = $$props.style);
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    		if ("classes" in $$props) $$invalidate(2, classes = $$props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style, id, classes, $$scope, $$slots];
    }

    class Row extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { style: 0, id: 1, classes: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Row",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get style() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Flex\Column.svelte generated by Svelte v3.22.2 */

    const file$f = "src\\svelte\\components\\Flex\\Column.svelte";

    function create_fragment$g(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "layout", "column");
    			attr_dev(div, "style", /*style*/ ctx[0]);
    			attr_dev(div, "id", /*id*/ ctx[1]);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*classes*/ ctx[2]) + " svelte-143bce8"));
    			add_location(div, file$f, 18, 0, 332);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[3], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null));
    				}
    			}

    			if (!current || dirty & /*style*/ 1) {
    				attr_dev(div, "style", /*style*/ ctx[0]);
    			}

    			if (!current || dirty & /*id*/ 2) {
    				attr_dev(div, "id", /*id*/ ctx[1]);
    			}

    			if (!current || dirty & /*classes*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty(/*classes*/ ctx[2]) + " svelte-143bce8"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	var { style = void 0 } = $$props;
    	var { id = void 0 } = $$props;
    	var { classes = void 0 } = $$props;
    	const writable_props = ["style", "id", "classes"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Column> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Column", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("style" in $$props) $$invalidate(0, style = $$props.style);
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    		if ("classes" in $$props) $$invalidate(2, classes = $$props.classes);
    		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ style, id, classes });

    	$$self.$inject_state = $$props => {
    		if ("style" in $$props) $$invalidate(0, style = $$props.style);
    		if ("id" in $$props) $$invalidate(1, id = $$props.id);
    		if ("classes" in $$props) $$invalidate(2, classes = $$props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style, id, classes, $$scope, $$slots];
    }

    class Column extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { style: 0, id: 1, classes: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Column",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get style() {
    		throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Column>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Column>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Flex\RowCell.svelte generated by Svelte v3.22.2 */

    const file$g = "src\\svelte\\components\\Flex\\RowCell.svelte";

    function create_fragment$h(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "flex", /*flex*/ ctx[0]);
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			attr_dev(div, "id", /*id*/ ctx[2]);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*classes*/ ctx[3]) + " svelte-6uecf1"));
    			add_location(div, file$g, 287, 0, 3133);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[4], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null));
    				}
    			}

    			if (!current || dirty & /*flex*/ 1) {
    				attr_dev(div, "flex", /*flex*/ ctx[0]);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty & /*id*/ 4) {
    				attr_dev(div, "id", /*id*/ ctx[2]);
    			}

    			if (!current || dirty & /*classes*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*classes*/ ctx[3]) + " svelte-6uecf1"))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	var { flex = "initial" } = $$props;
    	var { style = void 0 } = $$props;
    	var { id = void 0 } = $$props;
    	var { classes = void 0 } = $$props;
    	const writable_props = ["flex", "style", "id", "classes"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RowCell> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("RowCell", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("flex" in $$props) $$invalidate(0, flex = $$props.flex);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("id" in $$props) $$invalidate(2, id = $$props.id);
    		if ("classes" in $$props) $$invalidate(3, classes = $$props.classes);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ flex, style, id, classes });

    	$$self.$inject_state = $$props => {
    		if ("flex" in $$props) $$invalidate(0, flex = $$props.flex);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("id" in $$props) $$invalidate(2, id = $$props.id);
    		if ("classes" in $$props) $$invalidate(3, classes = $$props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [flex, style, id, classes, $$scope, $$slots];
    }

    class RowCell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { flex: 0, style: 1, id: 2, classes: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RowCell",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get flex() {
    		throw new Error("<RowCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flex(value) {
    		throw new Error("<RowCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<RowCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<RowCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<RowCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<RowCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<RowCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<RowCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Flex\ColumnCell.svelte generated by Svelte v3.22.2 */

    const file$h = "src\\svelte\\components\\Flex\\ColumnCell.svelte";

    function create_fragment$i(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "flex", /*flex*/ ctx[0]);
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			attr_dev(div, "id", /*id*/ ctx[3]);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*classes*/ ctx[4]) + " svelte-2jd122"));
    			attr_dev(div, "type", /*type*/ ctx[2]);
    			add_location(div, file$h, 315, 0, 3627);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[5], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null));
    				}
    			}

    			if (!current || dirty & /*flex*/ 1) {
    				attr_dev(div, "flex", /*flex*/ ctx[0]);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty & /*id*/ 8) {
    				attr_dev(div, "id", /*id*/ ctx[3]);
    			}

    			if (!current || dirty & /*classes*/ 16 && div_class_value !== (div_class_value = "" + (null_to_empty(/*classes*/ ctx[4]) + " svelte-2jd122"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty & /*type*/ 4) {
    				attr_dev(div, "type", /*type*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	var { flex = "initial" } = $$props;
    	var { style = void 0 } = $$props;
    	var { type = void 0 } = $$props;
    	var { id = void 0 } = $$props;
    	var { classes = void 0 } = $$props;
    	const writable_props = ["flex", "style", "type", "id", "classes"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ColumnCell> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ColumnCell", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("flex" in $$props) $$invalidate(0, flex = $$props.flex);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("type" in $$props) $$invalidate(2, type = $$props.type);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("classes" in $$props) $$invalidate(4, classes = $$props.classes);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ flex, style, type, id, classes });

    	$$self.$inject_state = $$props => {
    		if ("flex" in $$props) $$invalidate(0, flex = $$props.flex);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("type" in $$props) $$invalidate(2, type = $$props.type);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("classes" in $$props) $$invalidate(4, classes = $$props.classes);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [flex, style, type, id, classes, $$scope, $$slots];
    }

    class ColumnCell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			flex: 0,
    			style: 1,
    			type: 2,
    			id: 3,
    			classes: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ColumnCell",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get flex() {
    		throw new Error("<ColumnCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flex(value) {
    		throw new Error("<ColumnCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<ColumnCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ColumnCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<ColumnCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<ColumnCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<ColumnCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ColumnCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<ColumnCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<ColumnCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Icon\IconProgressCircle.svelte generated by Svelte v3.22.2 */

    const file$i = "src\\svelte\\components\\Icon\\IconProgressCircle.svelte";

    function create_fragment$j(ctx) {
    	let svg;
    	let path_1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path_1 = svg_element("path");
    			attr_dev(path_1, "fill", /*fill*/ ctx[2]);
    			attr_dev(path_1, "d", /*d*/ ctx[1]);
    			add_location(path_1, file$i, 49, 2, 2008);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", /*size*/ ctx[0]);
    			attr_dev(svg, "height", /*size*/ ctx[0]);
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$i, 48, 0, 1900);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path_1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*fill*/ 4) {
    				attr_dev(path_1, "fill", /*fill*/ ctx[2]);
    			}

    			if (dirty & /*d*/ 2) {
    				attr_dev(path_1, "d", /*d*/ ctx[1]);
    			}

    			if (dirty & /*size*/ 1) {
    				attr_dev(svg, "width", /*size*/ ctx[0]);
    			}

    			if (dirty & /*size*/ 1) {
    				attr_dev(svg, "height", /*size*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	var fillColor, path;
    	var { value = void 0 } = $$props;
    	var { color = "light-gray" } = $$props;
    	var { size = 24 } = $$props;

    	fillColor = function (val) {
    		switch (val) {
    			case "light-gray":
    				return "var(--lightest-gray)";
    			case "gray":
    				return "var(--gray)";
    			case "dark-gray":
    				return "var(--darker-gray)";
    			case "green":
    				return "var(--green)";
    			case "yellow":
    				return "var(--yellow)";
    			case "red":
    				return "var(--red)";
    			case "blue":
    				return "var(--blue)";
    		}
    	};

    	//}
    	path = function (val) {
    		switch (val) {
    			case 0:
    				return "M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z";
    			case 25:
    				return "M12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12C2 6.5 6.5 2 12 2M12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20C16.42 20 20 16.42 20 12C20 7.58 16.42 4 12 4M12 5C15.87 5 19 8.13 19 12H12V5Z";
    			case 50:
    				return "M12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12C2 6.5 6.5 2 12 2M12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20C16.42 20 20 16.42 20 12C20 7.58 16.42 4 12 4M12 5C15.87 5 19 8.13 19 12C19 15.87 15.87 19 12 19V5Z";
    			case 75:
    				return "M12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12C2 6.5 6.5 2 12 2M12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20C16.42 20 20 16.42 20 12C20 7.58 16.42 4 12 4M12 5C15.87 5 19 8.13 19 12C19 15.87 15.87 19 12 19C8.13 19 5 15.87 5 12H12V5Z";
    			default:
    				return "M12 5C15.87 5 19 8.13 19 12C19 15.87 15.87 19 12 19C8.13 19 5 15.87 5 12C5 8.13 8.13 5 12 5M12 2C17.5 2 22 6.5 22 12C22 17.5 17.5 22 12 22C6.5 22 2 17.5 2 12C2 6.5 6.5 2 12 2M12 4C7.58 4 4 7.58 4 12C4 16.42 7.58 20 12 20C16.42 20 20 16.42 20 12C20 7.58 16.42 4 12 4Z";
    		}
    	};

    	const writable_props = ["value", "color", "size"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IconProgressCircle> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("IconProgressCircle", $$slots, []);

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(3, value = $$props.value);
    		if ("color" in $$props) $$invalidate(4, color = $$props.color);
    		if ("size" in $$props) $$invalidate(0, size = $$props.size);
    	};

    	$$self.$capture_state = () => ({
    		fillColor,
    		path,
    		value,
    		color,
    		size,
    		d,
    		fill
    	});

    	$$self.$inject_state = $$props => {
    		if ("fillColor" in $$props) $$invalidate(5, fillColor = $$props.fillColor);
    		if ("path" in $$props) $$invalidate(6, path = $$props.path);
    		if ("value" in $$props) $$invalidate(3, value = $$props.value);
    		if ("color" in $$props) $$invalidate(4, color = $$props.color);
    		if ("size" in $$props) $$invalidate(0, size = $$props.size);
    		if ("d" in $$props) $$invalidate(1, d = $$props.d);
    		if ("fill" in $$props) $$invalidate(2, fill = $$props.fill);
    	};

    	let d;
    	let fill;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*path, value*/ 72) {
    			//}
    			 $$invalidate(1, d = path(value || 0));
    		}

    		if ($$self.$$.dirty & /*fillColor, color*/ 48) {
    			 $$invalidate(2, fill = fillColor(color));
    		}
    	};

    	return [size, d, fill, value, color];
    }

    class IconProgressCircle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, { value: 3, color: 4, size: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IconProgressCircle",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get value() {
    		throw new Error("<IconProgressCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<IconProgressCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<IconProgressCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<IconProgressCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<IconProgressCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<IconProgressCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Popovers\Progress.svelte generated by Svelte v3.22.2 */
    const file$j = "src\\svelte\\pages\\_Common\\Popovers\\Progress.svelte";

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	return child_ctx;
    }

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	return child_ctx;
    }

    // (82:8) <RowCell>
    function create_default_slot_2$1(ctx) {
    	let button;
    	let current;
    	let dispose;

    	const iconprogresscircle = new IconProgressCircle({
    			props: {
    				value: /*percentage*/ ctx[18],
    				color: /*color*/ ctx[15]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(iconprogresscircle.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			set_style(button, "margin", "0px 2px");
    			add_location(button, file$j, 82, 10, 1883);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			mount_component(iconprogresscircle, button, null);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*save*/ ctx[3](/*percentage*/ ctx[18], /*color*/ ctx[15]))) /*save*/ ctx[3](/*percentage*/ ctx[18], /*color*/ ctx[15]).apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconprogresscircle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconprogresscircle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(iconprogresscircle);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(82:8) <RowCell>",
    		ctx
    	});

    	return block;
    }

    // (81:6) {#each [0,25,50,75,100] as percentage}
    function create_each_block_1(ctx) {
    	let current;

    	const rowcell = new RowCell({
    			props: {
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rowcell.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rowcell, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const rowcell_changes = {};

    			if (dirty & /*$$scope, save*/ 2097160) {
    				rowcell_changes.$$scope = { dirty, ctx };
    			}

    			rowcell.$set(rowcell_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rowcell.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rowcell.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rowcell, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(81:6) {#each [0,25,50,75,100] as percentage}",
    		ctx
    	});

    	return block;
    }

    // (80:4) <Row style="padding: 8px">
    function create_default_slot_1$1(ctx) {
    	let t;
    	let current;
    	let each_value_1 = [0, 25, 50, 75, 100];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < 5; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 5; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 5; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*save*/ 8) {
    				each_value_1 = [0, 25, 50, 75, 100];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < 5; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = 5; i < 5; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < 5; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < 5; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(80:4) <Row style=\\\"padding: 8px\\\">",
    		ctx
    	});

    	return block;
    }

    // (79:2) {#each ["green","yellow","red","blue","dark-gray","gray","light-gray"] as color}
    function create_each_block(ctx) {
    	let current;

    	const row = new Row({
    			props: {
    				style: "padding: 8px",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, save*/ 2097160) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(79:2) {#each [\\\"green\\\",\\\"yellow\\\",\\\"red\\\",\\\"blue\\\",\\\"dark-gray\\\",\\\"gray\\\",\\\"light-gray\\\"] as color}",
    		ctx
    	});

    	return block;
    }

    // (78:0) <Popover bind:show={show} bind:trigger={triggerRef} on:close={cancel} width="160px">
    function create_default_slot$3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = ["green", "yellow", "red", "blue", "dark-gray", "gray", "light-gray"];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < 7; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < 7; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < 7; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*save*/ 8) {
    				each_value = ["green", "yellow", "red", "blue", "dark-gray", "gray", "light-gray"];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < 7; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = 7; i < 7; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < 7; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < 7; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(78:0) <Popover bind:show={show} bind:trigger={triggerRef} on:close={cancel} width=\\\"160px\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let div;
    	let updating_value;
    	let updating_color;
    	let t;
    	let updating_show;
    	let updating_trigger;
    	let current;
    	let dispose;

    	function iconprogresscircle_value_binding(value) {
    		/*iconprogresscircle_value_binding*/ ctx[10].call(null, value);
    	}

    	function iconprogresscircle_color_binding(value) {
    		/*iconprogresscircle_color_binding*/ ctx[11].call(null, value);
    	}

    	let iconprogresscircle_props = { size: /*size*/ ctx[1] };

    	if (/*item*/ ctx[0].progress.percent_complete !== void 0) {
    		iconprogresscircle_props.value = /*item*/ ctx[0].progress.percent_complete;
    	}

    	if (/*item*/ ctx[0].progress.color !== void 0) {
    		iconprogresscircle_props.color = /*item*/ ctx[0].progress.color;
    	}

    	const iconprogresscircle = new IconProgressCircle({
    			props: iconprogresscircle_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(iconprogresscircle, "value", iconprogresscircle_value_binding));
    	binding_callbacks.push(() => bind(iconprogresscircle, "color", iconprogresscircle_color_binding));

    	function popover_show_binding(value) {
    		/*popover_show_binding*/ ctx[13].call(null, value);
    	}

    	function popover_trigger_binding(value) {
    		/*popover_trigger_binding*/ ctx[14].call(null, value);
    	}

    	let popover_props = {
    		width: "160px",
    		$$slots: { default: [create_default_slot$3] },
    		$$scope: { ctx }
    	};

    	if (/*show*/ ctx[4] !== void 0) {
    		popover_props.show = /*show*/ ctx[4];
    	}

    	if (/*triggerRef*/ ctx[6] !== void 0) {
    		popover_props.trigger = /*triggerRef*/ ctx[6];
    	}

    	const popover = new Popover({ props: popover_props, $$inline: true });
    	binding_callbacks.push(() => bind(popover, "show", popover_show_binding));
    	binding_callbacks.push(() => bind(popover, "trigger", popover_trigger_binding));

    	popover.$on("close", function () {
    		if (is_function(/*cancel*/ ctx[2])) /*cancel*/ ctx[2].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(iconprogresscircle.$$.fragment);
    			t = space();
    			create_component(popover.$$.fragment);
    			add_location(div, file$j, 74, 0, 1443);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			mount_component(iconprogresscircle, div, null);
    			/*div_binding*/ ctx[12](div);
    			insert_dev(target, t, anchor);
    			mount_component(popover, target, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div,
    				"click",
    				function () {
    					if (is_function(/*triggerClick*/ ctx[5])) /*triggerClick*/ ctx[5].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const iconprogresscircle_changes = {};
    			if (dirty & /*size*/ 2) iconprogresscircle_changes.size = /*size*/ ctx[1];

    			if (!updating_value && dirty & /*item*/ 1) {
    				updating_value = true;
    				iconprogresscircle_changes.value = /*item*/ ctx[0].progress.percent_complete;
    				add_flush_callback(() => updating_value = false);
    			}

    			if (!updating_color && dirty & /*item*/ 1) {
    				updating_color = true;
    				iconprogresscircle_changes.color = /*item*/ ctx[0].progress.color;
    				add_flush_callback(() => updating_color = false);
    			}

    			iconprogresscircle.$set(iconprogresscircle_changes);
    			const popover_changes = {};

    			if (dirty & /*$$scope, save*/ 2097160) {
    				popover_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_show && dirty & /*show*/ 16) {
    				updating_show = true;
    				popover_changes.show = /*show*/ ctx[4];
    				add_flush_callback(() => updating_show = false);
    			}

    			if (!updating_trigger && dirty & /*triggerRef*/ 64) {
    				updating_trigger = true;
    				popover_changes.trigger = /*triggerRef*/ ctx[6];
    				add_flush_callback(() => updating_trigger = false);
    			}

    			popover.$set(popover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconprogresscircle.$$.fragment, local);
    			transition_in(popover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconprogresscircle.$$.fragment, local);
    			transition_out(popover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(iconprogresscircle);
    			/*div_binding*/ ctx[12](null);
    			if (detaching) detach_dev(t);
    			destroy_component(popover, detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	var cancel, dispatch, newValue, save, show, triggerClick, triggerRef;
    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	var { value = { percent_complete: 0, color: "light-gray" } } = $$props;
    	var { size = 24 } = $$props;
    	newValue = void 0;

    	// menu
    	show = false;

    	triggerClick = function () {
    		dispatch("open");
    		return $$invalidate(4, show = true);
    	};

    	triggerRef = void 0;

    	cancel = function () {
    		$$invalidate(4, show = false);
    		dispatch("close");
    		return newValue = value;
    	};

    	save = function (val, color) {
    		var progressItem;
    		newValue = { percent_complete: val, color };
    		$$invalidate(4, show = false);
    		progressItem = { id: item.id, progress: newValue };

    		if (newValue === 100) {
    			if (value.percent_complete < 100) {
    				// then add completion date, don''t change it if it was already 100%
    				progressItem["completion_date"] = Date.create();
    			}
    		} else {
    			if (value.percent_complete === 100) {
    				// then clear completion date
    				progressItem["completion_date"] = null;
    			}
    		}

    		dispatch("close");
    		return dispatch("update", progressItem);
    	};

    	const writable_props = ["item", "value", "size"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Progress> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Progress", $$slots, []);

    	function iconprogresscircle_value_binding(value) {
    		item.progress.percent_complete = value;
    		$$invalidate(0, item);
    	}

    	function iconprogresscircle_color_binding(value) {
    		item.progress.color = value;
    		$$invalidate(0, item);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(6, triggerRef = $$value);
    		});
    	}

    	function popover_show_binding(value) {
    		show = value;
    		$$invalidate(4, show);
    	}

    	function popover_trigger_binding(value) {
    		triggerRef = value;
    		$$invalidate(6, triggerRef);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("value" in $$props) $$invalidate(7, value = $$props.value);
    		if ("size" in $$props) $$invalidate(1, size = $$props.size);
    	};

    	$$self.$capture_state = () => ({
    		cancel,
    		dispatch,
    		newValue,
    		save,
    		show,
    		triggerClick,
    		triggerRef,
    		createEventDispatcher,
    		item,
    		value,
    		size,
    		Row,
    		RowCell,
    		Popover,
    		Tooltip,
    		IconProgressCircle
    	});

    	$$self.$inject_state = $$props => {
    		if ("cancel" in $$props) $$invalidate(2, cancel = $$props.cancel);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("newValue" in $$props) newValue = $$props.newValue;
    		if ("save" in $$props) $$invalidate(3, save = $$props.save);
    		if ("show" in $$props) $$invalidate(4, show = $$props.show);
    		if ("triggerClick" in $$props) $$invalidate(5, triggerClick = $$props.triggerClick);
    		if ("triggerRef" in $$props) $$invalidate(6, triggerRef = $$props.triggerRef);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("value" in $$props) $$invalidate(7, value = $$props.value);
    		if ("size" in $$props) $$invalidate(1, size = $$props.size);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 128) {
    			 newValue = {
    				percent_complete: value.percent_complete,
    				color: value.color
    			};
    		}
    	};

    	return [
    		item,
    		size,
    		cancel,
    		save,
    		show,
    		triggerClick,
    		triggerRef,
    		value,
    		dispatch,
    		newValue,
    		iconprogresscircle_value_binding,
    		iconprogresscircle_color_binding,
    		div_binding,
    		popover_show_binding,
    		popover_trigger_binding
    	];
    }

    class Progress extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { item: 0, value: 7, size: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Progress",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get item() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Date\DatePicker\Calendar.svelte generated by Svelte v3.22.2 */

    const { console: console_1$6 } = globals;
    const file$k = "src\\svelte\\components\\Date\\DatePicker\\Calendar.svelte";

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	child_ctx[24] = i;
    	return child_ctx;
    }

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	child_ctx[21] = i;
    	return child_ctx;
    }

    // (140:12) <RowCell>
    function create_default_slot_7(ctx) {
    	let button0;
    	let svg0;
    	let path0;
    	let t;
    	let button1;
    	let svg1;
    	let path1;
    	let path2;
    	let dispose;

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			t = space();
    			button1 = element("button");
    			svg1 = svg_element("svg");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			attr_dev(path0, "d", "M6,18V6H8V18H6M9.5,12L18,6V18L9.5,12Z");
    			add_location(path0, file$k, 141, 113, 3040);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "version", "1.1");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			add_location(svg0, file$k, 141, 16, 2943);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "icon", "");
    			add_location(button0, file$k, 140, 14, 2875);
    			attr_dev(path1, "fill", "none");
    			attr_dev(path1, "d", "M0 0h24v24H0V0z");
    			add_location(path1, file$k, 145, 99, 3282);
    			attr_dev(path2, "d", "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12l4.58-4.59z");
    			attr_dev(path2, "class", "fill");
    			add_location(path2, file$k, 145, 138, 3321);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			add_location(svg1, file$k, 145, 16, 3199);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "icon", "");
    			add_location(button1, file$k, 144, 14, 3135);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button0, anchor);
    			append_dev(button0, svg0);
    			append_dev(svg0, path0);
    			insert_dev(target, t, anchor);
    			insert_dev(target, button1, anchor);
    			append_dev(button1, svg1);
    			append_dev(svg1, path1);
    			append_dev(svg1, path2);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					button0,
    					"click",
    					function () {
    						if (is_function(/*previousYear*/ ctx[7])) /*previousYear*/ ctx[7].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button1,
    					"click",
    					function () {
    						if (is_function(/*previous*/ ctx[6])) /*previous*/ ctx[6].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(button1);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(140:12) <RowCell>",
    		ctx
    	});

    	return block;
    }

    // (149:12) <RowCell flex="flex">
    function create_default_slot_6(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*currentCalendarHeader*/ ctx[1]);
    			attr_dev(div, "monthname", "");
    			attr_dev(div, "class", "svelte-1229ek5");
    			add_location(div, file$k, 148, 33, 3488);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentCalendarHeader*/ 2) set_data_dev(t, /*currentCalendarHeader*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(149:12) <RowCell flex=\\\"flex\\\">",
    		ctx
    	});

    	return block;
    }

    // (150:12) <RowCell>
    function create_default_slot_5$1(ctx) {
    	let button0;
    	let svg0;
    	let path0;
    	let path1;
    	let t;
    	let button1;
    	let svg1;
    	let path2;
    	let dispose;

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t = space();
    			button1 = element("button");
    			svg1 = svg_element("svg");
    			path2 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$k, 151, 99, 3722);
    			attr_dev(path1, "d", "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6-6-6z");
    			attr_dev(path1, "class", "fill");
    			add_location(path1, file$k, 151, 138, 3761);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			add_location(svg0, file$k, 151, 16, 3639);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "icon", "");
    			add_location(button0, file$k, 150, 14, 3579);
    			attr_dev(path2, "d", "M16,18H18V6H16M6,18L14.5,12L6,6V18Z");
    			add_location(path2, file$k, 154, 113, 4042);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "version", "1.1");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			add_location(svg1, file$k, 154, 16, 3945);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "icon", "");
    			add_location(button1, file$k, 153, 14, 3881);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button0, anchor);
    			append_dev(button0, svg0);
    			append_dev(svg0, path0);
    			append_dev(svg0, path1);
    			insert_dev(target, t, anchor);
    			insert_dev(target, button1, anchor);
    			append_dev(button1, svg1);
    			append_dev(svg1, path2);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					button0,
    					"click",
    					function () {
    						if (is_function(/*next*/ ctx[4])) /*next*/ ctx[4].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button1,
    					"click",
    					function () {
    						if (is_function(/*nextYear*/ ctx[5])) /*nextYear*/ ctx[5].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(button1);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(150:12) <RowCell>",
    		ctx
    	});

    	return block;
    }

    // (139:10) <Row>
    function create_default_slot_4$1(ctx) {
    	let t0;
    	let t1;
    	let current;

    	const rowcell0 = new RowCell({
    			props: {
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const rowcell1 = new RowCell({
    			props: {
    				flex: "flex",
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const rowcell2 = new RowCell({
    			props: {
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rowcell0.$$.fragment);
    			t0 = space();
    			create_component(rowcell1.$$.fragment);
    			t1 = space();
    			create_component(rowcell2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rowcell0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(rowcell1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(rowcell2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const rowcell0_changes = {};

    			if (dirty & /*$$scope, previous, previousYear*/ 33554624) {
    				rowcell0_changes.$$scope = { dirty, ctx };
    			}

    			rowcell0.$set(rowcell0_changes);
    			const rowcell1_changes = {};

    			if (dirty & /*$$scope, currentCalendarHeader*/ 33554434) {
    				rowcell1_changes.$$scope = { dirty, ctx };
    			}

    			rowcell1.$set(rowcell1_changes);
    			const rowcell2_changes = {};

    			if (dirty & /*$$scope, nextYear, next*/ 33554480) {
    				rowcell2_changes.$$scope = { dirty, ctx };
    			}

    			rowcell2.$set(rowcell2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rowcell0.$$.fragment, local);
    			transition_in(rowcell1.$$.fragment, local);
    			transition_in(rowcell2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rowcell0.$$.fragment, local);
    			transition_out(rowcell1.$$.fragment, local);
    			transition_out(rowcell2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rowcell0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(rowcell1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(rowcell2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(139:10) <Row>",
    		ctx
    	});

    	return block;
    }

    // (182:12) {:else}
    function create_else_block_1(ctx) {
    	let td;
    	let button;
    	let t_value = /*day*/ ctx[22].format("{d}") + "";
    	let t;
    	let td_events_value;
    	let td_today_value;
    	let td_selected_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			td = element("td");
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "svelte-1229ek5");
    			add_location(button, file$k, 182, 115, 5076);
    			attr_dev(td, "month", "current");
    			attr_dev(td, "events", td_events_value = /*eventsForDay*/ ctx[3](/*day*/ ctx[22]).length);
    			attr_dev(td, "today", td_today_value = /*day*/ ctx[22].isToday());
    			attr_dev(td, "selected", td_selected_value = /*day*/ ctx[22].is(/*value*/ ctx[0]));
    			attr_dev(td, "class", "svelte-1229ek5");
    			add_location(td, file$k, 182, 14, 4975);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, td, anchor);
    			append_dev(td, button);
    			append_dev(button, t);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*setDay*/ ctx[8](/*day*/ ctx[22]))) /*setDay*/ ctx[8](/*day*/ ctx[22]).apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*weeks*/ 2048 && t_value !== (t_value = /*day*/ ctx[22].format("{d}") + "")) set_data_dev(t, t_value);

    			if (dirty & /*eventsForDay, weeks*/ 2056 && td_events_value !== (td_events_value = /*eventsForDay*/ ctx[3](/*day*/ ctx[22]).length)) {
    				attr_dev(td, "events", td_events_value);
    			}

    			if (dirty & /*weeks*/ 2048 && td_today_value !== (td_today_value = /*day*/ ctx[22].isToday())) {
    				attr_dev(td, "today", td_today_value);
    			}

    			if (dirty & /*weeks, value*/ 2049 && td_selected_value !== (td_selected_value = /*day*/ ctx[22].is(/*value*/ ctx[0]))) {
    				attr_dev(td, "selected", td_selected_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(182:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (176:12) {#if (parseInt(day.format("{M}")) != parseInt(currentMonth)) }
    function create_if_block$7(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*weekIndex*/ ctx[21] < 1) return create_if_block_1;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(176:12) {#if (parseInt(day.format(\\\"{M}\\\")) != parseInt(currentMonth)) }",
    		ctx
    	});

    	return block;
    }

    // (179:14) {:else}
    function create_else_block$2(ctx) {
    	let td;
    	let button;
    	let t_value = /*day*/ ctx[22].format("{d}") + "";
    	let t;
    	let td_events_value;
    	let td_selected_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			td = element("td");
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "svelte-1229ek5");
    			add_location(button, file$k, 179, 92, 4856);
    			attr_dev(td, "month", "next");
    			attr_dev(td, "events", td_events_value = /*eventsForDay*/ ctx[3](/*day*/ ctx[22]).length);
    			attr_dev(td, "selected", td_selected_value = /*day*/ ctx[22].is(/*value*/ ctx[0]));
    			attr_dev(td, "class", "svelte-1229ek5");
    			add_location(td, file$k, 179, 16, 4780);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, td, anchor);
    			append_dev(td, button);
    			append_dev(button, t);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*setDay*/ ctx[8](/*day*/ ctx[22]))) /*setDay*/ ctx[8](/*day*/ ctx[22]).apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*weeks*/ 2048 && t_value !== (t_value = /*day*/ ctx[22].format("{d}") + "")) set_data_dev(t, t_value);

    			if (dirty & /*eventsForDay, weeks*/ 2056 && td_events_value !== (td_events_value = /*eventsForDay*/ ctx[3](/*day*/ ctx[22]).length)) {
    				attr_dev(td, "events", td_events_value);
    			}

    			if (dirty & /*weeks, value*/ 2049 && td_selected_value !== (td_selected_value = /*day*/ ctx[22].is(/*value*/ ctx[0]))) {
    				attr_dev(td, "selected", td_selected_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(179:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (177:14) {#if (weekIndex < 1) }
    function create_if_block_1(ctx) {
    	let td;
    	let button;
    	let t_value = /*day*/ ctx[22].format("{d}") + "";
    	let t;
    	let td_events_value;
    	let td_selected_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			td = element("td");
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "svelte-1229ek5");
    			add_location(button, file$k, 177, 96, 4677);
    			attr_dev(td, "month", "previous");
    			attr_dev(td, "events", td_events_value = /*eventsForDay*/ ctx[3](/*day*/ ctx[22]).length);
    			attr_dev(td, "selected", td_selected_value = /*day*/ ctx[22].is(/*value*/ ctx[0]));
    			attr_dev(td, "class", "svelte-1229ek5");
    			add_location(td, file$k, 177, 16, 4597);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, td, anchor);
    			append_dev(td, button);
    			append_dev(button, t);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*setDay*/ ctx[8](/*day*/ ctx[22]))) /*setDay*/ ctx[8](/*day*/ ctx[22]).apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*weeks*/ 2048 && t_value !== (t_value = /*day*/ ctx[22].format("{d}") + "")) set_data_dev(t, t_value);

    			if (dirty & /*eventsForDay, weeks*/ 2056 && td_events_value !== (td_events_value = /*eventsForDay*/ ctx[3](/*day*/ ctx[22]).length)) {
    				attr_dev(td, "events", td_events_value);
    			}

    			if (dirty & /*weeks, value*/ 2049 && td_selected_value !== (td_selected_value = /*day*/ ctx[22].is(/*value*/ ctx[0]))) {
    				attr_dev(td, "selected", td_selected_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(177:14) {#if (weekIndex < 1) }",
    		ctx
    	});

    	return block;
    }

    // (175:10) {#each week as day, dayindex}
    function create_each_block_1$1(ctx) {
    	let show_if;
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (show_if == null || dirty & /*weeks, currentMonth*/ 2052) show_if = !!(parseInt(/*day*/ ctx[22].format("{M}")) != parseInt(/*currentMonth*/ ctx[2]));
    		if (show_if) return create_if_block$7;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(175:10) {#each week as day, dayindex}",
    		ctx
    	});

    	return block;
    }

    // (172:6) {#each weeks as week, weekIndex}
    function create_each_block$1(ctx) {
    	let tr;
    	let t;
    	let each_value_1 = /*week*/ ctx[19];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			add_location(tr, file$k, 172, 8, 4423);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tr, null);
    			}

    			append_dev(tr, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*eventsForDay, weeks, value, setDay, parseInt, currentMonth*/ 2317) {
    				each_value_1 = /*week*/ ctx[19];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tr, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(172:6) {#each weeks as week, weekIndex}",
    		ctx
    	});

    	return block;
    }

    // (193:12) <RowCell style="width: 33%">
    function create_default_slot_3$1(ctx) {
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Yesterday";
    			attr_dev(button, "type", "button");
    			attr_dev(button, "dayshortcut", "");
    			attr_dev(button, "class", "svelte-1229ek5");
    			add_location(button, file$k, 193, 14, 5335);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*yesterday*/ ctx[12])) /*yesterday*/ ctx[12].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(193:12) <RowCell style=\\\"width: 33%\\\">",
    		ctx
    	});

    	return block;
    }

    // (198:12) <RowCell flex="flex" style="width: 33%">
    function create_default_slot_2$2(ctx) {
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Today";
    			attr_dev(button, "type", "button");
    			attr_dev(button, "dayshortcut", "");
    			attr_dev(button, "class", "svelte-1229ek5");
    			add_location(button, file$k, 198, 14, 5531);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*today*/ ctx[9])) /*today*/ ctx[9].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(198:12) <RowCell flex=\\\"flex\\\" style=\\\"width: 33%\\\">",
    		ctx
    	});

    	return block;
    }

    // (203:12) <RowCell style="width: 33%">
    function create_default_slot_1$2(ctx) {
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Tomorrow";
    			attr_dev(button, "type", "button");
    			attr_dev(button, "dayshortcut", "");
    			attr_dev(button, "class", "svelte-1229ek5");
    			add_location(button, file$k, 203, 14, 5709);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*tomorrow*/ ctx[10])) /*tomorrow*/ ctx[10].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(203:12) <RowCell style=\\\"width: 33%\\\">",
    		ctx
    	});

    	return block;
    }

    // (192:10) <Row>
    function create_default_slot$4(ctx) {
    	let t0;
    	let t1;
    	let current;

    	const rowcell0 = new RowCell({
    			props: {
    				style: "width: 33%",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const rowcell1 = new RowCell({
    			props: {
    				flex: "flex",
    				style: "width: 33%",
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const rowcell2 = new RowCell({
    			props: {
    				style: "width: 33%",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rowcell0.$$.fragment);
    			t0 = space();
    			create_component(rowcell1.$$.fragment);
    			t1 = space();
    			create_component(rowcell2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rowcell0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(rowcell1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(rowcell2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const rowcell0_changes = {};

    			if (dirty & /*$$scope, yesterday*/ 33558528) {
    				rowcell0_changes.$$scope = { dirty, ctx };
    			}

    			rowcell0.$set(rowcell0_changes);
    			const rowcell1_changes = {};

    			if (dirty & /*$$scope, today*/ 33554944) {
    				rowcell1_changes.$$scope = { dirty, ctx };
    			}

    			rowcell1.$set(rowcell1_changes);
    			const rowcell2_changes = {};

    			if (dirty & /*$$scope, tomorrow*/ 33555456) {
    				rowcell2_changes.$$scope = { dirty, ctx };
    			}

    			rowcell2.$set(rowcell2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rowcell0.$$.fragment, local);
    			transition_in(rowcell1.$$.fragment, local);
    			transition_in(rowcell2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rowcell0.$$.fragment, local);
    			transition_out(rowcell1.$$.fragment, local);
    			transition_out(rowcell2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rowcell0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(rowcell1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(rowcell2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(192:10) <Row>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div;
    	let table;
    	let thead;
    	let tr0;
    	let td0;
    	let t0;
    	let tr1;
    	let td1;
    	let t2;
    	let td2;
    	let t4;
    	let td3;
    	let t6;
    	let td4;
    	let t8;
    	let td5;
    	let t10;
    	let td6;
    	let t12;
    	let td7;
    	let t14;
    	let tbody;
    	let t15;
    	let tfoot;
    	let tr2;
    	let td8;
    	let current;

    	const row0 = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value = /*weeks*/ ctx[11];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const row1 = new Row({
    			props: {
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			td0 = element("td");
    			create_component(row0.$$.fragment);
    			t0 = space();
    			tr1 = element("tr");
    			td1 = element("td");
    			td1.textContent = "S";
    			t2 = space();
    			td2 = element("td");
    			td2.textContent = "M";
    			t4 = space();
    			td3 = element("td");
    			td3.textContent = "T";
    			t6 = space();
    			td4 = element("td");
    			td4.textContent = "W";
    			t8 = space();
    			td5 = element("td");
    			td5.textContent = "T";
    			t10 = space();
    			td6 = element("td");
    			td6.textContent = "F";
    			t12 = space();
    			td7 = element("td");
    			td7.textContent = "S";
    			t14 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t15 = space();
    			tfoot = element("tfoot");
    			tr2 = element("tr");
    			td8 = element("td");
    			create_component(row1.$$.fragment);
    			attr_dev(td0, "colspan", "7");
    			add_location(td0, file$k, 137, 8, 2808);
    			add_location(tr0, file$k, 136, 6, 2795);
    			attr_dev(td1, "class", "svelte-1229ek5");
    			add_location(td1, file$k, 161, 8, 4214);
    			attr_dev(td2, "class", "svelte-1229ek5");
    			add_location(td2, file$k, 162, 8, 4233);
    			attr_dev(td3, "class", "svelte-1229ek5");
    			add_location(td3, file$k, 163, 8, 4252);
    			attr_dev(td4, "class", "svelte-1229ek5");
    			add_location(td4, file$k, 164, 8, 4271);
    			attr_dev(td5, "class", "svelte-1229ek5");
    			add_location(td5, file$k, 165, 8, 4290);
    			attr_dev(td6, "class", "svelte-1229ek5");
    			add_location(td6, file$k, 166, 8, 4309);
    			attr_dev(td7, "class", "svelte-1229ek5");
    			add_location(td7, file$k, 167, 8, 4328);
    			attr_dev(tr1, "weekdays", "");
    			attr_dev(tr1, "class", "svelte-1229ek5");
    			add_location(tr1, file$k, 160, 6, 4192);
    			add_location(thead, file$k, 134, 4, 2780);
    			attr_dev(tbody, "class", "svelte-1229ek5");
    			add_location(tbody, file$k, 170, 4, 4368);
    			attr_dev(td8, "colspan", "7");
    			attr_dev(td8, "class", "svelte-1229ek5");
    			add_location(td8, file$k, 190, 8, 5249);
    			add_location(tr2, file$k, 189, 6, 5236);
    			attr_dev(tfoot, "class", "svelte-1229ek5");
    			add_location(tfoot, file$k, 188, 4, 5222);
    			attr_dev(table, "calendar", "");
    			attr_dev(table, "class", "svelte-1229ek5");
    			add_location(table, file$k, 133, 2, 2759);
    			attr_dev(div, "container", "");
    			attr_dev(div, "class", "svelte-1229ek5");
    			add_location(div, file$k, 129, 0, 2738);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, table);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, td0);
    			mount_component(row0, td0, null);
    			append_dev(thead, t0);
    			append_dev(thead, tr1);
    			append_dev(tr1, td1);
    			append_dev(tr1, t2);
    			append_dev(tr1, td2);
    			append_dev(tr1, t4);
    			append_dev(tr1, td3);
    			append_dev(tr1, t6);
    			append_dev(tr1, td4);
    			append_dev(tr1, t8);
    			append_dev(tr1, td5);
    			append_dev(tr1, t10);
    			append_dev(tr1, td6);
    			append_dev(tr1, t12);
    			append_dev(tr1, td7);
    			append_dev(table, t14);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(table, t15);
    			append_dev(table, tfoot);
    			append_dev(tfoot, tr2);
    			append_dev(tr2, td8);
    			mount_component(row1, td8, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const row0_changes = {};

    			if (dirty & /*$$scope, nextYear, next, currentCalendarHeader, previous, previousYear*/ 33554674) {
    				row0_changes.$$scope = { dirty, ctx };
    			}

    			row0.$set(row0_changes);

    			if (dirty & /*weeks, eventsForDay, value, setDay, parseInt, currentMonth*/ 2317) {
    				each_value = /*weeks*/ ctx[11];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			const row1_changes = {};

    			if (dirty & /*$$scope, tomorrow, today, yesterday*/ 33560064) {
    				row1_changes.$$scope = { dirty, ctx };
    			}

    			row1.$set(row1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row0.$$.fragment, local);
    			transition_in(row1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row0.$$.fragment, local);
    			transition_out(row1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(row0);
    			destroy_each(each_blocks, detaching);
    			destroy_component(row1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	var current,
    		currentCalendar,
    		currentCalendarHeader,
    		currentMonth,
    		dispatch,
    		displayDate,
    		eventsForDay,
    		generate,
    		next,
    		nextYear,
    		previous,
    		previousYear,
    		setDay,
    		today,
    		tomorrow,
    		weeks,
    		yesterday;

    	var { value = null } = $$props;
    	var { events = [] } = $$props;
    	dispatch = createEventDispatcher();
    	weeks = [];
    	console.log(events);

    	eventsForDay = function (day) {
    		if (events.length === 0) {
    			return [];
    		} else {
    			return events.filter(function (event) {
    				return Date.create(event.start).format("{MM}{dd}") === Date.create(day).format("{MM}{dd}");
    			});
    		}
    	};

    	currentCalendar = [];
    	currentMonth = null;
    	currentCalendarHeader = null;

    	generate = function () {
    		var calendarEnd, calendarStart, count, currentWeek, results, runningDate;
    		$$invalidate(11, weeks = []);

    		if (typeof displayDate !== "undefined" && displayDate !== null) {
    			console.log("displayDate");
    			console.log(displayDate);
    			$$invalidate(1, currentCalendarHeader = displayDate.format("{Month} {yyyy}"));
    			$$invalidate(2, currentMonth = displayDate.format("{M}"));
    			calendarStart = displayDate.clone().beginningOfMonth().beginningOfWeek();
    			calendarEnd = displayDate.clone().endOfMonth().endOfWeek();
    			runningDate = calendarStart.clone();
    			currentWeek = [];
    			count = 0;
    			results = [];

    			while (runningDate.isBetween(calendarStart, calendarEnd)) {
    				currentWeek.push(runningDate.clone());
    				runningDate.addDays(1);
    				count++;

    				if (count === 7) {
    					weeks.push(currentWeek);
    					currentWeek = [];
    					results.push(count = 0);
    				} else {
    					results.push(void 0);
    				}
    			}

    			return results;
    		}
    	};

    	displayDate = void 0;

    	current = function () {
    		console.log("Value");
    		console.log(value);

    		if (value != null) {
    			displayDate = Date.create(value);
    		} else {
    			displayDate = Date.create();
    		}

    		return generate();
    	};

    	next = function () {
    		displayDate.addMonths(1);
    		generate();
    		return console.log(`value ${value}`);
    	};

    	previous = function () {
    		displayDate.addMonths(-1);
    		generate();
    		return console.log(`value ${value}`);
    	};

    	nextYear = function () {
    		displayDate.addYears(1);
    		generate();
    		return console.log(`value ${value}`);
    	};

    	previousYear = function () {
    		displayDate.addYears(-1);
    		generate();
    		return console.log(`value ${value}`);
    	};

    	today = function () {
    		setDay(Date.create());
    		return console.log("today");
    	};

    	yesterday = function () {
    		return setDay(Date.create("yesterday"));
    	};

    	tomorrow = function () {
    		return setDay(Date.create("tomorrow"));
    	};

    	current();

    	setDay = function (day) {
    		console.log(`CALENDAR SETDAY ${day}`);
    		return dispatch("change", day);
    	};

    	const writable_props = ["value", "events"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<Calendar> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Calendar", $$slots, []);

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("events" in $$props) $$invalidate(13, events = $$props.events);
    	};

    	$$self.$capture_state = () => ({
    		current,
    		currentCalendar,
    		currentCalendarHeader,
    		currentMonth,
    		dispatch,
    		displayDate,
    		eventsForDay,
    		generate,
    		next,
    		nextYear,
    		previous,
    		previousYear,
    		setDay,
    		today,
    		tomorrow,
    		weeks,
    		yesterday,
    		value,
    		events,
    		Row,
    		RowCell,
    		createEventDispatcher
    	});

    	$$self.$inject_state = $$props => {
    		if ("current" in $$props) current = $$props.current;
    		if ("currentCalendar" in $$props) currentCalendar = $$props.currentCalendar;
    		if ("currentCalendarHeader" in $$props) $$invalidate(1, currentCalendarHeader = $$props.currentCalendarHeader);
    		if ("currentMonth" in $$props) $$invalidate(2, currentMonth = $$props.currentMonth);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("displayDate" in $$props) displayDate = $$props.displayDate;
    		if ("eventsForDay" in $$props) $$invalidate(3, eventsForDay = $$props.eventsForDay);
    		if ("generate" in $$props) generate = $$props.generate;
    		if ("next" in $$props) $$invalidate(4, next = $$props.next);
    		if ("nextYear" in $$props) $$invalidate(5, nextYear = $$props.nextYear);
    		if ("previous" in $$props) $$invalidate(6, previous = $$props.previous);
    		if ("previousYear" in $$props) $$invalidate(7, previousYear = $$props.previousYear);
    		if ("setDay" in $$props) $$invalidate(8, setDay = $$props.setDay);
    		if ("today" in $$props) $$invalidate(9, today = $$props.today);
    		if ("tomorrow" in $$props) $$invalidate(10, tomorrow = $$props.tomorrow);
    		if ("weeks" in $$props) $$invalidate(11, weeks = $$props.weeks);
    		if ("yesterday" in $$props) $$invalidate(12, yesterday = $$props.yesterday);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("events" in $$props) $$invalidate(13, events = $$props.events);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		currentCalendarHeader,
    		currentMonth,
    		eventsForDay,
    		next,
    		nextYear,
    		previous,
    		previousYear,
    		setDay,
    		today,
    		tomorrow,
    		weeks,
    		yesterday,
    		events
    	];
    }

    class Calendar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { value: 0, events: 13 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Calendar",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get value() {
    		throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get events() {
    		throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set events(value) {
    		throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Format\RelativeDateFormat.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$1, console: console_1$7 } = globals;

    function create_fragment$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*output*/ ctx[0]);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*output*/ 1) set_data_dev(t, /*output*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	var recalc, translate;
    	var { value = void 0 } = $$props;

    	// todo: show time will change conditions
    	translate = function (val) {
    		var isFuture, theDate;

    		if (Object.isDate(val)) {
    			theDate = val;
    		} else {
    			theDate = Date.create(val);
    		}
    		isFuture = theDate.isFuture();

    		if (theDate.isToday()) {
    			return "Today";
    		} else if (theDate.isTomorrow()) {
    			return "Tomorrow";
    		} else if (theDate.isYesterday()) {
    			return "Yesterday";
    		} else if (theDate.isBetween(Date.create(), Date.create().endOfWeek())) {
    			return theDate.format("%A");
    		} else if (theDate.isBetween(Date.create().addWeeks(1).beginningOfWeek(), Date.create().addWeeks(1).endOfWeek())) {
    			return theDate.format("Next %A");
    		} else {
    			return theDate.format("%a, %b {d}, %Y");
    		}
    	};

    	recalc = function () {
    		$$invalidate(1, value);
    		return console.log(`recalc value ${translate(value)}`);
    	};

    	recalc();
    	recalc.every(60 * 1000); // recalc every minute
    	const writable_props = ["value"];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<RelativeDateFormat> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("RelativeDateFormat", $$slots, []);

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({ recalc, translate, value, output });

    	$$self.$inject_state = $$props => {
    		if ("recalc" in $$props) recalc = $$props.recalc;
    		if ("translate" in $$props) $$invalidate(3, translate = $$props.translate);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("output" in $$props) $$invalidate(0, output = $$props.output);
    	};

    	let output;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*translate, value*/ 10) {
    			 $$invalidate(0, output = translate(value));
    		}
    	};

    	return [output, value];
    }

    class RelativeDateFormat extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { value: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RelativeDateFormat",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get value() {
    		throw new Error("<RelativeDateFormat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<RelativeDateFormat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Popovers\DueDate.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$2 } = globals;
    const file$l = "src\\svelte\\pages\\_Common\\Popovers\\DueDate.svelte";

    // (137:6) {:else}
    function create_else_block_2(ctx) {
    	let a;
    	let em;
    	let t;
    	let current;
    	let if_block = !/*isListItem*/ ctx[0] && create_if_block_3(ctx);

    	const relativedateformat = new RelativeDateFormat({
    			props: { value: /*newValue*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			em = element("em");
    			if (if_block) if_block.c();
    			t = space();
    			create_component(relativedateformat.$$.fragment);
    			add_location(em, file$l, 137, 40, 2748);
    			attr_dev(a, "duedate", "");
    			attr_dev(a, "state", /*state*/ ctx[9]);
    			attr_dev(a, "islistitem", /*isListItem*/ ctx[0]);
    			attr_dev(a, "class", "svelte-1k3fyxy");
    			add_location(a, file$l, 137, 8, 2716);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, em);
    			if (if_block) if_block.m(em, null);
    			append_dev(em, t);
    			mount_component(relativedateformat, em, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*isListItem*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3(ctx);
    					if_block.c();
    					if_block.m(em, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const relativedateformat_changes = {};
    			if (dirty & /*newValue*/ 16) relativedateformat_changes.value = /*newValue*/ ctx[4];
    			relativedateformat.$set(relativedateformat_changes);

    			if (!current || dirty & /*state*/ 512) {
    				attr_dev(a, "state", /*state*/ ctx[9]);
    			}

    			if (!current || dirty & /*isListItem*/ 1) {
    				attr_dev(a, "islistitem", /*isListItem*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(relativedateformat.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(relativedateformat.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block) if_block.d();
    			destroy_component(relativedateformat);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(137:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (131:6) {#if newValue == null}
    function create_if_block_1$1(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*isListItem*/ ctx[0]) return create_if_block_2;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(131:6) {#if newValue == null}",
    		ctx
    	});

    	return block;
    }

    // (139:10) {#if !isListItem}
    function create_if_block_3(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text("Due");
    			attr_dev(span, "duedate", "");
    			attr_dev(span, "state", /*state*/ ctx[9]);
    			attr_dev(span, "class", "svelte-1k3fyxy");
    			add_location(span, file$l, 139, 12, 2793);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*state*/ 512) {
    				attr_dev(span, "state", /*state*/ ctx[9]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(139:10) {#if !isListItem}",
    		ctx
    	});

    	return block;
    }

    // (134:8) {:else}
    function create_else_block_1$1(ctx) {
    	let a;
    	let em;

    	const block = {
    		c: function create() {
    			a = element("a");
    			em = element("em");
    			em.textContent = "No Due Date specified";
    			add_location(em, file$l, 134, 42, 2645);
    			attr_dev(a, "duedate", "");
    			attr_dev(a, "state", /*state*/ ctx[9]);
    			attr_dev(a, "islistitem", /*isListItem*/ ctx[0]);
    			attr_dev(a, "class", "svelte-1k3fyxy");
    			add_location(a, file$l, 134, 10, 2613);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, em);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*state*/ 512) {
    				attr_dev(a, "state", /*state*/ ctx[9]);
    			}

    			if (dirty & /*isListItem*/ 1) {
    				attr_dev(a, "islistitem", /*isListItem*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(134:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (132:8) {#if isListItem}
    function create_if_block_2(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			attr_dev(path0, "fill", "none");
    			add_location(path0, file$l, 132, 93, 2459);
    			attr_dev(path1, "d", "M22 3h-3V1h-2v2H7V1H5v2H2v20h20V3zm-2 18H4V8h16v13z");
    			attr_dev(path1, "fill", "var(--gray)");
    			add_location(path1, file$l, 132, 132, 2498);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "width", "24");
    			add_location(svg, file$l, 132, 10, 2376);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(132:8) {#if isListItem}",
    		ctx
    	});

    	return block;
    }

    // (154:12) {:else}
    function create_else_block$3(ctx) {
    	let current;

    	const relativedateformat = new RelativeDateFormat({
    			props: {
    				value: /*dueDate*/ ctx[3](/*newValue*/ ctx[4])
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(relativedateformat.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(relativedateformat, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const relativedateformat_changes = {};
    			if (dirty & /*dueDate, newValue*/ 24) relativedateformat_changes.value = /*dueDate*/ ctx[3](/*newValue*/ ctx[4]);
    			relativedateformat.$set(relativedateformat_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(relativedateformat.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(relativedateformat.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(relativedateformat, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(154:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (152:12) {#if newValue == null}
    function create_if_block$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No Due Date");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(152:12) {#if newValue == null}",
    		ctx
    	});

    	return block;
    }

    // (151:10) <RowCell flex="flex" style="padding: 4px 0px 4px 8px">
    function create_default_slot_6$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$8, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*newValue*/ ctx[4] == null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(151:10) <RowCell flex=\\\"flex\\\" style=\\\"padding: 4px 0px 4px 8px\\\">",
    		ctx
    	});

    	return block;
    }

    // (158:10) <RowCell>
    function create_default_slot_5$2(ctx) {
    	let button;
    	let svg;
    	let path0;
    	let path1;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$l, 159, 97, 3500);
    			attr_dev(path1, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z");
    			attr_dev(path1, "class", "fill");
    			add_location(path1, file$l, 159, 136, 3539);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$l, 159, 14, 3417);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$l, 158, 12, 3358);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*clear*/ ctx[2])) /*clear*/ ctx[2].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(158:10) <RowCell>",
    		ctx
    	});

    	return block;
    }

    // (150:8) <Row>
    function create_default_slot_4$2(ctx) {
    	let t;
    	let current;

    	const rowcell0 = new RowCell({
    			props: {
    				flex: "flex",
    				style: "padding: 4px 0px 4px 8px",
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const rowcell1 = new RowCell({
    			props: {
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rowcell0.$$.fragment);
    			t = space();
    			create_component(rowcell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rowcell0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(rowcell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const rowcell0_changes = {};

    			if (dirty & /*$$scope, newValue, dueDate*/ 524312) {
    				rowcell0_changes.$$scope = { dirty, ctx };
    			}

    			rowcell0.$set(rowcell0_changes);
    			const rowcell1_changes = {};

    			if (dirty & /*$$scope, clear*/ 524292) {
    				rowcell1_changes.$$scope = { dirty, ctx };
    			}

    			rowcell1.$set(rowcell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rowcell0.$$.fragment, local);
    			transition_in(rowcell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rowcell0.$$.fragment, local);
    			transition_out(rowcell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rowcell0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(rowcell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(150:8) <Row>",
    		ctx
    	});

    	return block;
    }

    // (149:6) <ColumnCell>
    function create_default_slot_3$2(ctx) {
    	let current;

    	const row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, clear, newValue, dueDate*/ 524316) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(149:6) <ColumnCell>",
    		ctx
    	});

    	return block;
    }

    // (165:6) <ColumnCell>
    function create_default_slot_2$3(ctx) {
    	let div;
    	let updating_value;
    	let current;

    	function calendar_value_binding(value) {
    		/*calendar_value_binding*/ ctx[16].call(null, value);
    	}

    	let calendar_props = {};

    	if (/*newValue*/ ctx[4] !== void 0) {
    		calendar_props.value = /*newValue*/ ctx[4];
    	}

    	const calendar = new Calendar({ props: calendar_props, $$inline: true });
    	binding_callbacks.push(() => bind(calendar, "value", calendar_value_binding));

    	calendar.$on("change", function () {
    		if (is_function(/*setDate*/ ctx[5])) /*setDate*/ ctx[5].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(calendar.$$.fragment);
    			attr_dev(div, "calendar", "");
    			attr_dev(div, "class", "svelte-1k3fyxy");
    			add_location(div, file$l, 165, 8, 3785);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(calendar, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const calendar_changes = {};

    			if (!updating_value && dirty & /*newValue*/ 16) {
    				updating_value = true;
    				calendar_changes.value = /*newValue*/ ctx[4];
    				add_flush_callback(() => updating_value = false);
    			}

    			calendar.$set(calendar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(calendar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(calendar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(calendar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(165:6) <ColumnCell>",
    		ctx
    	});

    	return block;
    }

    // (148:4) <Column>
    function create_default_slot_1$3(ctx) {
    	let t;
    	let current;

    	const columncell0 = new ColumnCell({
    			props: {
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const columncell1 = new ColumnCell({
    			props: {
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(columncell0.$$.fragment);
    			t = space();
    			create_component(columncell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(columncell0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(columncell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const columncell0_changes = {};

    			if (dirty & /*$$scope, clear, newValue, dueDate*/ 524316) {
    				columncell0_changes.$$scope = { dirty, ctx };
    			}

    			columncell0.$set(columncell0_changes);
    			const columncell1_changes = {};

    			if (dirty & /*$$scope, newValue, setDate*/ 524336) {
    				columncell1_changes.$$scope = { dirty, ctx };
    			}

    			columncell1.$set(columncell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(columncell0.$$.fragment, local);
    			transition_in(columncell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(columncell0.$$.fragment, local);
    			transition_out(columncell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(columncell0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(columncell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(148:4) <Column>",
    		ctx
    	});

    	return block;
    }

    // (147:2) <Popover bind:show={show} on:close={cancel} bind:trigger={triggerRef} width="240px" align="right">
    function create_default_slot$5(ctx) {
    	let current;

    	const column = new Column({
    			props: {
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(column.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(column, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const column_changes = {};

    			if (dirty & /*$$scope, newValue, setDate, clear, dueDate*/ 524348) {
    				column_changes.$$scope = { dirty, ctx };
    			}

    			column.$set(column_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(column.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(column.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(column, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(147:2) <Popover bind:show={show} on:close={cancel} bind:trigger={triggerRef} width=\\\"240px\\\" align=\\\"right\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div1;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let updating_show;
    	let updating_trigger;
    	let current;
    	let dispose;
    	const if_block_creators = [create_if_block_1$1, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*newValue*/ ctx[4] == null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function popover_show_binding(value) {
    		/*popover_show_binding*/ ctx[17].call(null, value);
    	}

    	function popover_trigger_binding(value) {
    		/*popover_trigger_binding*/ ctx[18].call(null, value);
    	}

    	let popover_props = {
    		width: "240px",
    		align: "right",
    		$$slots: { default: [create_default_slot$5] },
    		$$scope: { ctx }
    	};

    	if (/*show*/ ctx[6] !== void 0) {
    		popover_props.show = /*show*/ ctx[6];
    	}

    	if (/*triggerRef*/ ctx[8] !== void 0) {
    		popover_props.trigger = /*triggerRef*/ ctx[8];
    	}

    	const popover = new Popover({ props: popover_props, $$inline: true });
    	binding_callbacks.push(() => bind(popover, "show", popover_show_binding));
    	binding_callbacks.push(() => bind(popover, "trigger", popover_trigger_binding));

    	popover.$on("close", function () {
    		if (is_function(/*cancel*/ ctx[1])) /*cancel*/ ctx[1].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t = space();
    			create_component(popover.$$.fragment);
    			add_location(div0, file$l, 128, 2, 2258);
    			add_location(div1, file$l, 127, 0, 2250);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			/*div0_binding*/ ctx[15](div0);
    			append_dev(div1, t);
    			mount_component(popover, div1, null);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div0,
    				"click",
    				function () {
    					if (is_function(/*triggerClick*/ ctx[7])) /*triggerClick*/ ctx[7].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			const popover_changes = {};

    			if (dirty & /*$$scope, newValue, setDate, clear, dueDate*/ 524348) {
    				popover_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_show && dirty & /*show*/ 64) {
    				updating_show = true;
    				popover_changes.show = /*show*/ ctx[6];
    				add_flush_callback(() => updating_show = false);
    			}

    			if (!updating_trigger && dirty & /*triggerRef*/ 256) {
    				updating_trigger = true;
    				popover_changes.trigger = /*triggerRef*/ ctx[8];
    				add_flush_callback(() => updating_trigger = false);
    			}

    			popover.$set(popover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(popover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(popover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    			/*div0_binding*/ ctx[15](null);
    			destroy_component(popover);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	var cancel,
    		clear,
    		dispatch,
    		dueDate,
    		dueDateState,
    		newValue,
    		save,
    		setDate,
    		show,
    		triggerClick,
    		triggerRef;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	var { value = null } = $$props;
    	var { isListItem = true } = $$props;
    	newValue = void 0;

    	// menu
    	show = false;

    	triggerClick = function () {
    		dispatch("open");
    		return $$invalidate(6, show = true);
    	};

    	triggerRef = void 0;

    	setDate = function (e) {
    		$$invalidate(4, newValue = e.detail);
    		save();
    		return cancel();
    	};

    	cancel = function () {
    		$$invalidate(6, show = false);
    		dispatch("close");
    		return $$invalidate(4, newValue = value);
    	};

    	save = function () {
    		$$invalidate(6, show = false);
    		dispatch("close");
    		return dispatch("update", { id: item.id, due_date: newValue });
    	};

    	clear = function () {
    		$$invalidate(4, newValue = null);
    		return save();
    	};

    	dueDate = function (due_date) {
    		if (due_date != null) {
    			if (Object.isDate(due_date)) {
    				return due_date;
    			} else {
    				return Date.create(due_date);
    			}
    		} else {
    			return due_date;
    		}
    	};

    	dueDateState = function (item, date) {
    		if (date != null) {
    			if (item.percent_complete === 100) {
    				return "complete";
    			} else {
    				if (Object.isDate(date)) {
    					return date.comparedTo(Date.create());
    				} else {
    					return Date.create(date).comparedTo(Date.create());
    				}
    			}
    		} else {
    			return "before";
    		}
    	};

    	const writable_props = ["item", "value", "isListItem"];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DueDate> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DueDate", $$slots, []);

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(8, triggerRef = $$value);
    		});
    	}

    	function calendar_value_binding(value$1) {
    		newValue = value$1;
    		($$invalidate(4, newValue), $$invalidate(11, value));
    	}

    	function popover_show_binding(value) {
    		show = value;
    		$$invalidate(6, show);
    	}

    	function popover_trigger_binding(value) {
    		triggerRef = value;
    		$$invalidate(8, triggerRef);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(10, item = $$props.item);
    		if ("value" in $$props) $$invalidate(11, value = $$props.value);
    		if ("isListItem" in $$props) $$invalidate(0, isListItem = $$props.isListItem);
    	};

    	$$self.$capture_state = () => ({
    		cancel,
    		clear,
    		dispatch,
    		dueDate,
    		dueDateState,
    		newValue,
    		save,
    		setDate,
    		show,
    		triggerClick,
    		triggerRef,
    		createEventDispatcher,
    		item,
    		value,
    		isListItem,
    		Popover,
    		Column,
    		ColumnCell,
    		Row,
    		RowCell,
    		Calendar,
    		RelativeDateFormat,
    		state
    	});

    	$$self.$inject_state = $$props => {
    		if ("cancel" in $$props) $$invalidate(1, cancel = $$props.cancel);
    		if ("clear" in $$props) $$invalidate(2, clear = $$props.clear);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("dueDate" in $$props) $$invalidate(3, dueDate = $$props.dueDate);
    		if ("dueDateState" in $$props) $$invalidate(13, dueDateState = $$props.dueDateState);
    		if ("newValue" in $$props) $$invalidate(4, newValue = $$props.newValue);
    		if ("save" in $$props) save = $$props.save;
    		if ("setDate" in $$props) $$invalidate(5, setDate = $$props.setDate);
    		if ("show" in $$props) $$invalidate(6, show = $$props.show);
    		if ("triggerClick" in $$props) $$invalidate(7, triggerClick = $$props.triggerClick);
    		if ("triggerRef" in $$props) $$invalidate(8, triggerRef = $$props.triggerRef);
    		if ("item" in $$props) $$invalidate(10, item = $$props.item);
    		if ("value" in $$props) $$invalidate(11, value = $$props.value);
    		if ("isListItem" in $$props) $$invalidate(0, isListItem = $$props.isListItem);
    		if ("state" in $$props) $$invalidate(9, state = $$props.state);
    	};

    	let state;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 2048) {
    			 $$invalidate(4, newValue = value);
    		}

    		if ($$self.$$.dirty & /*dueDateState, item, newValue*/ 9232) {
    			 $$invalidate(9, state = dueDateState(item, newValue));
    		}
    	};

    	return [
    		isListItem,
    		cancel,
    		clear,
    		dueDate,
    		newValue,
    		setDate,
    		show,
    		triggerClick,
    		triggerRef,
    		state,
    		item,
    		value,
    		dispatch,
    		dueDateState,
    		save,
    		div0_binding,
    		calendar_value_binding,
    		popover_show_binding,
    		popover_trigger_binding
    	];
    }

    class DueDate extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { item: 10, value: 11, isListItem: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DueDate",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get item() {
    		throw new Error("<DueDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<DueDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<DueDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<DueDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isListItem() {
    		throw new Error("<DueDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isListItem(value) {
    		throw new Error("<DueDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Overlay\Menu\ComposedMenuFavorites.svelte generated by Svelte v3.22.2 */
    const file$m = "src\\svelte\\components\\Overlay\\Menu\\ComposedMenuFavorites.svelte";

    // (126:0) {#if showMenu}
    function create_if_block$9(ctx) {
    	let div;
    	let div_transition;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[29].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "menu", "");
    			attr_dev(div, "id", /*menuId*/ ctx[3]);
    			attr_dev(div, "style", /*style*/ ctx[7]);
    			attr_dev(div, "align", /*align*/ ctx[1]);
    			attr_dev(div, "class", "svelte-1d0aqiv");
    			add_location(div, file$m, 126, 2, 2876);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[30](div);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div,
    				"mouseover",
    				function () {
    					if (is_function(/*menumouseover*/ ctx[5])) /*menumouseover*/ ctx[5].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 268435456) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[28], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[28], dirty, null));
    				}
    			}

    			if (!current || dirty & /*menuId*/ 8) {
    				attr_dev(div, "id", /*menuId*/ ctx[3]);
    			}

    			if (!current || dirty & /*style*/ 128) {
    				attr_dev(div, "style", /*style*/ ctx[7]);
    			}

    			if (!current || dirty & /*align*/ 2) {
    				attr_dev(div, "align", /*align*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 75 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 75 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[30](null);
    			if (detaching && div_transition) div_transition.end();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(126:0) {#if showMenu}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let div;
    	let t;
    	let if_block_anchor;
    	let current;
    	let dispose;
    	let if_block = /*showMenu*/ ctx[0] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(div, "type", "overlay");
    			attr_dev(div, "clear", "");
    			attr_dev(div, "open", /*showMenu*/ ctx[0]);
    			add_location(div, file$m, 124, 0, 2762);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					div,
    					"click",
    					function () {
    						if (is_function(/*overlayClick*/ ctx[6])) /*overlayClick*/ ctx[6].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					div,
    					"mouseover",
    					function () {
    						if (is_function(/*debouncedHide*/ ctx[2])) /*debouncedHide*/ ctx[2].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (!current || dirty & /*showMenu*/ 1) {
    				attr_dev(div, "open", /*showMenu*/ ctx[0]);
    			}

    			if (/*showMenu*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showMenu*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	var changeIndex,
    		checkTrigger,
    		debouncedHide,
    		dispatch,
    		hasfocus,
    		hide,
    		highlightedIndex,
    		menuId,
    		menuItemClick,
    		menuRef,
    		menumouseover,
    		overlayClick,
    		style;

    	dispatch = createEventDispatcher();
    	var { disabled = false } = $$props;
    	var { id = uuid() } = $$props;
    	var { items = [] } = $$props;
    	var { width = "200px" } = $$props;
    	var { top = void 0 } = $$props;
    	var { selectedIndex = -1 } = $$props;
    	var { size = void 0 } = $$props;
    	var { value = "" } = $$props;
    	var { blankSlate = "" } = $$props;
    	var { labelKey = "label" } = $$props;
    	var { idKey = "id" } = $$props;
    	var { showMenu = false } = $$props;
    	var { align = "left" } = $$props;
    	var { trigger = void 0 } = $$props;
    	var { matchTrigger = true } = $$props;
    	style = void 0;
    	menuRef = void 0;
    	hasfocus = false;
    	highlightedIndex = -1;

    	changeIndex = function (direction) {
    		var index;
    		index = highlightedIndex + direction;

    		if (index < 0) {
    			index = items.length - 1;
    		} else if (index >= items.length) {
    			index = 0;
    		}

    		return highlightedIndex = index;
    	};

    	hide = function () {
    		return $$invalidate(0, showMenu = false);
    	};

    	debouncedHide = hide.debounce(1500);
    	menuId = uuid();

    	checkTrigger = function (i) {
    		var topPosition;

    		//console.log trigger
    		//console.log "checktrigger #{align}"
    		if (i != null) {
    			//console.log i
    			//console.log trigger
    			//console.log i.offsetLeft
    			//console.log i.offsetTop
    			if (matchTrigger) {
    				return $$invalidate(7, style = `width: ${width}; top: ${i.offsetTop + i.offsetHeight}px; left: ${i.offsetLeft + 4}px;`);
    			} else {
    				//console.log "no match trigger"
    				if (align === "left") {
    					//console.log trigger.offsetParent
    					//console.log trigger.offsetParent.clientHeight
    					return $$invalidate(7, style = `width: ${width};top: ${trigger.offsetParent.clientHeight + 4}px;`);
    				} else {
    					//console.log "align-right"
    					//triggerContainerWidth = trigger.offsetParent.clientWidth
    					//triggerCoords = trigger.getBoundingClientRect()
    					//right = triggerContainerWidth  - (triggerCoords.width)
    					//console.log style
    					topPosition = top || i.offsetTop + i.offsetHeight;

    					return $$invalidate(7, style = `width: ${width};top: ${topPosition}px; right: ${i.offsetLeft + i.offsetWidth}px`);
    				}
    			}
    		}
    	};

    	menuItemClick = function (item, index) {
    		$$invalidate(0, showMenu = false);
    		return dispatch("click", item);
    	};

    	overlayClick = function () {
    		return $$invalidate(0, showMenu = false);
    	};

    	menumouseover = function (e) {
    		return debouncedHide.cancel();
    	};

    	const writable_props = [
    		"disabled",
    		"id",
    		"items",
    		"width",
    		"top",
    		"selectedIndex",
    		"size",
    		"value",
    		"blankSlate",
    		"labelKey",
    		"idKey",
    		"showMenu",
    		"align",
    		"trigger",
    		"matchTrigger"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComposedMenuFavorites> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComposedMenuFavorites", $$slots, ['default']);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(4, menuRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("disabled" in $$props) $$invalidate(8, disabled = $$props.disabled);
    		if ("id" in $$props) $$invalidate(9, id = $$props.id);
    		if ("items" in $$props) $$invalidate(10, items = $$props.items);
    		if ("width" in $$props) $$invalidate(11, width = $$props.width);
    		if ("top" in $$props) $$invalidate(12, top = $$props.top);
    		if ("selectedIndex" in $$props) $$invalidate(13, selectedIndex = $$props.selectedIndex);
    		if ("size" in $$props) $$invalidate(14, size = $$props.size);
    		if ("value" in $$props) $$invalidate(15, value = $$props.value);
    		if ("blankSlate" in $$props) $$invalidate(16, blankSlate = $$props.blankSlate);
    		if ("labelKey" in $$props) $$invalidate(17, labelKey = $$props.labelKey);
    		if ("idKey" in $$props) $$invalidate(18, idKey = $$props.idKey);
    		if ("showMenu" in $$props) $$invalidate(0, showMenu = $$props.showMenu);
    		if ("align" in $$props) $$invalidate(1, align = $$props.align);
    		if ("trigger" in $$props) $$invalidate(19, trigger = $$props.trigger);
    		if ("matchTrigger" in $$props) $$invalidate(20, matchTrigger = $$props.matchTrigger);
    		if ("$$scope" in $$props) $$invalidate(28, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		changeIndex,
    		checkTrigger,
    		debouncedHide,
    		dispatch,
    		hasfocus,
    		hide,
    		highlightedIndex,
    		menuId,
    		menuItemClick,
    		menuRef,
    		menumouseover,
    		overlayClick,
    		style,
    		createEventDispatcher,
    		slide,
    		disabled,
    		id,
    		items,
    		width,
    		top,
    		selectedIndex,
    		size,
    		value,
    		blankSlate,
    		labelKey,
    		idKey,
    		showMenu,
    		align,
    		trigger,
    		matchTrigger
    	});

    	$$self.$inject_state = $$props => {
    		if ("changeIndex" in $$props) changeIndex = $$props.changeIndex;
    		if ("checkTrigger" in $$props) $$invalidate(22, checkTrigger = $$props.checkTrigger);
    		if ("debouncedHide" in $$props) $$invalidate(2, debouncedHide = $$props.debouncedHide);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("hasfocus" in $$props) hasfocus = $$props.hasfocus;
    		if ("hide" in $$props) hide = $$props.hide;
    		if ("highlightedIndex" in $$props) highlightedIndex = $$props.highlightedIndex;
    		if ("menuId" in $$props) $$invalidate(3, menuId = $$props.menuId);
    		if ("menuItemClick" in $$props) menuItemClick = $$props.menuItemClick;
    		if ("menuRef" in $$props) $$invalidate(4, menuRef = $$props.menuRef);
    		if ("menumouseover" in $$props) $$invalidate(5, menumouseover = $$props.menumouseover);
    		if ("overlayClick" in $$props) $$invalidate(6, overlayClick = $$props.overlayClick);
    		if ("style" in $$props) $$invalidate(7, style = $$props.style);
    		if ("disabled" in $$props) $$invalidate(8, disabled = $$props.disabled);
    		if ("id" in $$props) $$invalidate(9, id = $$props.id);
    		if ("items" in $$props) $$invalidate(10, items = $$props.items);
    		if ("width" in $$props) $$invalidate(11, width = $$props.width);
    		if ("top" in $$props) $$invalidate(12, top = $$props.top);
    		if ("selectedIndex" in $$props) $$invalidate(13, selectedIndex = $$props.selectedIndex);
    		if ("size" in $$props) $$invalidate(14, size = $$props.size);
    		if ("value" in $$props) $$invalidate(15, value = $$props.value);
    		if ("blankSlate" in $$props) $$invalidate(16, blankSlate = $$props.blankSlate);
    		if ("labelKey" in $$props) $$invalidate(17, labelKey = $$props.labelKey);
    		if ("idKey" in $$props) $$invalidate(18, idKey = $$props.idKey);
    		if ("showMenu" in $$props) $$invalidate(0, showMenu = $$props.showMenu);
    		if ("align" in $$props) $$invalidate(1, align = $$props.align);
    		if ("trigger" in $$props) $$invalidate(19, trigger = $$props.trigger);
    		if ("matchTrigger" in $$props) $$invalidate(20, matchTrigger = $$props.matchTrigger);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*checkTrigger, trigger*/ 4718592) {
    			//console.log "offset parent"
    			//console.log i.offsetParent
    			//console.log style
    			 checkTrigger(trigger);
    		}
    	};

    	return [
    		showMenu,
    		align,
    		debouncedHide,
    		menuId,
    		menuRef,
    		menumouseover,
    		overlayClick,
    		style,
    		disabled,
    		id,
    		items,
    		width,
    		top,
    		selectedIndex,
    		size,
    		value,
    		blankSlate,
    		labelKey,
    		idKey,
    		trigger,
    		matchTrigger,
    		changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		hide,
    		highlightedIndex,
    		menuItemClick,
    		$$scope,
    		$$slots,
    		div_binding
    	];
    }

    class ComposedMenuFavorites extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
    			disabled: 8,
    			id: 9,
    			items: 10,
    			width: 11,
    			top: 12,
    			selectedIndex: 13,
    			size: 14,
    			value: 15,
    			blankSlate: 16,
    			labelKey: 17,
    			idKey: 18,
    			showMenu: 0,
    			align: 1,
    			trigger: 19,
    			matchTrigger: 20
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComposedMenuFavorites",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get disabled() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get top() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedIndex() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedIndex(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blankSlate() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blankSlate(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelKey() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelKey(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get idKey() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set idKey(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showMenu() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showMenu(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trigger() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trigger(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get matchTrigger() {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set matchTrigger(value) {
    		throw new Error("<ComposedMenuFavorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var HumanEffort;

    HumanEffort = (function() {
      class HumanEffort {
        day() {
          return this.hours_per_day * 60;
        }

        week() {
          return this.days_per_week * this.day();
        }

        month() {
          return this.weeks_per_month * this.week();
        }

        year() {
          return this.weeks_per_year * this.week();
        }

        parseMinutes(string) {
          var i, j, mLen, nLen, numbers, options, regex, sum, unit;
          options = {
            minutes: 1,
            hours: 60,
            days: this.day(),
            weeks: this.week(),
            months: this.month(),
            years: this.year()
          };
          // error trap items not passed in by an input field
          if (Object.isNumber(string)) {
            string = `${string}`;
          }
          if (string != null) {
            for (unit in this.units) {
              i = 0;
              mLen = this.units[unit].patterns.length;
              while (i < mLen) {
                regex = new RegExp("((?:\\d+\\.\\d+)|\\d+)\\s?(" + this.units[unit].patterns[i] + "s?(?=\\s|\\d|\\b))", "gi");
                string = string.replace(regex, function(str, p1, p2) {
                  return " " + (p1 * options[unit]).toString() + " ";
                });
                i++;
              }
            }
            sum = 0;
            // replaces non-word chars (excluding '.') with whitespace
            // trim L/R whitespace, replace known join words with ''
            numbers = string.replace(/(?!\.)\W+/g, " ").replace(/^\s+|\s+$|(?:and|plus|with)\s?/g, "").split(" ");
            j = 0;
            nLen = numbers.length;
            while (j < nLen) {
              if (numbers[j] && isFinite(numbers[j])) {
                sum += parseFloat(numbers[j]);
              } else if (numbers[j] == null) ;
              j++;
            }
            return sum;
          } else {
            return 0;
          }
        }

        parseHours(string, toMinutes) {
          var i, j, mLen, nLen, numbers, options, regex, sum, unit;
          options = {
            minutes: 1 / 60,
            hours: 1,
            days: this.day() / 60,
            weeks: this.week() / 60,
            months: this.month() / 60,
            years: this.year() / 60
          };
          // error trap items not passed in by an input field
          if (Object.isNumber(string)) {
            string = `${string}`;
          }
          if (string != null) {
            for (unit in this.units) {
              i = 0;
              mLen = this.units[unit].patterns.length;
              while (i < mLen) {
                regex = new RegExp("((?:\\d+\\.\\d+)|\\d+)\\s?(" + this.units[unit].patterns[i] + "s?(?=\\s|\\d|\\b))", "gi");
                string = string.replace(regex, function(str, p1, p2) {
                  return " " + (p1 * options[unit]).toString() + " ";
                });
                i++;
              }
            }
            sum = 0;
            // replaces non-word chars (excluding '.') with whitespace
            // trim L/R whitespace, replace known join words with ''
            numbers = string.replace(/(?!\.)\W+/g, " ").replace(/^\s+|\s+$|(?:and|plus|with)\s?/g, "").split(" ");
            j = 0;
            nLen = numbers.length;
            while (j < nLen) {
              if (numbers[j] && isFinite(numbers[j])) {
                sum += parseFloat(numbers[j]);
              } else if (numbers[j] == null) ;
              j++;
            }
            if (toMinutes != null) {
              return sum * 60;
            } else {
              return sum;
            }
          } else {
            return 0;
          }
        }

        // ## Humanize

        // Humanize returns effort in person days and hours only.

        // start_at_hours sets the output to use hours instead of days
        humanizeMinutes(minutes, start_at_hours) {
          var days, hours, humanized_effort, show_minutes, unit;
          humanized_effort = "";
          start_at_hours = start_at_hours || false;
          if (minutes != null) {
            minutes = parseInt(minutes);
            if (!isNaN(minutes)) {
              if (!start_at_hours) {
                if (minutes >= this.day()) {
                  unit = "d";
                  days = Math.floor(minutes / this.day());
                  minutes = minutes - (days * this.day());
                  humanized_effort = humanized_effort + `${days}${unit} `;
                }
              }
              // hours
              if (minutes >= 60) {
                unit = "h";
                hours = Math.floor(minutes / 60);
                minutes = minutes - (hours * 60);
                humanized_effort = humanized_effort + `${hours}${unit} `;
              }
              // minutes
              if (minutes >= 0) {
                unit = "m";
                show_minutes = true;
                if ((minutes === 0) && ((days > 0) || (hours > 0))) {
                  show_minutes = false;
                }
                if (show_minutes) {
                  humanized_effort = humanized_effort + `${minutes}${unit}`;
                }
              }
              return humanized_effort;
            } else {
              return "0m";
            }
          } else {
            return "0m";
          }
        }

        humanizeHours(hours) {
          var hoursFromMinutes, hoursText, humanized_effort, minuteText, minutes;
          humanized_effort = "";
          if (hours != null) {
            if (!isNaN(hours)) {
              // days
              minutes = parseInt((hours - Math.floor(hours)) * 60);
              hoursFromMinutes = Math.floor(minutes / 60);
              minutes = minutes - (hoursFromMinutes * 60);
              hours = Math.floor(hours) + hoursFromMinutes;
              //days = hours / @days()

              //unit = "h"
              if (minutes > 0) {
                minuteText = `${minutes}m`;
              } else {
                minuteText = "";
              }
              if (hours > 0) {
                hoursText = `${hours}h`;
              } else {
                if (minutes === 0) {
                  hoursText = "0h";
                } else {
                  hoursText = "";
                }
              }
              //hours = hours - (hours * 60)
              humanized_effort = `${hoursText}${minuteText} `;
              return humanized_effort;
            } else {
              return "0h";
            }
          } else {
            return "0h";
          }
        }

      }
      HumanEffort.prototype.hours_per_day = 8;

      HumanEffort.prototype.days_per_week = 5;

      HumanEffort.prototype.weeks_per_month = 4;

      HumanEffort.prototype.weeks_per_year = 52;

      HumanEffort.prototype.units = {
        minutes: {
          patterns: ["minute", "min", "m(?!s)"],
          formats: {
            chrono: ":",
            micro: "m",
            short: "min",
            long: "minute"
          }
        },
        hours: {
          patterns: ["hour", "hr", "h", ":"],
          formats: {
            chrono: ":",
            micro: "h",
            short: "hr",
            long: "hour"
          }
        },
        days: {
          patterns: ["day", "dy", "d"],
          formats: {
            chrono: ":",
            micro: "d",
            short: "day",
            long: "day"
          }
        },
        weeks: {
          patterns: ["week", "wk", "w"],
          formats: {
            chrono: ":",
            micro: "w",
            short: "wk",
            long: "week"
          }
        },
        months: {
          patterns: ["month", "mon", "mo", "mth"],
          formats: {
            chrono: ":",
            micro: "mo",
            short: "mth",
            long: "month"
          }
        },
        years: {
          patterns: ["year", "yr", "y"],
          formats: {
            chrono: ":",
            micro: "y",
            short: "yr",
            long: "year"
          }
        }
      };

      return HumanEffort;

    }).call(commonjsGlobal);

    var human_effort = new HumanEffort;

    /* src\svelte\components\Format\EffortFormat.svelte generated by Svelte v3.22.2 */

    const { console: console_1$8 } = globals;

    function create_fragment$p(ctx) {
    	let t_value = /*translate*/ ctx[1](/*value*/ ctx[0]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*translate, value*/ 3 && t_value !== (t_value = /*translate*/ ctx[1](/*value*/ ctx[0]) + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	var change, debouncedChange, effortInput, translate;
    	var { value = void 0 } = $$props;
    	var { units = "minutes" } = $$props; // input unit
    	var { dayHours = 8 } = $$props; // hours per day
    	var { aggregate = true } = $$props; // return as raw or not
    	effortInput = human_effort.humanizeHours(value || 0);

    	change = function (e) {
    		var event;

    		event = {
    			inputValue: value,
    			inHours: human_effort.parseHours(value || ""),
    			inMinutes: human_effort.parseHours(value || "", true)
    		};

    		console.log(event);
    		return dispatch("change", event);
    	};

    	debouncedChange = change.debounce(500);

    	translate = function (val) {
    		var hours;
    		hours = human_effort.parseHours(value || "");
    		console.log(`Hours: ${hours} Units: ${units}`);

    		switch (units) {
    			case "hours":
    				hours = human_effort.parseHours(value || "");
    				break;
    			default:
    				hours = human_effort.parseHours(value / 60 || "");
    		} // "minutes"

    		if (aggregate) {
    			if (hours < 1) {
    				return `${(hours * 60).format()}m`;
    			} else if (hours > dayHours) {
    				return `${(hours / dayHours).format()}d`;
    			} else {
    				return `${hours.format()}h`;
    			}
    		} else {
    			return hours;
    		}
    	};

    	const writable_props = ["value", "units", "dayHours", "aggregate"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<EffortFormat> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("EffortFormat", $$slots, []);

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("units" in $$props) $$invalidate(2, units = $$props.units);
    		if ("dayHours" in $$props) $$invalidate(3, dayHours = $$props.dayHours);
    		if ("aggregate" in $$props) $$invalidate(4, aggregate = $$props.aggregate);
    	};

    	$$self.$capture_state = () => ({
    		change,
    		debouncedChange,
    		effortInput,
    		translate,
    		HumanEffort: human_effort,
    		value,
    		units,
    		dayHours,
    		aggregate
    	});

    	$$self.$inject_state = $$props => {
    		if ("change" in $$props) change = $$props.change;
    		if ("debouncedChange" in $$props) debouncedChange = $$props.debouncedChange;
    		if ("effortInput" in $$props) effortInput = $$props.effortInput;
    		if ("translate" in $$props) $$invalidate(1, translate = $$props.translate);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("units" in $$props) $$invalidate(2, units = $$props.units);
    		if ("dayHours" in $$props) $$invalidate(3, dayHours = $$props.dayHours);
    		if ("aggregate" in $$props) $$invalidate(4, aggregate = $$props.aggregate);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [value, translate, units, dayHours, aggregate];
    }

    class EffortFormat extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
    			value: 0,
    			units: 2,
    			dayHours: 3,
    			aggregate: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EffortFormat",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get value() {
    		throw new Error("<EffortFormat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<EffortFormat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<EffortFormat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<EffortFormat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dayHours() {
    		throw new Error("<EffortFormat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dayHours(value) {
    		throw new Error("<EffortFormat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get aggregate() {
    		throw new Error("<EffortFormat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set aggregate(value) {
    		throw new Error("<EffortFormat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Form\TranslatedInput\TranslatedInput.svelte generated by Svelte v3.22.2 */
    const file$n = "src\\svelte\\components\\Form\\TranslatedInput\\TranslatedInput.svelte";

    function create_fragment$q(ctx) {
    	let div;
    	let input;
    	let input_invalid_value;
    	let t0;
    	let label;
    	let t1;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t0 = space();
    			label = element("label");
    			t1 = text(/*translatedValue*/ ctx[5]);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "style", /*style*/ ctx[4]);
    			attr_dev(input, "maxlength", /*maxlength*/ ctx[1]);
    			attr_dev(input, "invalid", input_invalid_value = !/*valid*/ ctx[6]);
    			add_location(input, file$n, 72, 2, 1581);
    			attr_dev(label, "type", "translated-input");
    			attr_dev(label, "state", /*state*/ ctx[7]);
    			attr_dev(label, "class", "svelte-1draoay");
    			add_location(label, file$n, 73, 2, 1706);
    			add_location(div, file$n, 71, 0, 1573);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*value*/ ctx[0]);
    			append_dev(div, t0);
    			append_dev(div, label);
    			append_dev(label, t1);
    			/*label_binding*/ ctx[14](label);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(input, "input", /*input_input_handler*/ ctx[13]),
    				listen_dev(
    					input,
    					"keyup",
    					function () {
    						if (is_function(/*change*/ ctx[2])) /*change*/ ctx[2].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					input,
    					"change",
    					function () {
    						if (is_function(/*change*/ ctx[2])) /*change*/ ctx[2].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(input, "keyup", /*keyup_handler*/ ctx[12], false, false, false)
    			];
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (dirty & /*style*/ 16) {
    				attr_dev(input, "style", /*style*/ ctx[4]);
    			}

    			if (dirty & /*maxlength*/ 2) {
    				attr_dev(input, "maxlength", /*maxlength*/ ctx[1]);
    			}

    			if (dirty & /*valid*/ 64 && input_invalid_value !== (input_invalid_value = !/*valid*/ ctx[6])) {
    				attr_dev(input, "invalid", input_invalid_value);
    			}

    			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}

    			if (dirty & /*translatedValue*/ 32) set_data_dev(t1, /*translatedValue*/ ctx[5]);

    			if (dirty & /*state*/ 128) {
    				attr_dev(label, "state", /*state*/ ctx[7]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*label_binding*/ ctx[14](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	var change, dispatch, labelRef, style;
    	var { value = "" } = $$props;
    	var { maxlength = 50 } = $$props;

    	var { translateFn = function (val) {
    		return (val || "empty").toUpperCase();
    	} } = $$props;

    	var { validateFn = function (val) {
    		return true;
    	} } = $$props;

    	var { stateFn = function (val) {
    		return "ok";
    	} } = $$props;

    	style = void 0;
    	dispatch = createEventDispatcher();
    	labelRef = null;

    	change = function (e) {
    		return dispatch("change", { value, translatedValue });
    	};

    	afterUpdate(function () {
    		if (labelRef != null) {
    			return $$invalidate(4, style = `padding-right: ${16 + labelRef.clientWidth}px`);
    		}
    	});

    	const writable_props = ["value", "maxlength", "translateFn", "validateFn", "stateFn"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TranslatedInput> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TranslatedInput", $$slots, []);

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function input_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	function label_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(3, labelRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("maxlength" in $$props) $$invalidate(1, maxlength = $$props.maxlength);
    		if ("translateFn" in $$props) $$invalidate(8, translateFn = $$props.translateFn);
    		if ("validateFn" in $$props) $$invalidate(9, validateFn = $$props.validateFn);
    		if ("stateFn" in $$props) $$invalidate(10, stateFn = $$props.stateFn);
    	};

    	$$self.$capture_state = () => ({
    		change,
    		dispatch,
    		labelRef,
    		style,
    		onMount,
    		afterUpdate,
    		createEventDispatcher,
    		value,
    		maxlength,
    		translateFn,
    		validateFn,
    		stateFn,
    		translatedValue,
    		valid,
    		state
    	});

    	$$self.$inject_state = $$props => {
    		if ("change" in $$props) $$invalidate(2, change = $$props.change);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("labelRef" in $$props) $$invalidate(3, labelRef = $$props.labelRef);
    		if ("style" in $$props) $$invalidate(4, style = $$props.style);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("maxlength" in $$props) $$invalidate(1, maxlength = $$props.maxlength);
    		if ("translateFn" in $$props) $$invalidate(8, translateFn = $$props.translateFn);
    		if ("validateFn" in $$props) $$invalidate(9, validateFn = $$props.validateFn);
    		if ("stateFn" in $$props) $$invalidate(10, stateFn = $$props.stateFn);
    		if ("translatedValue" in $$props) $$invalidate(5, translatedValue = $$props.translatedValue);
    		if ("valid" in $$props) $$invalidate(6, valid = $$props.valid);
    		if ("state" in $$props) $$invalidate(7, state = $$props.state);
    	};

    	let translatedValue;
    	let valid;
    	let state;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*translateFn, value*/ 257) {
    			 $$invalidate(5, translatedValue = translateFn(value));
    		}

    		if ($$self.$$.dirty & /*validateFn, value*/ 513) {
    			 $$invalidate(6, valid = validateFn(value));
    		}

    		if ($$self.$$.dirty & /*stateFn, value*/ 1025) {
    			 $$invalidate(7, state = stateFn(value));
    		}
    	};

    	return [
    		value,
    		maxlength,
    		change,
    		labelRef,
    		style,
    		translatedValue,
    		valid,
    		state,
    		translateFn,
    		validateFn,
    		stateFn,
    		dispatch,
    		keyup_handler,
    		input_input_handler,
    		label_binding
    	];
    }

    class TranslatedInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
    			value: 0,
    			maxlength: 1,
    			translateFn: 8,
    			validateFn: 9,
    			stateFn: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TranslatedInput",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get value() {
    		throw new Error("<TranslatedInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<TranslatedInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxlength() {
    		throw new Error("<TranslatedInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxlength(value) {
    		throw new Error("<TranslatedInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get translateFn() {
    		throw new Error("<TranslatedInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set translateFn(value) {
    		throw new Error("<TranslatedInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get validateFn() {
    		throw new Error("<TranslatedInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validateFn(value) {
    		throw new Error("<TranslatedInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stateFn() {
    		throw new Error("<TranslatedInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stateFn(value) {
    		throw new Error("<TranslatedInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Form\TranslatedInput\DurationInput.svelte generated by Svelte v3.22.2 */

    const { console: console_1$9 } = globals;

    function create_fragment$r(ctx) {
    	let updating_value;
    	let current;

    	function translatedinput_value_binding(value) {
    		/*translatedinput_value_binding*/ ctx[10].call(null, value);
    	}

    	let translatedinput_props = {
    		maxlength: "7",
    		translateFn: /*translateFn*/ ctx[4],
    		validateFn: /*validateFn*/ ctx[5],
    		stateFn: /*stateFn*/ ctx[3],
    		style: /*style*/ ctx[1]
    	};

    	if (/*value*/ ctx[0] !== void 0) {
    		translatedinput_props.value = /*value*/ ctx[0];
    	}

    	const translatedinput = new TranslatedInput({
    			props: translatedinput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(translatedinput, "value", translatedinput_value_binding));

    	translatedinput.$on("change", function () {
    		if (is_function(/*change*/ ctx[2])) /*change*/ ctx[2].apply(this, arguments);
    	});

    	translatedinput.$on("keyup", /*keyup_handler*/ ctx[11]);
    	translatedinput.$on("blur", /*blur_handler*/ ctx[12]);
    	translatedinput.$on("input", /*input_handler*/ ctx[13]);
    	translatedinput.$on("click", /*click_handler*/ ctx[14]);

    	const block = {
    		c: function create() {
    			create_component(translatedinput.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(translatedinput, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const translatedinput_changes = {};
    			if (dirty & /*translateFn*/ 16) translatedinput_changes.translateFn = /*translateFn*/ ctx[4];
    			if (dirty & /*validateFn*/ 32) translatedinput_changes.validateFn = /*validateFn*/ ctx[5];
    			if (dirty & /*stateFn*/ 8) translatedinput_changes.stateFn = /*stateFn*/ ctx[3];
    			if (dirty & /*style*/ 2) translatedinput_changes.style = /*style*/ ctx[1];

    			if (!updating_value && dirty & /*value*/ 1) {
    				updating_value = true;
    				translatedinput_changes.value = /*value*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			translatedinput.$set(translatedinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(translatedinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(translatedinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(translatedinput, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	var change,
    		debouncedChange,
    		dispatch,
    		effortInput,
    		stateFn,
    		translateFn,
    		validateFn;

    	dispatch = createEventDispatcher();
    	var { value = 0 } = $$props;
    	var { presets = ["8h", "4h", "2h"] } = $$props;
    	var { style = void 0 } = $$props;
    	effortInput = human_effort.humanizeHours(value || 0);

    	change = function (e) {
    		var event;

    		event = {
    			inputValue: value,
    			inHours: human_effort.parseHours(value || ""),
    			inMinutes: human_effort.parseHours(value || "", true)
    		};

    		console.log(event);
    		return dispatch("change", event);
    	};

    	debouncedChange = change.debounce(500);

    	translateFn = function (val) {
    		return `${human_effort.parseHours(value || "").format(2)}h`;
    	};

    	validateFn = function (val) {
    		if (val.length === 0) {
    			return false;
    		} else {
    			return true;
    		}
    	};

    	stateFn = function (val) {
    		if (val.length === 0) {
    			return "empty";
    		} else {
    			return "ok";
    		}
    	};

    	const writable_props = ["value", "presets", "style"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$9.warn(`<DurationInput> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DurationInput", $$slots, []);

    	function translatedinput_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(0, value);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function blur_handler(event) {
    		bubble($$self, event);
    	}

    	function input_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("presets" in $$props) $$invalidate(6, presets = $$props.presets);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({
    		change,
    		debouncedChange,
    		dispatch,
    		effortInput,
    		stateFn,
    		translateFn,
    		validateFn,
    		createEventDispatcher,
    		TranslatedInput,
    		HumanEffort: human_effort,
    		value,
    		presets,
    		style
    	});

    	$$self.$inject_state = $$props => {
    		if ("change" in $$props) $$invalidate(2, change = $$props.change);
    		if ("debouncedChange" in $$props) debouncedChange = $$props.debouncedChange;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("effortInput" in $$props) effortInput = $$props.effortInput;
    		if ("stateFn" in $$props) $$invalidate(3, stateFn = $$props.stateFn);
    		if ("translateFn" in $$props) $$invalidate(4, translateFn = $$props.translateFn);
    		if ("validateFn" in $$props) $$invalidate(5, validateFn = $$props.validateFn);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("presets" in $$props) $$invalidate(6, presets = $$props.presets);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		style,
    		change,
    		stateFn,
    		translateFn,
    		validateFn,
    		presets,
    		debouncedChange,
    		dispatch,
    		effortInput,
    		translatedinput_value_binding,
    		keyup_handler,
    		blur_handler,
    		input_handler,
    		click_handler
    	];
    }

    class DurationInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, { value: 0, presets: 6, style: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DurationInput",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get value() {
    		throw new Error("<DurationInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<DurationInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get presets() {
    		throw new Error("<DurationInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set presets(value) {
    		throw new Error("<DurationInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<DurationInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<DurationInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Popovers\Time.svelte generated by Svelte v3.22.2 */

    const { console: console_1$a } = globals;
    const file$o = "src\\svelte\\pages\\_Common\\Popovers\\Time.svelte";

    // (108:6) {:else}
    function create_else_block_1$2(ctx) {
    	let a;
    	let em;
    	let t;
    	let updating_value;
    	let current;
    	let if_block = !/*isListItem*/ ctx[1] && create_if_block_3$1(ctx);

    	function effortformat_value_binding(value) {
    		/*effortformat_value_binding*/ ctx[17].call(null, value);
    	}

    	let effortformat_props = {};

    	if (/*item*/ ctx[0].estimate !== void 0) {
    		effortformat_props.value = /*item*/ ctx[0].estimate;
    	}

    	const effortformat = new EffortFormat({
    			props: effortformat_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(effortformat, "value", effortformat_value_binding));

    	const block = {
    		c: function create() {
    			a = element("a");
    			em = element("em");
    			if (if_block) if_block.c();
    			t = space();
    			create_component(effortformat.$$.fragment);
    			add_location(em, file$o, 108, 46, 2582);
    			attr_dev(a, "duedate", "");
    			set_style(a, "color", "var(--gray)");
    			add_location(a, file$o, 108, 8, 2544);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, em);
    			if (if_block) if_block.m(em, null);
    			append_dev(em, t);
    			mount_component(effortformat, em, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*isListItem*/ ctx[1]) {
    				if (if_block) ; else {
    					if_block = create_if_block_3$1(ctx);
    					if_block.c();
    					if_block.m(em, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const effortformat_changes = {};

    			if (!updating_value && dirty & /*item*/ 1) {
    				updating_value = true;
    				effortformat_changes.value = /*item*/ ctx[0].estimate;
    				add_flush_callback(() => updating_value = false);
    			}

    			effortformat.$set(effortformat_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(effortformat.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(effortformat.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block) if_block.d();
    			destroy_component(effortformat);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(108:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (98:6) {#if (item.estimate || 0) == 0}
    function create_if_block_1$2(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*isListItem*/ ctx[1]) return create_if_block_2$1;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(98:6) {#if (item.estimate || 0) == 0}",
    		ctx
    	});

    	return block;
    }

    // (110:10) {#if !isListItem}
    function create_if_block_3$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Estimate:";
    			attr_dev(span, "duedate", "");
    			add_location(span, file$o, 110, 12, 2627);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(110:10) {#if !isListItem}",
    		ctx
    	});

    	return block;
    }

    // (104:8) {:else}
    function create_else_block$4(ctx) {
    	let a;
    	let em;

    	const block = {
    		c: function create() {
    			a = element("a");
    			em = element("em");
    			em.textContent = "No estimate";
    			add_location(em, file$o, 104, 61, 2482);
    			attr_dev(a, "duedate", "");
    			attr_dev(a, "islistitem", /*isListItem*/ ctx[1]);
    			set_style(a, "color", "var(--gray)");
    			add_location(a, file$o, 104, 10, 2431);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, em);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*isListItem*/ 2) {
    				attr_dev(a, "islistitem", /*isListItem*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(104:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (99:8) {#if isListItem}
    function create_if_block_2$1(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$o, 100, 12, 2128);
    			attr_dev(path1, "d", "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z");
    			attr_dev(path1, "class", "fill");
    			add_location(path1, file$o, 101, 12, 2180);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$o, 99, 10, 2032);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(99:8) {#if isListItem}",
    		ctx
    	});

    	return block;
    }

    // (143:6) {#if showTimeForm}
    function create_if_block$a(ctx) {
    	let hr;
    	let t0;
    	let li0;
    	let t2;
    	let li1;

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			li0 = element("li");
    			li0.textContent = "Quick Time Entry";
    			t2 = space();
    			li1 = element("li");
    			attr_dev(hr, "class", "svelte-hsffqc");
    			add_location(hr, file$o, 143, 8, 3927);
    			attr_dev(li0, "label", "");
    			attr_dev(li0, "class", "svelte-hsffqc");
    			add_location(li0, file$o, 144, 8, 3941);
    			attr_dev(li1, "class", "svelte-hsffqc");
    			add_location(li1, file$o, 145, 8, 3981);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, li0, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, li1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(li0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(li1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(143:6) {#if showTimeForm}",
    		ctx
    	});

    	return block;
    }

    // (120:2) <Menu bind:showMenu={show} bind:trigger={triggerRef} matchTrigger={false} align="right" top="24px">
    function create_default_slot$6(ctx) {
    	let ul;
    	let li0;
    	let t1;
    	let li1;
    	let updating_value;
    	let t2;
    	let li2;
    	let div4;
    	let div0;
    	let t3;
    	let div1;
    	let button0;
    	let svg0;
    	let path0;
    	let path1;
    	let t4;
    	let div2;
    	let button1;
    	let svg1;
    	let path2;
    	let path3;
    	let t5;
    	let div3;
    	let t6;
    	let current;
    	let dispose;

    	function durationinput_value_binding(value) {
    		/*durationinput_value_binding*/ ctx[19].call(null, value);
    	}

    	let durationinput_props = { autofocus: true };

    	if (/*effort*/ ctx[5] !== void 0) {
    		durationinput_props.value = /*effort*/ ctx[5];
    	}

    	const durationinput = new DurationInput({
    			props: durationinput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(durationinput, "value", durationinput_value_binding));

    	durationinput.$on("change", function () {
    		if (is_function(/*updateEffortMinutes*/ ctx[10])) /*updateEffortMinutes*/ ctx[10].apply(this, arguments);
    	});

    	durationinput.$on("keyup", function () {
    		if (is_function(/*durationKeyup*/ ctx[4])) /*durationKeyup*/ ctx[4].apply(this, arguments);
    	});

    	let if_block = /*showTimeForm*/ ctx[2] && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li0 = element("li");
    			li0.textContent = "Estimate";
    			t1 = space();
    			li1 = element("li");
    			create_component(durationinput.$$.fragment);
    			t2 = space();
    			li2 = element("li");
    			div4 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div1 = element("div");
    			button0 = element("button");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t4 = space();
    			div2 = element("div");
    			button1 = element("button");
    			svg1 = svg_element("svg");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			t5 = space();
    			div3 = element("div");
    			t6 = space();
    			if (if_block) if_block.c();
    			attr_dev(li0, "label", "");
    			attr_dev(li0, "class", "svelte-hsffqc");
    			add_location(li0, file$o, 122, 6, 2888);
    			attr_dev(li1, "class", "svelte-hsffqc");
    			add_location(li1, file$o, 123, 6, 2918);
    			attr_dev(div0, "flex", "flex");
    			attr_dev(div0, "class", "svelte-hsffqc");
    			add_location(div0, file$o, 126, 10, 3079);
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$o, 129, 97, 3279);
    			attr_dev(path1, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z");
    			add_location(path1, file$o, 129, 136, 3318);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			add_location(svg0, file$o, 129, 14, 3196);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "svelte-hsffqc");
    			add_location(button0, file$o, 128, 12, 3141);
    			attr_dev(div1, "flex", "initial");
    			attr_dev(div1, "class", "svelte-hsffqc");
    			add_location(div1, file$o, 127, 10, 3108);
    			attr_dev(path2, "fill", "none");
    			attr_dev(path2, "d", "M0 0h24v24H0V0z");
    			add_location(path2, file$o, 134, 97, 3664);
    			attr_dev(path3, "d", "M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z");
    			add_location(path3, file$o, 134, 136, 3703);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			add_location(svg1, file$o, 134, 14, 3581);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "class", "svelte-hsffqc");
    			add_location(button1, file$o, 133, 12, 3528);
    			attr_dev(div2, "flex", "initial");
    			attr_dev(div2, "class", "svelte-hsffqc");
    			add_location(div2, file$o, 132, 10, 3495);
    			attr_dev(div3, "flex", "initial");
    			attr_dev(div3, "class", "svelte-hsffqc");
    			add_location(div3, file$o, 137, 10, 3828);
    			attr_dev(div4, "layout", "row");
    			attr_dev(div4, "class", "svelte-hsffqc");
    			add_location(div4, file$o, 125, 8, 3050);
    			attr_dev(li2, "class", "svelte-hsffqc");
    			add_location(li2, file$o, 124, 6, 3037);
    			attr_dev(ul, "class", "svelte-hsffqc");
    			add_location(ul, file$o, 121, 4, 2877);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li0);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			mount_component(durationinput, li1, null);
    			append_dev(ul, t2);
    			append_dev(ul, li2);
    			append_dev(li2, div4);
    			append_dev(div4, div0);
    			append_dev(div4, t3);
    			append_dev(div4, div1);
    			append_dev(div1, button0);
    			append_dev(button0, svg0);
    			append_dev(svg0, path0);
    			append_dev(svg0, path1);
    			append_dev(div4, t4);
    			append_dev(div4, div2);
    			append_dev(div2, button1);
    			append_dev(button1, svg1);
    			append_dev(svg1, path2);
    			append_dev(svg1, path3);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			append_dev(ul, t6);
    			if (if_block) if_block.m(ul, null);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					button0,
    					"click",
    					function () {
    						if (is_function(/*cancel*/ ctx[3])) /*cancel*/ ctx[3].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button1,
    					"click",
    					function () {
    						if (is_function(/*save*/ ctx[6])) /*save*/ ctx[6].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const durationinput_changes = {};

    			if (!updating_value && dirty & /*effort*/ 32) {
    				updating_value = true;
    				durationinput_changes.value = /*effort*/ ctx[5];
    				add_flush_callback(() => updating_value = false);
    			}

    			durationinput.$set(durationinput_changes);

    			if (/*showTimeForm*/ ctx[2]) {
    				if (if_block) ; else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					if_block.m(ul, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(durationinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(durationinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_component(durationinput);
    			if (if_block) if_block.d();
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(120:2) <Menu bind:showMenu={show} bind:trigger={triggerRef} matchTrigger={false} align=\\\"right\\\" top=\\\"24px\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let div1;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let updating_showMenu;
    	let updating_trigger;
    	let current;
    	let dispose;
    	const if_block_creators = [create_if_block_1$2, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if ((/*item*/ ctx[0].estimate || 0) == 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function menu_showMenu_binding(value) {
    		/*menu_showMenu_binding*/ ctx[20].call(null, value);
    	}

    	function menu_trigger_binding(value) {
    		/*menu_trigger_binding*/ ctx[21].call(null, value);
    	}

    	let menu_props = {
    		matchTrigger: false,
    		align: "right",
    		top: "24px",
    		$$slots: { default: [create_default_slot$6] },
    		$$scope: { ctx }
    	};

    	if (/*show*/ ctx[7] !== void 0) {
    		menu_props.showMenu = /*show*/ ctx[7];
    	}

    	if (/*triggerRef*/ ctx[9] !== void 0) {
    		menu_props.trigger = /*triggerRef*/ ctx[9];
    	}

    	const menu = new ComposedMenuFavorites({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "showMenu", menu_showMenu_binding));
    	binding_callbacks.push(() => bind(menu, "trigger", menu_trigger_binding));

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t = space();
    			create_component(menu.$$.fragment);
    			add_location(div0, file$o, 96, 2, 1906);
    			add_location(div1, file$o, 94, 0, 1897);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			/*div0_binding*/ ctx[18](div0);
    			append_dev(div1, t);
    			mount_component(menu, div1, null);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div0,
    				"click",
    				function () {
    					if (is_function(/*triggerClick*/ ctx[8])) /*triggerClick*/ ctx[8].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			const menu_changes = {};

    			if (dirty & /*$$scope, showTimeForm, save, cancel, effort, updateEffortMinutes, durationKeyup*/ 4195452) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_showMenu && dirty & /*show*/ 128) {
    				updating_showMenu = true;
    				menu_changes.showMenu = /*show*/ ctx[7];
    				add_flush_callback(() => updating_showMenu = false);
    			}

    			if (!updating_trigger && dirty & /*triggerRef*/ 512) {
    				updating_trigger = true;
    				menu_changes.trigger = /*triggerRef*/ ctx[9];
    				add_flush_callback(() => updating_trigger = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    			/*div0_binding*/ ctx[18](null);
    			destroy_component(menu);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	var add,
    		cancel,
    		dispatch,
    		durationKeyup,
    		effort,
    		newTime,
    		newValue,
    		progressMenuClick,
    		save,
    		show,
    		stub,
    		triggerClick,
    		triggerRef,
    		updateEffortMinutes;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	var { isListItem = true } = $$props;
    	var { showTimeForm = false } = $$props;
    	newValue = void 0;

    	// menu
    	show = false;

    	stub = { estimate: 0 };
    	effort = 0;

    	onMount(function () {
    		return $$invalidate(5, effort = item.estimate / 60);
    	});

    	triggerClick = function () {
    		console.log("trigger click");
    		dispatch("open");
    		return $$invalidate(7, show = true);
    	};

    	triggerRef = void 0;

    	progressMenuClick = function (e) {
    		return console.log("progressmenuclick");
    	};

    	durationKeyup = function (e) {
    		if (e.key === "Escape") {
    			return cancel();
    		}
    	};

    	cancel = function () {
    		$$invalidate(7, show = false);
    		return dispatch("close");
    	};

    	save = function () {
    		var progressItem;

    		// show = false
    		progressItem = { id: item.id, estimate: stub.estimate };

    		dispatch("close");
    		return dispatch("update", progressItem);
    	};

    	add = function () {
    		var progressItem;

    		// show = false
    		progressItem = { estimated_hours: newValue };

    		dispatch("close");
    		return dispatch("save", progressItem);
    	};

    	newTime = 0;

    	updateEffortMinutes = function (e) {
    		return stub.estimate = e.detail.inMinutes;
    	};

    	const writable_props = ["item", "isListItem", "showTimeForm"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$a.warn(`<Time> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Time", $$slots, []);

    	function effortformat_value_binding(value) {
    		item.estimate = value;
    		$$invalidate(0, item);
    	}

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(9, triggerRef = $$value);
    		});
    	}

    	function durationinput_value_binding(value) {
    		effort = value;
    		$$invalidate(5, effort);
    	}

    	function menu_showMenu_binding(value) {
    		show = value;
    		$$invalidate(7, show);
    	}

    	function menu_trigger_binding(value) {
    		triggerRef = value;
    		$$invalidate(9, triggerRef);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("isListItem" in $$props) $$invalidate(1, isListItem = $$props.isListItem);
    		if ("showTimeForm" in $$props) $$invalidate(2, showTimeForm = $$props.showTimeForm);
    	};

    	$$self.$capture_state = () => ({
    		add,
    		cancel,
    		dispatch,
    		durationKeyup,
    		effort,
    		newTime,
    		newValue,
    		progressMenuClick,
    		save,
    		show,
    		stub,
    		triggerClick,
    		triggerRef,
    		updateEffortMinutes,
    		createEventDispatcher,
    		onMount,
    		item,
    		isListItem,
    		showTimeForm,
    		Popover,
    		Menu: ComposedMenuFavorites,
    		EffortFormat,
    		DurationInput
    	});

    	$$self.$inject_state = $$props => {
    		if ("add" in $$props) add = $$props.add;
    		if ("cancel" in $$props) $$invalidate(3, cancel = $$props.cancel);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("durationKeyup" in $$props) $$invalidate(4, durationKeyup = $$props.durationKeyup);
    		if ("effort" in $$props) $$invalidate(5, effort = $$props.effort);
    		if ("newTime" in $$props) newTime = $$props.newTime;
    		if ("newValue" in $$props) newValue = $$props.newValue;
    		if ("progressMenuClick" in $$props) progressMenuClick = $$props.progressMenuClick;
    		if ("save" in $$props) $$invalidate(6, save = $$props.save);
    		if ("show" in $$props) $$invalidate(7, show = $$props.show);
    		if ("stub" in $$props) stub = $$props.stub;
    		if ("triggerClick" in $$props) $$invalidate(8, triggerClick = $$props.triggerClick);
    		if ("triggerRef" in $$props) $$invalidate(9, triggerRef = $$props.triggerRef);
    		if ("updateEffortMinutes" in $$props) $$invalidate(10, updateEffortMinutes = $$props.updateEffortMinutes);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("isListItem" in $$props) $$invalidate(1, isListItem = $$props.isListItem);
    		if ("showTimeForm" in $$props) $$invalidate(2, showTimeForm = $$props.showTimeForm);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		item,
    		isListItem,
    		showTimeForm,
    		cancel,
    		durationKeyup,
    		effort,
    		save,
    		show,
    		triggerClick,
    		triggerRef,
    		updateEffortMinutes,
    		add,
    		dispatch,
    		newTime,
    		newValue,
    		progressMenuClick,
    		stub,
    		effortformat_value_binding,
    		div0_binding,
    		durationinput_value_binding,
    		menu_showMenu_binding,
    		menu_trigger_binding
    	];
    }

    class Time extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, { item: 0, isListItem: 1, showTimeForm: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Time",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get item() {
    		throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isListItem() {
    		throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isListItem(value) {
    		throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showTimeForm() {
    		throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showTimeForm(value) {
    		throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Popovers\Assignment.svelte generated by Svelte v3.22.2 */
    const file$p = "src\\svelte\\pages\\_Common\\Popovers\\Assignment.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i];
    	return child_ctx;
    }

    // (142:8) {:else}
    function create_else_block$5(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "fill");
    			attr_dev(path, "d", "M19,3A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3H9.18C9.6,1.84 10.7,1 12,1C13.3,1 14.4,1.84 14.82,3H19M12,3A1,1 0 0,0 11,4A1,1 0 0,0 12,5A1,1 0 0,0 13,4A1,1 0 0,0 12,3M7,7V5H5V19H19V5H17V7H7M12,9A2,2 0 0,1 14,11A2,2 0 0,1 12,13A2,2 0 0,1 10,11A2,2 0 0,1 12,9M8,17V16C8,14.9 9.79,14 12,14C14.21,14 16,14.9 16,16V17H8Z");
    			add_location(path, file$p, 142, 10, 3431);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(142:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (140:8) {#if (item.assigned_to || []).length == 0}
    function create_if_block_1$3(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "class", "fill");
    			attr_dev(path, "d", "M19,3H14.82C14.4,1.84 13.3,1 12,1C10.7,1 9.6,1.84 9.18,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3M12,3A1,1 0 0,1 13,4A1,1 0 0,1 12,5A1,1 0 0,1 11,4A1,1 0 0,1 12,3M7,7H17V5H19V19H5V5H7V7Z");
    			add_location(path, file$p, 140, 10, 3164);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(140:8) {#if (item.assigned_to || []).length == 0}",
    		ctx
    	});

    	return block;
    }

    // (137:4) <Tooltip content={tooltip}>
    function create_default_slot_1$4(ctx) {
    	let svg;

    	function select_block_type(ctx, dirty) {
    		if ((/*item*/ ctx[0].assigned_to || []).length == 0) return create_if_block_1$3;
    		return create_else_block$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			if_block.c();
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$p, 138, 6, 3005);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			if_block.m(svg, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(svg, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(137:4) <Tooltip content={tooltip}>",
    		ctx
    	});

    	return block;
    }

    // (168:18) {#if (item.assigned_to || []).includes(assignment.id)}
    function create_if_block$b(ctx) {
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$p, 168, 20, 4842);
    			attr_dev(path1, "d", "M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z");
    			attr_dev(path1, "class", "fill");
    			add_location(path1, file$p, 168, 59, 4881);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path0, anchor);
    			insert_dev(target, path1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path0);
    			if (detaching) detach_dev(path1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(168:18) {#if (item.assigned_to || []).includes(assignment.id)}",
    		ctx
    	});

    	return block;
    }

    // (161:6) {#each sortedList as assignment}
    function create_each_block$2(ctx) {
    	let li;
    	let button;
    	let div2;
    	let div0;
    	let svg;
    	let show_if = (/*item*/ ctx[0].assigned_to || []).includes(/*assignment*/ ctx[21].id);
    	let t0;
    	let div1;
    	let t1_value = /*assignment*/ ctx[21].name + "";
    	let t1;
    	let t2;
    	let dispose;
    	let if_block = show_if && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			div2 = element("div");
    			div0 = element("div");
    			svg = svg_element("svg");
    			if (if_block) if_block.c();
    			t0 = space();
    			div1 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$p, 166, 16, 4651);
    			attr_dev(div0, "flex", "initial");
    			set_style(div0, "width", "24px");
    			set_style(div0, "height", "24px");
    			attr_dev(div0, "class", "svelte-nf9dxi");
    			add_location(div0, file$p, 165, 14, 4579);
    			attr_dev(div1, "flex", "flex");
    			attr_dev(div1, "ellipsis", "");
    			set_style(div1, "padding-left", "4px");
    			attr_dev(div1, "class", "svelte-nf9dxi");
    			add_location(div1, file$p, 172, 14, 5039);
    			attr_dev(div2, "layout", "row");
    			attr_dev(div2, "class", "svelte-nf9dxi");
    			add_location(div2, file$p, 163, 12, 4545);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "svelte-nf9dxi");
    			add_location(button, file$p, 162, 10, 4471);
    			attr_dev(li, "class", "svelte-nf9dxi");
    			add_location(li, file$p, 161, 8, 4456);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, div2);
    			append_dev(div2, div0);
    			append_dev(div0, svg);
    			if (if_block) if_block.m(svg, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, t1);
    			append_dev(li, t2);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*assignmentClick*/ ctx[1](/*assignment*/ ctx[21]))) /*assignmentClick*/ ctx[1](/*assignment*/ ctx[21]).apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*item, sortedList*/ 65) show_if = (/*item*/ ctx[0].assigned_to || []).includes(/*assignment*/ ctx[21].id);

    			if (show_if) {
    				if (if_block) ; else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					if_block.m(svg, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*sortedList*/ 64 && t1_value !== (t1_value = /*assignment*/ ctx[21].name + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (if_block) if_block.d();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(161:6) {#each sortedList as assignment}",
    		ctx
    	});

    	return block;
    }

    // (148:2) <Menu bind:showMenu={show} bind:trigger={triggerRef} matchTrigger={false} align="right" top="24px">
    function create_default_slot$7(ctx) {
    	let ul;
    	let li;
    	let button;
    	let div2;
    	let div0;
    	let svg;
    	let t0;
    	let div1;
    	let t2;
    	let hr;
    	let t3;
    	let dispose;
    	let each_value = /*sortedList*/ ctx[6];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li = element("li");
    			button = element("button");
    			div2 = element("div");
    			div0 = element("div");
    			svg = svg_element("svg");
    			t0 = space();
    			div1 = element("div");
    			div1.textContent = "Toggle All";
    			t2 = space();
    			hr = element("hr");
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$p, 153, 14, 4142);
    			attr_dev(div0, "flex", "initial");
    			set_style(div0, "width", "24px");
    			set_style(div0, "height", "24px");
    			attr_dev(div0, "class", "svelte-nf9dxi");
    			add_location(div0, file$p, 152, 12, 4072);
    			attr_dev(div1, "flex", "flex");
    			attr_dev(div1, "ellipsis", "");
    			set_style(div1, "padding-left", "4px");
    			attr_dev(div1, "class", "svelte-nf9dxi");
    			add_location(div1, file$p, 155, 14, 4281);
    			attr_dev(div2, "layout", "row");
    			attr_dev(div2, "class", "svelte-nf9dxi");
    			add_location(div2, file$p, 151, 10, 4041);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "ellipsis", "");
    			attr_dev(button, "class", "svelte-nf9dxi");
    			add_location(button, file$p, 150, 8, 3978);
    			attr_dev(li, "class", "svelte-nf9dxi");
    			add_location(li, file$p, 149, 6, 3965);
    			attr_dev(hr, "class", "svelte-nf9dxi");
    			add_location(hr, file$p, 159, 6, 4403);
    			attr_dev(ul, "class", "svelte-nf9dxi");
    			add_location(ul, file$p, 148, 4, 3954);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li);
    			append_dev(li, button);
    			append_dev(button, div2);
    			append_dev(div2, div0);
    			append_dev(div0, svg);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(ul, t2);
    			append_dev(ul, hr);
    			append_dev(ul, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*toggleAll*/ ctx[3])) /*toggleAll*/ ctx[3].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*assignmentClick, sortedList, item*/ 67) {
    				each_value = /*sortedList*/ ctx[6];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(148:2) <Menu bind:showMenu={show} bind:trigger={triggerRef} matchTrigger={false} align=\\\"right\\\" top=\\\"24px\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let div1;
    	let div0;
    	let t;
    	let updating_showMenu;
    	let updating_trigger;
    	let current;
    	let dispose;

    	const tooltip_1 = new Tooltip({
    			props: {
    				content: /*tooltip*/ ctx[7],
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function menu_showMenu_binding(value) {
    		/*menu_showMenu_binding*/ ctx[19].call(null, value);
    	}

    	function menu_trigger_binding(value) {
    		/*menu_trigger_binding*/ ctx[20].call(null, value);
    	}

    	let menu_props = {
    		matchTrigger: false,
    		align: "right",
    		top: "24px",
    		$$slots: { default: [create_default_slot$7] },
    		$$scope: { ctx }
    	};

    	if (/*show*/ ctx[2] !== void 0) {
    		menu_props.showMenu = /*show*/ ctx[2];
    	}

    	if (/*triggerRef*/ ctx[5] !== void 0) {
    		menu_props.trigger = /*triggerRef*/ ctx[5];
    	}

    	const menu = new ComposedMenuFavorites({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "showMenu", menu_showMenu_binding));
    	binding_callbacks.push(() => bind(menu, "trigger", menu_trigger_binding));

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(tooltip_1.$$.fragment);
    			t = space();
    			create_component(menu.$$.fragment);
    			add_location(div0, file$p, 135, 2, 2913);
    			add_location(div1, file$p, 134, 0, 2905);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(tooltip_1, div0, null);
    			/*div0_binding*/ ctx[18](div0);
    			append_dev(div1, t);
    			mount_component(menu, div1, null);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div0,
    				"click",
    				function () {
    					if (is_function(/*triggerClick*/ ctx[4])) /*triggerClick*/ ctx[4].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const tooltip_1_changes = {};
    			if (dirty & /*tooltip*/ 128) tooltip_1_changes.content = /*tooltip*/ ctx[7];

    			if (dirty & /*$$scope, item*/ 16777217) {
    				tooltip_1_changes.$$scope = { dirty, ctx };
    			}

    			tooltip_1.$set(tooltip_1_changes);
    			const menu_changes = {};

    			if (dirty & /*$$scope, sortedList, assignmentClick, item, toggleAll*/ 16777291) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_showMenu && dirty & /*show*/ 4) {
    				updating_showMenu = true;
    				menu_changes.showMenu = /*show*/ ctx[2];
    				add_flush_callback(() => updating_showMenu = false);
    			}

    			if (!updating_trigger && dirty & /*triggerRef*/ 32) {
    				updating_trigger = true;
    				menu_changes.trigger = /*triggerRef*/ ctx[5];
    				add_flush_callback(() => updating_trigger = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip_1.$$.fragment, local);
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip_1.$$.fragment, local);
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(tooltip_1);
    			/*div0_binding*/ ctx[18](null);
    			destroy_component(menu);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	var assignmentClick,
    		debouncedSave,
    		dispatch,
    		getTooltip,
    		match,
    		newValue,
    		save,
    		show,
    		sort,
    		toggleAll,
    		triggerClick,
    		triggerRef;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	var { value = void 0 } = $$props;
    	newValue = void 0;
    	var { project = void 0 } = $$props;

    	// menu
    	show = false;

    	triggerRef = void 0;

    	triggerClick = function () {
    		dispatch("open");
    		return $$invalidate(2, show = true);
    	};

    	save = function (change) {
    		return dispatch("update", change);
    	};

    	debouncedSave = save.debounce(500);

    	assignmentClick = function (assignment) {
    		if (item.assigned_to == null) {
    			$$invalidate(0, item.assigned_to = [], item);
    		}

    		if (item.assigned_to.includes(assignment.id)) {
    			// remove it
    			item.assigned_to.remove(assignment.id);
    		} else {
    			item.assigned_to.push(assignment.id);
    		}

    		$$invalidate(0, item.assigned_to = item.assigned_to.unique(), item);

    		return debouncedSave({
    			id: item.id,
    			assigned_to: item.assigned_to
    		});
    	};

    	toggleAll = function () {
    		// clear it
    		if (sortedList.length === (item.assigned_to || []).length) {
    			$$invalidate(0, item.assigned_to = [], item);
    		} else {
    			$$invalidate(
    				0,
    				item.assigned_to = sortedList.map(function (o) {
    					return o.id;
    				}),
    				item
    			);
    		}

    		return debouncedSave({
    			id: item.id,
    			assigned_to: item.assigned_to
    		});
    	};

    	sort = function (val) {
    		if (val != null) {
    			return val.sortBy("ordinal");
    		} else {
    			return [];
    		}
    	};

    	match = function (assigned_ids) {
    		var output;

    		output = sort(project.assignments).filter(function (a) {
    			return (assigned_ids || []).includes(a.id);
    		});

    		return output;
    	};

    	getTooltip = function (v) {
    		var options;

    		if ((v.assigned_to || []).length === 0) {
    			return "Unassigned";
    		} else {
    			options = match(v.assigned_to).map(function (i) {
    				return `<li>${i.name}</li>`;
    			});

    			return `<ul>${options}</ul>`;
    		}
    	};

    	const writable_props = ["item", "value", "project"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Assignment> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Assignment", $$slots, []);

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(5, triggerRef = $$value);
    		});
    	}

    	function menu_showMenu_binding(value) {
    		show = value;
    		$$invalidate(2, show);
    	}

    	function menu_trigger_binding(value) {
    		triggerRef = value;
    		$$invalidate(5, triggerRef);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("value" in $$props) $$invalidate(8, value = $$props.value);
    		if ("project" in $$props) $$invalidate(9, project = $$props.project);
    	};

    	$$self.$capture_state = () => ({
    		assignmentClick,
    		debouncedSave,
    		dispatch,
    		getTooltip,
    		match,
    		newValue,
    		save,
    		show,
    		sort,
    		toggleAll,
    		triggerClick,
    		triggerRef,
    		createEventDispatcher,
    		item,
    		value,
    		Menu: ComposedMenuFavorites,
    		Tooltip,
    		project,
    		sortedList,
    		assigned,
    		tooltip
    	});

    	$$self.$inject_state = $$props => {
    		if ("assignmentClick" in $$props) $$invalidate(1, assignmentClick = $$props.assignmentClick);
    		if ("debouncedSave" in $$props) debouncedSave = $$props.debouncedSave;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("getTooltip" in $$props) $$invalidate(12, getTooltip = $$props.getTooltip);
    		if ("match" in $$props) $$invalidate(13, match = $$props.match);
    		if ("newValue" in $$props) newValue = $$props.newValue;
    		if ("save" in $$props) save = $$props.save;
    		if ("show" in $$props) $$invalidate(2, show = $$props.show);
    		if ("sort" in $$props) $$invalidate(16, sort = $$props.sort);
    		if ("toggleAll" in $$props) $$invalidate(3, toggleAll = $$props.toggleAll);
    		if ("triggerClick" in $$props) $$invalidate(4, triggerClick = $$props.triggerClick);
    		if ("triggerRef" in $$props) $$invalidate(5, triggerRef = $$props.triggerRef);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("value" in $$props) $$invalidate(8, value = $$props.value);
    		if ("project" in $$props) $$invalidate(9, project = $$props.project);
    		if ("sortedList" in $$props) $$invalidate(6, sortedList = $$props.sortedList);
    		if ("assigned" in $$props) assigned = $$props.assigned;
    		if ("tooltip" in $$props) $$invalidate(7, tooltip = $$props.tooltip);
    	};

    	let assigned;
    	let sortedList;
    	let tooltip;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*match, item*/ 8193) {
    			 assigned = match(item.assigned_to);
    		}

    		if ($$self.$$.dirty & /*sort, project*/ 66048) {
    			 $$invalidate(6, sortedList = sort(project.assignments));
    		}

    		if ($$self.$$.dirty & /*getTooltip, item*/ 4097) {
    			 $$invalidate(7, tooltip = getTooltip(item));
    		}
    	};

    	return [
    		item,
    		assignmentClick,
    		show,
    		toggleAll,
    		triggerClick,
    		triggerRef,
    		sortedList,
    		tooltip,
    		value,
    		project,
    		debouncedSave,
    		dispatch,
    		getTooltip,
    		match,
    		newValue,
    		save,
    		sort,
    		assigned,
    		div0_binding,
    		menu_showMenu_binding,
    		menu_trigger_binding
    	];
    }

    class Assignment$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, { item: 0, value: 8, project: 9 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Assignment",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get item() {
    		throw new Error("<Assignment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Assignment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Assignment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Assignment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get project() {
    		throw new Error("<Assignment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set project(value) {
    		throw new Error("<Assignment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Menus\Checklist.svelte generated by Svelte v3.22.2 */

    const { console: console_1$b } = globals;
    const file$q = "src\\svelte\\pages\\_Common\\Menus\\Checklist.svelte";

    // (90:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align="right" {width}>
    function create_default_slot$8(ctx) {
    	let ul;
    	let li;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li = element("li");
    			button = element("button");
    			button.textContent = "Delete Item";
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "svelte-1vrp3g");
    			add_location(button, file$q, 92, 6, 2459);
    			attr_dev(li, "class", "svelte-1vrp3g");
    			add_location(li, file$q, 91, 4, 2447);
    			attr_dev(ul, "class", "svelte-1vrp3g");
    			add_location(ul, file$q, 90, 2, 2437);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li);
    			append_dev(li, button);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*deleteConfirmation*/ ctx[0])) /*deleteConfirmation*/ ctx[0].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(90:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align=\\\"right\\\" {width}>",
    		ctx
    	});

    	return block;
    }

    // (97:0) {#if showDeleteConfirmation}
    function create_if_block$c(ctx) {
    	let current;
    	const deleteconfirmation = new DeleteConfirmation({ $$inline: true });

    	deleteconfirmation.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[2])) /*destroy*/ ctx[2].apply(this, arguments);
    	});

    	deleteconfirmation.$on("cancel", function () {
    		if (is_function(/*deleteConfirmationCancel*/ ctx[1])) /*deleteConfirmationCancel*/ ctx[1].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(deleteconfirmation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deleteconfirmation, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteconfirmation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteconfirmation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deleteconfirmation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(97:0) {#if showDeleteConfirmation}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let button;
    	let svg;
    	let path;
    	let t0;
    	let updating_showMenu;
    	let t1;
    	let if_block_anchor;
    	let current;
    	let dispose;

    	function menu_showMenu_binding(value) {
    		/*menu_showMenu_binding*/ ctx[13].call(null, value);
    	}

    	let menu_props = {
    		trigger: /*menuButtonRef*/ ctx[3],
    		align: "right",
    		width: /*width*/ ctx[7],
    		$$slots: { default: [create_default_slot$8] },
    		$$scope: { ctx }
    	};

    	if (/*showMenu*/ ctx[6] !== void 0) {
    		menu_props.showMenu = /*showMenu*/ ctx[6];
    	}

    	const menu = new ComposedMenu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "showMenu", menu_showMenu_binding));
    	let if_block = /*showDeleteConfirmation*/ ctx[5] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t0 = space();
    			create_component(menu.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(path, "d", "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z");
    			add_location(path, file$q, 87, 112, 2119);
    			attr_dev(svg, "class", "menu");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$q, 87, 2, 2009);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$q, 86, 0, 1932);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			/*button_binding*/ ctx[12](button);
    			insert_dev(target, t0, anchor);
    			mount_component(menu, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*openMenu*/ ctx[4])) /*openMenu*/ ctx[4].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const menu_changes = {};
    			if (dirty & /*menuButtonRef*/ 8) menu_changes.trigger = /*menuButtonRef*/ ctx[3];
    			if (dirty & /*width*/ 128) menu_changes.width = /*width*/ ctx[7];

    			if (dirty & /*$$scope, deleteConfirmation*/ 16385) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_showMenu && dirty & /*showMenu*/ 64) {
    				updating_showMenu = true;
    				menu_changes.showMenu = /*showMenu*/ ctx[6];
    				add_flush_callback(() => updating_showMenu = false);
    			}

    			menu.$set(menu_changes);

    			if (/*showDeleteConfirmation*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showDeleteConfirmation*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			/*button_binding*/ ctx[12](null);
    			if (detaching) detach_dev(t0);
    			destroy_component(menu, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	var closeMenu,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		indent,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	menuButtonRef = void 0;
    	showMenu = false;

    	openMenu = function () {
    		return $$invalidate(6, showMenu = true);
    	};

    	closeMenu = function () {
    		return $$invalidate(6, showMenu = false);
    	};

    	width = "189px";

    	destroy = function () {
    		dispatch("destroy", item);
    		return closeMenu();
    	};

    	indent = function (indentLevel) {
    		console.log("indent");
    		dispatch("update", { id: item.id, indent: indentLevel });
    		return closeMenu();
    	};

    	showDeleteConfirmation = false;

    	deleteConfirmation = function () {
    		closeMenu();
    		return $$invalidate(5, showDeleteConfirmation = true);
    	};

    	deleteConfirmationCancel = function () {
    		return $$invalidate(5, showDeleteConfirmation = false);
    	};

    	destroy = function () {
    		dispatch("destroy", item);
    		return $$invalidate(5, showDeleteConfirmation = false);
    	};

    	const writable_props = ["item"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$b.warn(`<Checklist> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Checklist", $$slots, []);

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(3, menuButtonRef = $$value);
    		});
    	}

    	function menu_showMenu_binding(value) {
    		showMenu = value;
    		$$invalidate(6, showMenu);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(8, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({
    		closeMenu,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		indent,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width,
    		createEventDispatcher,
    		Menu: ComposedMenu,
    		DeleteConfirmation,
    		item
    	});

    	$$self.$inject_state = $$props => {
    		if ("closeMenu" in $$props) closeMenu = $$props.closeMenu;
    		if ("deleteConfirmation" in $$props) $$invalidate(0, deleteConfirmation = $$props.deleteConfirmation);
    		if ("deleteConfirmationCancel" in $$props) $$invalidate(1, deleteConfirmationCancel = $$props.deleteConfirmationCancel);
    		if ("destroy" in $$props) $$invalidate(2, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("indent" in $$props) indent = $$props.indent;
    		if ("menuButtonRef" in $$props) $$invalidate(3, menuButtonRef = $$props.menuButtonRef);
    		if ("openMenu" in $$props) $$invalidate(4, openMenu = $$props.openMenu);
    		if ("showDeleteConfirmation" in $$props) $$invalidate(5, showDeleteConfirmation = $$props.showDeleteConfirmation);
    		if ("showMenu" in $$props) $$invalidate(6, showMenu = $$props.showMenu);
    		if ("width" in $$props) $$invalidate(7, width = $$props.width);
    		if ("item" in $$props) $$invalidate(8, item = $$props.item);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width,
    		item,
    		closeMenu,
    		dispatch,
    		indent,
    		button_binding,
    		menu_showMenu_binding
    	];
    }

    class Checklist extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, { item: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checklist",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get item() {
    		throw new Error("<Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // requires global variable db, declared in App.svelte
    var PouchResource;

    PouchResource = (function() {
      class PouchResource {
        model() {
          return {
            // if sourceversion < latest version, then some upgrades may be required
            // if null then return latest
            _id: null,
            id: null,
            type: this.type,
            name: null,
            due_date: null,
            completion_date: null,
            estimate: null,
            progress: {
              percent_complete: 0,
              color: "light-gray"
            },
            ordinal: null,
            indent: 0,
            hierarchy: null,
            content: "",
            content_indexable: "",
            assigned_to: [],
            assignments: [],
            attachments: [],
            tasks: [],
            documents: [],
            clips: [],
            attachments: [],
            created_at: null,
            updated_at: null,
            metadata: {},
            is_favorite: false,
            is_archived: false,
            is_locked: false,
            is_template: false,
            last_export: null,
            settings: {
              hours_per_day: 8,
              sections: {
                about: {
                  enabled: true,
                  expanded: true,
                  label: "Description"
                },
                assignments: {
                  enabled: true,
                  expanded: true,
                  label: "Assignments"
                },
                tasks: {
                  enabled: true,
                  expanded: true,
                  label: "Tasks"
                },
                documents: {
                  enabled: true,
                  expanded: true,
                  label: "Documents"
                },
                clips: {
                  enabled: true,
                  expanded: true,
                  label: "Clips"
                },
                attachments: {
                  enabled: true,
                  expanded: true,
                  label: "Assignments"
                },
                settings: {
                  enabled: true,
                  expanded: true,
                  label: "Settings"
                }
              }
            }
          };
        }

        upgradeModel(item) {
          var latest;
          // check version
          latest = this.model();
          //console.log item
          delete item.description;
          if (item.progress == null) {
            item["progress"] = {
              percent_complete: item.percent_complete,
              color: "gray"
            };
            delete item.percent_complete;
          }
          if (item.settings.sections == null) {
            item.settings["sections"] = latest.settings.sections; // get rid of obsolete
          } else {
            if (item.settings.sections.description != null) {
              item.settings.sections["about"] = item.settings.sections.description;
              delete item.settings.sections.description;
            }
            if (item.settings.sections.details != null) {
              delete item.settings.sections.details;
            }
          }
          return item;
        }

        stub(override) {
          var base, newId;
          base = this.model();
          newId = uuid();
          base._id = newId;
          base.id = newId;
          base.name = `New ${this.type} created at ${Date.create().format('%Y-%m-%d %H:%M:%S')}`;
          base.created_at = Date.create();
          base.updated_at = Date.create();
          if (override != null) {
            return Object.merge(base, override, true);
          } else {
            return base;
          }
        }

        transformCollection(items) {
          var that;
          that = this;
          //console.log items
          return items.map(function(item) {
            return that.transformModel(item);
          });
        }

        transformModel(item) {
          var base, upgraded;
          base = this.model();
          base.id = item._id;
          upgraded = Object.merge(base, this.upgradeModel(item), true);
          //console.log upgraded
          return upgraded;
        }

        constructor(options) {
          this.after_construct();
        }

        after_construct() {}

        sync() {
          console.log("pouchresourece.sync");
          return window.pouch.sync();
        }

        select(thenCb, catchCb, finallyCb) {
          var that;
          that = this;
          return db.find({
            selector: {
              type: this.type
            }
          }).then(function(result) {
            if (thenCb != null) {
              return thenCb(that.transformCollection(result.docs));
            }
          }).catch(function(err) {
            if (catchCb != null) {
              return catchCb(err);
            } else {
              console.log("select  err");
              return console.log(err);
            }
          }).finally(function() {
            if (finallyCb != null) {
              return finallyCb();
            }
          });
        }

        selectOne(id, thenCb, catchCb, finallyCb) {
          var that;
          that = this;
          // console.log "selectone #{id}"
          return db.get(id).then(function(doc) {
            //console.log "select one"
            //console.log doc
            if (thenCb != null) {
              return thenCb(that.transformModel(doc));
            }
          }).catch(function(err) {
            if (catchCb != null) {
              return catchCb(err);
            } else {
              console.log("select on e err");
              return console.log(err);
            }
          }).finally(function() {
            if (finallyCb != null) {
              return finallyCb();
            }
          });
        }

        find(options, thenCb, catchCb, finallyCb) {
          return db.find(options).then(function(result) {
            if (thenCb != null) {
              return thenCb(that.transformCollection(result.docs));
            }
          }).catch(function(err) {
            if (catchCb != null) {
              return catchCb(err);
            } else {
              console.log("select  err");
              return console.log(err);
            }
          }).finally(function() {
            if (finallyCb != null) {
              return finallyCb();
            }
          });
        }

        insert(obj, thenCb, catchCb, finallyCb) {
          var newRecord, that;
          that = this;
          newRecord = this.stub(obj);
          //console.log "newRecord"
          //console.log newRecord
          newRecord.created_at = Date.create();
          return db.put(newRecord).then(function(response) {
            // note the response is this format:
            // ok: true
            // id: id
            // rev: rev_id
            if (thenCb != null) {
              return thenCb(response);
            }
          }).catch(function(err) {
            if (catchCb != null) {
              return catchCb(err);
            } else {
              console.log("insert.catch");
              return console.log(err);
            }
          }).finally(function() {
            console.log("insert finally");
            that.sync();
            if (finallyCb != null) {
              console.log("insert.finally");
              return finallyCb();
            }
          });
        }

        update(changedDoc, thenCb, catchCb, finallyCb) {
          var that;
          that = this;
          //console.log "updateDocument"
          //console.log changedDoc
          //console.log "attempt to update #{changedDoc.id}"
          return db.get(changedDoc.id).then(function(originalDoc) {
            changedDoc["_rev"] = originalDoc._rev;
            changedDoc.updated_at = Date.create();
            if (thenCb != null) {
              return thenCb(db.put(changedDoc));
            }
          }).catch(function(err) {
            if (catchCb != null) {
              return catchCb(err);
            } else {
              console.log("update.catch");
              return console.log(err);
            }
          }).finally(function() {
            console.log("update finally");
            that.sync();
            if (finallyCb != null) {
              return finallyCb();
            }
          });
        }

        updateAttributes(changedDoc, thenCb, catchCb, finallyCb) {
          var that;
          that = this;
          return db.get(changedDoc.id).then(function(originalDoc) {
            Object.merge(originalDoc, changedDoc);
            originalDoc.updated_at = Date.create();
            if (thenCb != null) {
              return thenCb(db.put(originalDoc));
            }
          }).catch(function(err) {
            if (catchCb != null) {
              return catchCb(err);
            } else {
              console.log("update.catch");
              return console.log(err);
            }
          }).finally(function() {
            that.sync();
            if (finallyCb != null) {
              return finallyCb();
            }
          });
        }

        destroy(id, thenCb, catchCb, finallyCb) {
          var that;
          that = this;
          return db.get(id).then(function(response) {
            if (thenCb != null) {
              return thenCb(db.remove(response));
            }
          }).catch(function(err) {
            if (catchCb != null) {
              return catchCb(err);
            } else {
              console.log("destroy.catch");
              return console.log(err);
            }
          }).finally(function() {
            console.log("destroy finally");
            that.sync();
            if (finallyCb != null) {
              return finallyCb();
            }
          });
        }

      }
      PouchResource.prototype.name = "Resource Name";

      PouchResource.prototype.type = "resource";

      PouchResource.prototype.version = 1;

      return PouchResource;

    }).call(commonjsGlobal);

    var pouch_resource = PouchResource;

    var PouchDocument, Project$1;

    PouchDocument = pouch_resource;

    Project$1 = (function() {
      class Project extends PouchDocument {
        /*
          options:
            project:
            subDocument:
            checklistItem:
        */
        updateChecklistItem(options, thenCb, catchCb, finallyCb) {
          var that;
          that = this;
          console.log("updateChecklistItem");
          console.log(options);
          return db.get(options.project.id).then(function(doc) {
            var affectedChecklistItem, affectedSubDocument, collection;
            //console.log "select one"
            //console.log doc
            console.log("found project");
            console.log(doc);
            doc.updated_at = Date.create();
            collection = options.subDocument.type.pluralize();
            console.log(`collection: ${collection}`);
            affectedSubDocument = doc[collection].find(function(item) {
              return item.id === options.subDocument.id;
            });
            if (affectedSubDocument != null) {
              console.log("found affected subdocument");
              console.log(affectedSubDocument);
              affectedSubDocument.updated_at = Date.create();
              affectedChecklistItem = affectedSubDocument.checklist_items.find(function(checklistItem) {
                return checklistItem.id === options.checklistItem.id;
              });
              if (affectedChecklistItem != null) {
                console.log("found affected affectedChecklistItem");
                console.log(affectedChecklistItem);
                Object.merge(affectedChecklistItem, options.checklistItem);
                affectedChecklistItem.updated_at = Date.create();
                // update the project doc
                if (thenCb != null) {
                  return thenCb(db.put(doc));
                } else {
                  return console.log("cb required");
                }
              }
            }
          }).catch(function(err) {
            if (catchCb != null) {
              return catchCb(err);
            } else {
              console.log("select on e err");
              return console.log(err);
            }
          }).finally(function() {
            that.sync();
            if (finallyCb != null) {
              return finallyCb();
            }
          });
        }

        /*
          options:
            project:
            subDocument:
        */
        updateSubdocument(options, thenCb, catchCb, finallyCb) {
          var that;
          that = this;
          console.log("updateChecklistItem");
          console.log(options);
          return db.get(options.project.id).then(function(doc) {
            var affectedSubDocument, collection;
            //console.log "select one"
            //console.log doc
            console.log("found project");
            console.log(doc);
            doc.updated_at = Date.create();
            collection = options.subDocument.type.pluralize();
            console.log(`collection: ${collection}`);
            affectedSubDocument = doc[collection].find(function(item) {
              return item.id === options.subDocument.id;
            });
            if (affectedSubDocument != null) {
              console.log("found affected subdocument");
              console.log(affectedSubDocument);
              Object.merge(affectedSubDocument, options.subDocument);
              affectedSubDocument.updated_at = Date.create();
              // update the project doc
              if (thenCb != null) {
                return thenCb(db.put(doc));
              } else {
                return console.log("cb required");
              }
            }
          }).catch(function(err) {
            if (catchCb != null) {
              return catchCb(err);
            } else {
              console.log("select on e err");
              return console.log(err);
            }
          }).finally(function() {
            that.sync();
            if (finallyCb != null) {
              return finallyCb();
            }
          });
        }

      }
      Project.prototype.name = "Project";

      Project.prototype.type = "project";

      return Project;

    }).call(commonjsGlobal);

    var project = Project$1;

    /* src\svelte\pages\_Common\Sections\Home_Checklist.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$3, console: console_1$c } = globals;
    const file$r = "src\\svelte\\pages\\_Common\\Sections\\Home_Checklist.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	child_ctx[23] = list;
    	child_ctx[24] = i;
    	return child_ctx;
    }

    // (99:2) {#if list.length > 0}
    function create_if_block$d(ctx) {
    	let div;
    	let current;
    	let each_value = /*list*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$r, 100, 4, 2287);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*list, project, updateAttribute, style, label, toggleCompleted*/ 33554463) {
    				each_value = /*list*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(99:2) {#if list.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (112:16) {:else}
    function create_else_block$6(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M19 5v14H5V5h14m2-2H3v18h18V3z");
    			add_location(path, file$r, 112, 18, 2901);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(112:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (110:16) {#if checklistItem.is_completed}
    function create_if_block_2$2(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M21 3H3v18h18V3zM10 17l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z");
    			add_location(path, file$r, 110, 18, 2777);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(110:16) {#if checklistItem.is_completed}",
    		ctx
    	});

    	return block;
    }

    // (119:14) <InlineInput bind:value={checklistItem.content} on:update={updateAttribute({ detail: {id: checklistItem.id, name: checklistItem.content } })} {style} let:label>
    function create_default_slot$9(ctx) {
    	let span;
    	let t_value = /*label*/ ctx[25] + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "ellipsis", "");
    			add_location(span, file$r, 119, 14, 3254);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 33554432 && t_value !== (t_value = /*label*/ ctx[25] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(119:14) <InlineInput bind:value={checklistItem.content} on:update={updateAttribute({ detail: {id: checklistItem.id, name: checklistItem.content } })} {style} let:label>",
    		ctx
    	});

    	return block;
    }

    // (135:14) {#if (project.assignments.length > 0)}
    function create_if_block_1$4(ctx) {
    	let div;
    	let updating_item;
    	let div_present_value;
    	let current;

    	function assignmentpopover_item_binding(value) {
    		/*assignmentpopover_item_binding*/ ctx[19].call(null, value, /*checklistItem*/ ctx[22], /*each_value*/ ctx[23], /*index*/ ctx[24]);
    	}

    	let assignmentpopover_props = { project: /*project*/ ctx[0] };

    	if (/*checklistItem*/ ctx[22] !== void 0) {
    		assignmentpopover_props.item = /*checklistItem*/ ctx[22];
    	}

    	const assignmentpopover = new Assignment$1({
    			props: assignmentpopover_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(assignmentpopover, "item", assignmentpopover_item_binding));

    	assignmentpopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[3])) /*updateAttribute*/ ctx[3].apply(this, arguments);
    	});

    	assignmentpopover.$on("open", /*open_handler_1*/ ctx[20]);
    	assignmentpopover.$on("close", /*close_handler_1*/ ctx[21]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(assignmentpopover.$$.fragment);
    			attr_dev(div, "flex", "initial");
    			attr_dev(div, "present", div_present_value = (/*checklistItem*/ ctx[22].assigned_to || []).length > 0);
    			attr_dev(div, "class", "svelte-1239dg0");
    			add_location(div, file$r, 135, 16, 3743);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(assignmentpopover, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const assignmentpopover_changes = {};
    			if (dirty & /*project*/ 1) assignmentpopover_changes.project = /*project*/ ctx[0];

    			if (!updating_item && dirty & /*list*/ 16) {
    				updating_item = true;
    				assignmentpopover_changes.item = /*checklistItem*/ ctx[22];
    				add_flush_callback(() => updating_item = false);
    			}

    			assignmentpopover.$set(assignmentpopover_changes);

    			if (!current || dirty & /*list*/ 16 && div_present_value !== (div_present_value = (/*checklistItem*/ ctx[22].assigned_to || []).length > 0)) {
    				attr_dev(div, "present", div_present_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(assignmentpopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(assignmentpopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(assignmentpopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(135:14) {#if (project.assignments.length > 0)}",
    		ctx
    	});

    	return block;
    }

    // (103:6) {#each list as checklistItem, index}
    function create_each_block$3(ctx) {
    	let div5;
    	let t0;
    	let div0;
    	let button;
    	let svg;
    	let path;
    	let t1;
    	let div1;
    	let updating_value;
    	let t2;
    	let div4;
    	let div3;
    	let div2;
    	let t3;
    	let t4;
    	let current;
    	let dispose;

    	const indent = new Indent({
    			props: { level: 1, width: 32 },
    			$$inline: true
    		});

    	function select_block_type(ctx, dirty) {
    		if (/*checklistItem*/ ctx[22].is_completed) return create_if_block_2$2;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function inlineinput_value_binding(value) {
    		/*inlineinput_value_binding*/ ctx[16].call(null, value, /*checklistItem*/ ctx[22]);
    	}

    	let inlineinput_props = {
    		style: /*style*/ ctx[1],
    		$$slots: {
    			default: [
    				create_default_slot$9,
    				({ label }) => ({ 25: label }),
    				({ label }) => label ? 33554432 : 0
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*checklistItem*/ ctx[22].content !== void 0) {
    		inlineinput_props.value = /*checklistItem*/ ctx[22].content;
    	}

    	const inlineinput = new InlineInput({ props: inlineinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(inlineinput, "value", inlineinput_value_binding));

    	inlineinput.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[3]({
    			detail: {
    				id: /*checklistItem*/ ctx[22].id,
    				name: /*checklistItem*/ ctx[22].content
    			}
    		}))) /*updateAttribute*/ ctx[3]({
    			detail: {
    				id: /*checklistItem*/ ctx[22].id,
    				name: /*checklistItem*/ ctx[22].content
    			}
    		}).apply(this, arguments);
    	});

    	const duedatepopover = new DueDate({
    			props: {
    				item: /*checklistItem*/ ctx[22],
    				value: /*checklistItem*/ ctx[22].due_date
    			},
    			$$inline: true
    		});

    	duedatepopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[3])) /*updateAttribute*/ ctx[3].apply(this, arguments);
    	});

    	duedatepopover.$on("open", /*open_handler*/ ctx[17]);
    	duedatepopover.$on("close", /*close_handler*/ ctx[18]);
    	let if_block1 = /*project*/ ctx[0].assignments.length > 0 && create_if_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			create_component(indent.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if_block0.c();
    			t1 = space();
    			div1 = element("div");
    			create_component(inlineinput.$$.fragment);
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			create_component(duedatepopover.$$.fragment);
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			attr_dev(path, "fill", "none");
    			attr_dev(path, "d", "M0 0h24v24H0V0z");
    			add_location(path, file$r, 108, 97, 2668);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$r, 108, 14, 2585);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$r, 107, 12, 2500);
    			attr_dev(div0, "flex", "initial");
    			set_style(div0, "padding-right", "8px");
    			add_location(div0, file$r, 106, 10, 2439);
    			attr_dev(div1, "flex", "");
    			attr_dev(div1, "ellipsis", "");
    			add_location(div1, file$r, 117, 12, 3043);
    			attr_dev(div2, "flex", "initial");
    			add_location(div2, file$r, 128, 14, 3453);
    			attr_dev(div3, "layout", "row");
    			add_location(div3, file$r, 123, 12, 3375);
    			attr_dev(div4, "flex", "initial");
    			add_location(div4, file$r, 122, 10, 3341);
    			attr_dev(div5, "layout", "row");
    			attr_dev(div5, "type", "list-item");
    			attr_dev(div5, "class", "svelte-1239dg0");
    			add_location(div5, file$r, 104, 8, 2350);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div5, anchor);
    			mount_component(indent, div5, null);
    			append_dev(div5, t0);
    			append_dev(div5, div0);
    			append_dev(div0, button);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			if_block0.m(svg, null);
    			append_dev(div5, t1);
    			append_dev(div5, div1);
    			mount_component(inlineinput, div1, null);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			mount_component(duedatepopover, div2, null);
    			append_dev(div3, t3);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div5, t4);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*toggleCompleted*/ ctx[2](/*checklistItem*/ ctx[22]))) /*toggleCompleted*/ ctx[2](/*checklistItem*/ ctx[22]).apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(svg, null);
    				}
    			}

    			const inlineinput_changes = {};
    			if (dirty & /*style*/ 2) inlineinput_changes.style = /*style*/ ctx[1];

    			if (dirty & /*$$scope, label*/ 100663296) {
    				inlineinput_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty & /*list*/ 16) {
    				updating_value = true;
    				inlineinput_changes.value = /*checklistItem*/ ctx[22].content;
    				add_flush_callback(() => updating_value = false);
    			}

    			inlineinput.$set(inlineinput_changes);
    			const duedatepopover_changes = {};
    			if (dirty & /*list*/ 16) duedatepopover_changes.item = /*checklistItem*/ ctx[22];
    			if (dirty & /*list*/ 16) duedatepopover_changes.value = /*checklistItem*/ ctx[22].due_date;
    			duedatepopover.$set(duedatepopover_changes);

    			if (/*project*/ ctx[0].assignments.length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*project*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indent.$$.fragment, local);
    			transition_in(inlineinput.$$.fragment, local);
    			transition_in(duedatepopover.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indent.$$.fragment, local);
    			transition_out(inlineinput.$$.fragment, local);
    			transition_out(duedatepopover.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(indent);
    			if_block0.d();
    			destroy_component(inlineinput);
    			destroy_component(duedatepopover);
    			if (if_block1) if_block1.d();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(103:6) {#each list as checklistItem, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*list*/ ctx[4].length > 0 && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*list*/ ctx[4].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*list*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	var dispatch, resource, save, sort, style, toggleCompleted, updateAttribute;
    	dispatch = createEventDispatcher();
    	var { assignments = [] } = $$props;
    	var { project: project$1 = void 0 } = $$props;
    	var { showProgress = true } = $$props;
    	var { showAssignment = true } = $$props;
    	var { showChecklist = false } = $$props;
    	var { collection = [] } = $$props;
    	var { item = void 0 } = $$props;
    	var { rawList = [] } = $$props;
    	resource = new project();
    	style = ":hover {font-weight: bold}";

    	save = function () {
    		
    	}; // assignment

    	sort = function () {
    		if (item.checklist_items != null) {
    			return item.checklist_items.sortBy("ordinal");
    		} else {
    			return [];
    		}
    	};

    	style = ":hover {font-weight: bold}";

    	toggleCompleted = function (checklistItem) {
    		var wasAlreadyCompleted;

    		// has some additional logic
    		wasAlreadyCompleted = checklistItem.is_completed === true;

    		checklistItem.is_completed = !checklistItem.is_completed;

    		if (checklistItem.isCompleted) {
    			if (!wasAlreadyCompleted) {
    				// then don''t update date
    				checklistItem.completion_date = Date.create(); // flip it back to null
    			}
    		} else {
    			checklistItem.completion_date = null;
    		}

    		return updateAttribute({
    			detail: {
    				id: checklistItem.id,
    				is_completed: checklistItem.is_completed,
    				completion_date: checklistItem.completion_date
    			}
    		});
    	};

    	updateAttribute = function (e) {
    		var change, changeOptions, changed;
    		console.log("checklist updateAttribute");
    		console.log(e.detail);
    		change = e.detail;
    		changed = item.checklist_items.find({ id: change.id });
    		Object.merge(changed, change);
    		$$invalidate(5, item); // refresh array

    		changeOptions = {
    			project: project$1,
    			subDocument: item,
    			checklistItem: changed
    		};

    		return dispatch("update", changeOptions);
    	};

    	const writable_props = [
    		"assignments",
    		"project",
    		"showProgress",
    		"showAssignment",
    		"showChecklist",
    		"collection",
    		"item",
    		"rawList"
    	];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$c.warn(`<Home_Checklist> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Home_Checklist", $$slots, []);

    	function inlineinput_value_binding(value, checklistItem) {
    		checklistItem.content = value;
    		(($$invalidate(4, list), $$invalidate(15, sort)), $$invalidate(5, item));
    	}

    	function open_handler(event) {
    		bubble($$self, event);
    	}

    	function close_handler(event) {
    		bubble($$self, event);
    	}

    	function assignmentpopover_item_binding(value, checklistItem, each_value, index) {
    		each_value[index] = value;
    		(($$invalidate(4, list), $$invalidate(15, sort)), $$invalidate(5, item));
    	}

    	function open_handler_1(event) {
    		bubble($$self, event);
    	}

    	function close_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("assignments" in $$props) $$invalidate(6, assignments = $$props.assignments);
    		if ("project" in $$props) $$invalidate(0, project$1 = $$props.project);
    		if ("showProgress" in $$props) $$invalidate(7, showProgress = $$props.showProgress);
    		if ("showAssignment" in $$props) $$invalidate(8, showAssignment = $$props.showAssignment);
    		if ("showChecklist" in $$props) $$invalidate(9, showChecklist = $$props.showChecklist);
    		if ("collection" in $$props) $$invalidate(10, collection = $$props.collection);
    		if ("item" in $$props) $$invalidate(5, item = $$props.item);
    		if ("rawList" in $$props) $$invalidate(11, rawList = $$props.rawList);
    	};

    	$$self.$capture_state = () => ({
    		dispatch,
    		resource,
    		save,
    		sort,
    		style,
    		toggleCompleted,
    		updateAttribute,
    		Indent,
    		onMount,
    		createEventDispatcher,
    		InlineInput,
    		DueDatePopover: DueDate,
    		AssignmentPopover: Assignment$1,
    		Menu: Checklist,
    		assignments,
    		project: project$1,
    		showProgress,
    		showAssignment,
    		showChecklist,
    		collection,
    		item,
    		rawList,
    		Project: project,
    		list
    	});

    	$$self.$inject_state = $$props => {
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("resource" in $$props) resource = $$props.resource;
    		if ("save" in $$props) save = $$props.save;
    		if ("sort" in $$props) $$invalidate(15, sort = $$props.sort);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("toggleCompleted" in $$props) $$invalidate(2, toggleCompleted = $$props.toggleCompleted);
    		if ("updateAttribute" in $$props) $$invalidate(3, updateAttribute = $$props.updateAttribute);
    		if ("assignments" in $$props) $$invalidate(6, assignments = $$props.assignments);
    		if ("project" in $$props) $$invalidate(0, project$1 = $$props.project);
    		if ("showProgress" in $$props) $$invalidate(7, showProgress = $$props.showProgress);
    		if ("showAssignment" in $$props) $$invalidate(8, showAssignment = $$props.showAssignment);
    		if ("showChecklist" in $$props) $$invalidate(9, showChecklist = $$props.showChecklist);
    		if ("collection" in $$props) $$invalidate(10, collection = $$props.collection);
    		if ("item" in $$props) $$invalidate(5, item = $$props.item);
    		if ("rawList" in $$props) $$invalidate(11, rawList = $$props.rawList);
    		if ("list" in $$props) $$invalidate(4, list = $$props.list);
    	};

    	let list;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*sort, item*/ 32800) {
    			 $$invalidate(4, list = sort(item.checklist_items));
    		}
    	};

    	return [
    		project$1,
    		style,
    		toggleCompleted,
    		updateAttribute,
    		list,
    		item,
    		assignments,
    		showProgress,
    		showAssignment,
    		showChecklist,
    		collection,
    		rawList,
    		dispatch,
    		resource,
    		save,
    		sort,
    		inlineinput_value_binding,
    		open_handler,
    		close_handler,
    		assignmentpopover_item_binding,
    		open_handler_1,
    		close_handler_1
    	];
    }

    class Home_Checklist extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
    			assignments: 6,
    			project: 0,
    			showProgress: 7,
    			showAssignment: 8,
    			showChecklist: 9,
    			collection: 10,
    			item: 5,
    			rawList: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home_Checklist",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get assignments() {
    		throw new Error("<Home_Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set assignments(value) {
    		throw new Error("<Home_Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get project() {
    		throw new Error("<Home_Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set project(value) {
    		throw new Error("<Home_Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showProgress() {
    		throw new Error("<Home_Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showProgress(value) {
    		throw new Error("<Home_Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showAssignment() {
    		throw new Error("<Home_Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showAssignment(value) {
    		throw new Error("<Home_Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showChecklist() {
    		throw new Error("<Home_Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showChecklist(value) {
    		throw new Error("<Home_Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collection() {
    		throw new Error("<Home_Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collection(value) {
    		throw new Error("<Home_Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Home_Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Home_Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rawList() {
    		throw new Error("<Home_Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rawList(value) {
    		throw new Error("<Home_Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\QuickEntry\_AddStub.svelte generated by Svelte v3.22.2 */
    const file$s = "src\\svelte\\pages\\_Common\\QuickEntry\\_AddStub.svelte";

    function create_fragment$w(ctx) {
    	let div2;
    	let div0;
    	let svg;
    	let path;
    	let t0;
    	let div1;
    	let span;
    	let t1;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t0 = space();
    			div1 = element("div");
    			span = element("span");
    			t1 = text(/*stubPlaceholder*/ ctx[0]);
    			attr_dev(path, "fill", "var(--light-gray)");
    			attr_dev(path, "d", "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z");
    			attr_dev(path, "class", "svelte-rybc7e");
    			add_location(path, file$s, 27, 101, 673);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$s, 27, 4, 576);
    			attr_dev(div0, "flex", "initial");
    			set_style(div0, "width", "32px");
    			add_location(div0, file$s, 26, 2, 531);
    			attr_dev(span, "class", "svelte-rybc7e");
    			add_location(span, file$s, 29, 12, 779);
    			attr_dev(div1, "flex", "");
    			add_location(div1, file$s, 29, 2, 769);
    			attr_dev(div2, "layout", "row");
    			attr_dev(div2, "type", "quick-entry");
    			attr_dev(div2, "class", "svelte-rybc7e");
    			add_location(div2, file$s, 25, 0, 475);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, svg);
    			append_dev(svg, path);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, span);
    			append_dev(span, t1);
    			if (remount) dispose();

    			dispose = listen_dev(
    				div2,
    				"click",
    				function () {
    					if (is_function(/*edit*/ ctx[1])) /*edit*/ ctx[1].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			if (dirty & /*stubPlaceholder*/ 1) set_data_dev(t1, /*stubPlaceholder*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	var dispatch, edit;
    	dispatch = createEventDispatcher();
    	var { stubPlaceholder = "item" } = $$props;

    	edit = function () {
    		return dispatch("edit");
    	};

    	const writable_props = ["stubPlaceholder"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AddStub> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("AddStub", $$slots, []);

    	$$self.$set = $$props => {
    		if ("stubPlaceholder" in $$props) $$invalidate(0, stubPlaceholder = $$props.stubPlaceholder);
    	};

    	$$self.$capture_state = () => ({
    		dispatch,
    		edit,
    		createEventDispatcher,
    		stubPlaceholder
    	});

    	$$self.$inject_state = $$props => {
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("edit" in $$props) $$invalidate(1, edit = $$props.edit);
    		if ("stubPlaceholder" in $$props) $$invalidate(0, stubPlaceholder = $$props.stubPlaceholder);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [stubPlaceholder, edit];
    }

    class AddStub extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { stubPlaceholder: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AddStub",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get stubPlaceholder() {
    		throw new Error("<AddStub>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stubPlaceholder(value) {
    		throw new Error("<AddStub>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Form\TextArea\Autogrow.svelte generated by Svelte v3.22.2 */
    const file$t = "src\\svelte\\components\\Form\\TextArea\\Autogrow.svelte";

    function create_fragment$x(ctx) {
    	let textarea_1;
    	let textarea_1_class_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			textarea_1 = element("textarea");
    			attr_dev(textarea_1, "style", /*style*/ ctx[1]);
    			attr_dev(textarea_1, "class", textarea_1_class_value = "" + (null_to_empty(/*classes*/ ctx[2]) + " svelte-1jd6e52"));
    			attr_dev(textarea_1, "id", /*id*/ ctx[3]);
    			attr_dev(textarea_1, "placeholder", /*placeholder*/ ctx[4]);
    			add_location(textarea_1, file$t, 51, 0, 877);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, textarea_1, anchor);
    			/*textarea_1_binding*/ ctx[11](textarea_1);
    			set_input_value(textarea_1, /*value*/ ctx[0]);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(textarea_1, "input", /*textarea_1_input_handler*/ ctx[12]),
    				listen_dev(
    					textarea_1,
    					"change",
    					function () {
    						if (is_function(/*change*/ ctx[6])) /*change*/ ctx[6].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					textarea_1,
    					"keyup",
    					function () {
    						if (is_function(/*keyup*/ ctx[8])) /*keyup*/ ctx[8].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					textarea_1,
    					"input",
    					function () {
    						if (is_function(/*input*/ ctx[7])) /*input*/ ctx[7].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					textarea_1,
    					"blur",
    					function () {
    						if (is_function(/*blur*/ ctx[5])) /*blur*/ ctx[5].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (dirty & /*style*/ 2) {
    				attr_dev(textarea_1, "style", /*style*/ ctx[1]);
    			}

    			if (dirty & /*classes*/ 4 && textarea_1_class_value !== (textarea_1_class_value = "" + (null_to_empty(/*classes*/ ctx[2]) + " svelte-1jd6e52"))) {
    				attr_dev(textarea_1, "class", textarea_1_class_value);
    			}

    			if (dirty & /*id*/ 8) {
    				attr_dev(textarea_1, "id", /*id*/ ctx[3]);
    			}

    			if (dirty & /*placeholder*/ 16) {
    				attr_dev(textarea_1, "placeholder", /*placeholder*/ ctx[4]);
    			}

    			if (dirty & /*value*/ 1) {
    				set_input_value(textarea_1, /*value*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea_1);
    			/*textarea_1_binding*/ ctx[11](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	var blur, change, dispatch, input, keyup, textarea;
    	var { value = void 0 } = $$props;
    	var { style = void 0 } = $$props;
    	var { classes = void 0 } = $$props;
    	var { id = void 0 } = $$props;
    	var { placeholder = void 0 } = $$props;
    	dispatch = createEventDispatcher();
    	textarea = void 0;

    	change = function (e) {
    		$$invalidate(9, textarea.style.height = "", textarea); // /* Reset the height*/
    		return $$invalidate(9, textarea.style.height = textarea.scrollHeight + 40 + "px", textarea);
    	};

    	keyup = function (e) {
    		dispatch("keyup", value);
    		change();

    		if (e.keyCode === 27) {
    			return textarea.blur();
    		}
    	};

    	input = function (e) {
    		return dispatch("input", value);
    	};

    	blur = function (e) {
    		return dispatch("blur", value);
    	};

    	onMount(change);
    	const writable_props = ["value", "style", "classes", "id", "placeholder"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Autogrow> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Autogrow", $$slots, []);

    	function textarea_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(9, textarea = $$value);
    		});
    	}

    	function textarea_1_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("classes" in $$props) $$invalidate(2, classes = $$props.classes);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("placeholder" in $$props) $$invalidate(4, placeholder = $$props.placeholder);
    	};

    	$$self.$capture_state = () => ({
    		blur,
    		change,
    		dispatch,
    		input,
    		keyup,
    		textarea,
    		onMount,
    		createEventDispatcher,
    		value,
    		style,
    		classes,
    		id,
    		placeholder
    	});

    	$$self.$inject_state = $$props => {
    		if ("blur" in $$props) $$invalidate(5, blur = $$props.blur);
    		if ("change" in $$props) $$invalidate(6, change = $$props.change);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("input" in $$props) $$invalidate(7, input = $$props.input);
    		if ("keyup" in $$props) $$invalidate(8, keyup = $$props.keyup);
    		if ("textarea" in $$props) $$invalidate(9, textarea = $$props.textarea);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("classes" in $$props) $$invalidate(2, classes = $$props.classes);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("placeholder" in $$props) $$invalidate(4, placeholder = $$props.placeholder);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		style,
    		classes,
    		id,
    		placeholder,
    		blur,
    		change,
    		input,
    		keyup,
    		textarea,
    		dispatch,
    		textarea_1_binding,
    		textarea_1_input_handler
    	];
    }

    class Autogrow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
    			value: 0,
    			style: 1,
    			classes: 2,
    			id: 3,
    			placeholder: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Autogrow",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get value() {
    		throw new Error("<Autogrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Autogrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Autogrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Autogrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Autogrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Autogrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Autogrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Autogrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Autogrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Autogrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\QuickEntry\GenericItem.svelte generated by Svelte v3.22.2 */

    const { console: console_1$d } = globals;
    const file$u = "src\\svelte\\pages\\_Common\\QuickEntry\\GenericItem.svelte";

    // (77:0) {:else}
    function create_else_block$7(ctx) {
    	let div3;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let div1;
    	let button0;
    	let svg0;
    	let title;
    	let t1;
    	let line0;
    	let line1;
    	let t2;
    	let div2;
    	let button1;
    	let svg1;
    	let path0;
    	let path1;
    	let current;
    	let dispose;
    	const if_block_creators = [create_if_block_1$5, create_else_block_1$3];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*isTextArea*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t0 = space();
    			div1 = element("div");
    			button0 = element("button");
    			svg0 = svg_element("svg");
    			title = svg_element("title");
    			t1 = text("ionicons-v5-a");
    			line0 = svg_element("line");
    			line1 = svg_element("line");
    			t2 = space();
    			div2 = element("div");
    			button1 = element("button");
    			svg1 = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(div0, "flex", "");
    			add_location(div0, file$u, 79, 4, 1391);
    			add_location(title, file$u, 88, 93, 1874);
    			attr_dev(line0, "x1", "256");
    			attr_dev(line0, "y1", "112");
    			attr_dev(line0, "x2", "256");
    			attr_dev(line0, "y2", "400");
    			set_style(line0, "fill", "none");
    			set_style(line0, "stroke", "#000");
    			set_style(line0, "stroke-linecap", "round");
    			set_style(line0, "stroke-linejoin", "round");
    			set_style(line0, "stroke-width", "32px");
    			add_location(line0, file$u, 88, 121, 1902);
    			attr_dev(line1, "x1", "400");
    			attr_dev(line1, "y1", "256");
    			attr_dev(line1, "x2", "112");
    			attr_dev(line1, "y2", "256");
    			set_style(line1, "fill", "none");
    			set_style(line1, "stroke", "#000");
    			set_style(line1, "stroke-linecap", "round");
    			set_style(line1, "stroke-linejoin", "round");
    			set_style(line1, "stroke-width", "32px");
    			add_location(line1, file$u, 88, 255, 2036);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 512 512");
    			add_location(svg0, file$u, 88, 8, 1789);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "icon", "");
    			button0.disabled = /*invalid*/ ctx[11];
    			add_location(button0, file$u, 87, 6, 1718);
    			attr_dev(div1, "flex", "initial");
    			add_location(div1, file$u, 86, 4, 1690);
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$u, 93, 91, 2377);
    			attr_dev(path1, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z");
    			add_location(path1, file$u, 93, 130, 2416);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			add_location(svg1, file$u, 93, 8, 2294);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "icon", "");
    			add_location(button1, file$u, 92, 6, 2239);
    			attr_dev(div2, "flex", "initial");
    			add_location(div2, file$u, 91, 4, 2211);
    			attr_dev(div3, "layout", "row");
    			add_location(div3, file$u, 77, 2, 1365);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div3, t0);
    			append_dev(div3, div1);
    			append_dev(div1, button0);
    			append_dev(button0, svg0);
    			append_dev(svg0, title);
    			append_dev(title, t1);
    			append_dev(svg0, line0);
    			append_dev(svg0, line1);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, button1);
    			append_dev(button1, svg1);
    			append_dev(svg1, path0);
    			append_dev(svg1, path1);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					button0,
    					"click",
    					function () {
    						if (is_function(/*add*/ ctx[5])) /*add*/ ctx[5].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button1,
    					"click",
    					function () {
    						if (is_function(/*cancel*/ ctx[6])) /*cancel*/ ctx[6].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			if (!current || dirty & /*invalid*/ 2048) {
    				prop_dev(button0, "disabled", /*invalid*/ ctx[11]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if_blocks[current_block_type_index].d();
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(77:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (75:0) {#if !showForm}
    function create_if_block$e(ctx) {
    	let current;

    	const addstub = new AddStub({
    			props: {
    				stubPlaceholder: /*stubPlaceholder*/ ctx[1]
    			},
    			$$inline: true
    		});

    	addstub.$on("edit", function () {
    		if (is_function(/*edit*/ ctx[7])) /*edit*/ ctx[7].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(addstub.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(addstub, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const addstub_changes = {};
    			if (dirty & /*stubPlaceholder*/ 2) addstub_changes.stubPlaceholder = /*stubPlaceholder*/ ctx[1];
    			addstub.$set(addstub_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(addstub.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(addstub.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(addstub, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(75:0) {#if !showForm}",
    		ctx
    	});

    	return block;
    }

    // (83:6) {:else}
    function create_else_block_1$3(ctx) {
    	let input;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
    			input.autofocus = true;
    			add_location(input, file$u, 83, 8, 1569);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*stub*/ ctx[9][/*attribute*/ ctx[3]]);
    			input.focus();
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(input, "input", /*input_input_handler*/ ctx[16]),
    				listen_dev(
    					input,
    					"keyup",
    					function () {
    						if (is_function(/*keyup*/ ctx[8])) /*keyup*/ ctx[8].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*placeholder*/ 4) {
    				attr_dev(input, "placeholder", /*placeholder*/ ctx[2]);
    			}

    			if (dirty & /*stub, attribute*/ 520 && input.value !== /*stub*/ ctx[9][/*attribute*/ ctx[3]]) {
    				set_input_value(input, /*stub*/ ctx[9][/*attribute*/ ctx[3]]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(83:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (81:6) {#if isTextArea}
    function create_if_block_1$5(ctx) {
    	let updating_value;
    	let current;

    	function autogrow_value_binding(value) {
    		/*autogrow_value_binding*/ ctx[15].call(null, value);
    	}

    	let autogrow_props = {
    		placeholder: /*placeholder*/ ctx[2],
    		autofocus: true,
    		style: "width: 100%"
    	};

    	if (/*stub*/ ctx[9][/*attribute*/ ctx[3]] !== void 0) {
    		autogrow_props.value = /*stub*/ ctx[9][/*attribute*/ ctx[3]];
    	}

    	const autogrow = new Autogrow({ props: autogrow_props, $$inline: true });
    	binding_callbacks.push(() => bind(autogrow, "value", autogrow_value_binding));

    	autogrow.$on("keyup", function () {
    		if (is_function(/*textareakeyup*/ ctx[10])) /*textareakeyup*/ ctx[10].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(autogrow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(autogrow, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const autogrow_changes = {};
    			if (dirty & /*placeholder*/ 4) autogrow_changes.placeholder = /*placeholder*/ ctx[2];

    			if (!updating_value && dirty & /*stub, attribute*/ 520) {
    				updating_value = true;
    				autogrow_changes.value = /*stub*/ ctx[9][/*attribute*/ ctx[3]];
    				add_flush_callback(() => updating_value = false);
    			}

    			autogrow.$set(autogrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(autogrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(autogrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(autogrow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(81:6) {#if isTextArea}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$e, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*showForm*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	var add, cancel, dispatch, edit, keyup, resetStub, stub, textareakeyup, validate;
    	dispatch = createEventDispatcher();
    	var { showForm = false } = $$props;
    	var { stubPlaceholder = "Add item" } = $$props;
    	var { placeholder = "Enter name here." } = $$props;
    	var { attribute = "name" } = $$props;
    	var { isTextArea = false } = $$props;
    	stub = {};
    	stub[attribute] = "";

    	resetStub = function () {
    		return $$invalidate(9, stub[attribute] = "", stub);
    	};

    	edit = function () {
    		return $$invalidate(0, showForm = true);
    	};

    	cancel = function () {
    		return $$invalidate(0, showForm = false);
    	};

    	add = function () {
    		console.log("add click");

    		if (stub[attribute] != null) {
    			if (stub[attribute].length > 0) {
    				dispatch("add", stub);
    				return resetStub();
    			}
    		}
    	};

    	validate = function (val) {
    		if (val != null) {
    			return val.length > 0;
    		} else {
    			return false;
    		}
    	};

    	keyup = function (e) {
    		if (e.key === "Return" || e.key === "Enter") {
    			add();
    		}

    		if (e.key === "Escape") {
    			return cancel();
    		}
    	};

    	textareakeyup = function (e) {
    		if (e.detail.key === "Escape") {
    			return cancel();
    		}
    	};

    	const writable_props = ["showForm", "stubPlaceholder", "placeholder", "attribute", "isTextArea"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$d.warn(`<GenericItem> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GenericItem", $$slots, []);

    	function autogrow_value_binding(value) {
    		stub[attribute] = value;
    		$$invalidate(9, stub);
    	}

    	function input_input_handler() {
    		stub[attribute] = this.value;
    		$$invalidate(9, stub);
    		$$invalidate(3, attribute);
    	}

    	$$self.$set = $$props => {
    		if ("showForm" in $$props) $$invalidate(0, showForm = $$props.showForm);
    		if ("stubPlaceholder" in $$props) $$invalidate(1, stubPlaceholder = $$props.stubPlaceholder);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("attribute" in $$props) $$invalidate(3, attribute = $$props.attribute);
    		if ("isTextArea" in $$props) $$invalidate(4, isTextArea = $$props.isTextArea);
    	};

    	$$self.$capture_state = () => ({
    		add,
    		cancel,
    		dispatch,
    		edit,
    		keyup,
    		resetStub,
    		stub,
    		textareakeyup,
    		validate,
    		AddStub,
    		createEventDispatcher,
    		showForm,
    		stubPlaceholder,
    		placeholder,
    		attribute,
    		isTextArea,
    		Autogrow,
    		invalid
    	});

    	$$self.$inject_state = $$props => {
    		if ("add" in $$props) $$invalidate(5, add = $$props.add);
    		if ("cancel" in $$props) $$invalidate(6, cancel = $$props.cancel);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("edit" in $$props) $$invalidate(7, edit = $$props.edit);
    		if ("keyup" in $$props) $$invalidate(8, keyup = $$props.keyup);
    		if ("resetStub" in $$props) resetStub = $$props.resetStub;
    		if ("stub" in $$props) $$invalidate(9, stub = $$props.stub);
    		if ("textareakeyup" in $$props) $$invalidate(10, textareakeyup = $$props.textareakeyup);
    		if ("validate" in $$props) $$invalidate(14, validate = $$props.validate);
    		if ("showForm" in $$props) $$invalidate(0, showForm = $$props.showForm);
    		if ("stubPlaceholder" in $$props) $$invalidate(1, stubPlaceholder = $$props.stubPlaceholder);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$props.placeholder);
    		if ("attribute" in $$props) $$invalidate(3, attribute = $$props.attribute);
    		if ("isTextArea" in $$props) $$invalidate(4, isTextArea = $$props.isTextArea);
    		if ("invalid" in $$props) $$invalidate(11, invalid = $$props.invalid);
    	};

    	let invalid;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*validate, stub, attribute*/ 16904) {
    			 $$invalidate(11, invalid = !validate(stub[attribute]));
    		}
    	};

    	return [
    		showForm,
    		stubPlaceholder,
    		placeholder,
    		attribute,
    		isTextArea,
    		add,
    		cancel,
    		edit,
    		keyup,
    		stub,
    		textareakeyup,
    		invalid,
    		dispatch,
    		resetStub,
    		validate,
    		autogrow_value_binding,
    		input_input_handler
    	];
    }

    class GenericItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
    			showForm: 0,
    			stubPlaceholder: 1,
    			placeholder: 2,
    			attribute: 3,
    			isTextArea: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GenericItem",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get showForm() {
    		throw new Error("<GenericItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showForm(value) {
    		throw new Error("<GenericItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stubPlaceholder() {
    		throw new Error("<GenericItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stubPlaceholder(value) {
    		throw new Error("<GenericItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<GenericItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<GenericItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get attribute() {
    		throw new Error("<GenericItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set attribute(value) {
    		throw new Error("<GenericItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isTextArea() {
    		throw new Error("<GenericItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isTextArea(value) {
    		throw new Error("<GenericItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Menus\SubDocument.svelte generated by Svelte v3.22.2 */

    const { console: console_1$e } = globals;
    const file$v = "src\\svelte\\pages\\_Common\\Menus\\SubDocument.svelte";

    // (90:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align="right" {width}>
    function create_default_slot$a(ctx) {
    	let ul;
    	let li;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li = element("li");
    			button = element("button");
    			button.textContent = "Delete Item";
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "svelte-t4jhcr");
    			add_location(button, file$v, 94, 6, 2455);
    			attr_dev(li, "class", "svelte-t4jhcr");
    			add_location(li, file$v, 93, 4, 2444);
    			attr_dev(ul, "class", "svelte-t4jhcr");
    			add_location(ul, file$v, 90, 2, 2433);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li);
    			append_dev(li, button);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*deleteConfirmation*/ ctx[0])) /*deleteConfirmation*/ ctx[0].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(90:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align=\\\"right\\\" {width}>",
    		ctx
    	});

    	return block;
    }

    // (99:0) {#if showDeleteConfirmation}
    function create_if_block$f(ctx) {
    	let current;
    	const deleteconfirmation = new DeleteConfirmation({ $$inline: true });

    	deleteconfirmation.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[2])) /*destroy*/ ctx[2].apply(this, arguments);
    	});

    	deleteconfirmation.$on("cancel", function () {
    		if (is_function(/*deleteConfirmationCancel*/ ctx[1])) /*deleteConfirmationCancel*/ ctx[1].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(deleteconfirmation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deleteconfirmation, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteconfirmation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteconfirmation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deleteconfirmation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(99:0) {#if showDeleteConfirmation}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let button;
    	let svg;
    	let path;
    	let t0;
    	let updating_showMenu;
    	let t1;
    	let if_block_anchor;
    	let current;
    	let dispose;

    	function menu_showMenu_binding(value) {
    		/*menu_showMenu_binding*/ ctx[13].call(null, value);
    	}

    	let menu_props = {
    		trigger: /*menuButtonRef*/ ctx[3],
    		align: "right",
    		width: /*width*/ ctx[7],
    		$$slots: { default: [create_default_slot$a] },
    		$$scope: { ctx }
    	};

    	if (/*showMenu*/ ctx[6] !== void 0) {
    		menu_props.showMenu = /*showMenu*/ ctx[6];
    	}

    	const menu = new ComposedMenu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "showMenu", menu_showMenu_binding));
    	let if_block = /*showDeleteConfirmation*/ ctx[5] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t0 = space();
    			create_component(menu.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(path, "d", "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z");
    			add_location(path, file$v, 87, 112, 2118);
    			attr_dev(svg, "class", "menu");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$v, 87, 2, 2008);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$v, 86, 0, 1932);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			/*button_binding*/ ctx[12](button);
    			insert_dev(target, t0, anchor);
    			mount_component(menu, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*openMenu*/ ctx[4])) /*openMenu*/ ctx[4].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const menu_changes = {};
    			if (dirty & /*menuButtonRef*/ 8) menu_changes.trigger = /*menuButtonRef*/ ctx[3];
    			if (dirty & /*width*/ 128) menu_changes.width = /*width*/ ctx[7];

    			if (dirty & /*$$scope, deleteConfirmation*/ 16385) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_showMenu && dirty & /*showMenu*/ 64) {
    				updating_showMenu = true;
    				menu_changes.showMenu = /*showMenu*/ ctx[6];
    				add_flush_callback(() => updating_showMenu = false);
    			}

    			menu.$set(menu_changes);

    			if (/*showDeleteConfirmation*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showDeleteConfirmation*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			/*button_binding*/ ctx[12](null);
    			if (detaching) detach_dev(t0);
    			destroy_component(menu, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	var closeMenu,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		indent,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	menuButtonRef = void 0;
    	showMenu = false;

    	openMenu = function () {
    		return $$invalidate(6, showMenu = true);
    	};

    	closeMenu = function () {
    		return $$invalidate(6, showMenu = false);
    	};

    	width = "189px";

    	destroy = function () {
    		dispatch("destroy", item);
    		return closeMenu();
    	};

    	indent = function (indentLevel) {
    		console.log("indent");
    		dispatch("update", { id: item.id, indent: indentLevel });
    		return closeMenu();
    	};

    	showDeleteConfirmation = false;

    	deleteConfirmation = function () {
    		closeMenu();
    		return $$invalidate(5, showDeleteConfirmation = true);
    	};

    	deleteConfirmationCancel = function () {
    		return $$invalidate(5, showDeleteConfirmation = false);
    	};

    	destroy = function () {
    		dispatch("destroy", item);
    		return $$invalidate(5, showDeleteConfirmation = false);
    	};

    	const writable_props = ["item"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$e.warn(`<SubDocument> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SubDocument", $$slots, []);

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(3, menuButtonRef = $$value);
    		});
    	}

    	function menu_showMenu_binding(value) {
    		showMenu = value;
    		$$invalidate(6, showMenu);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(8, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({
    		closeMenu,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		indent,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width,
    		createEventDispatcher,
    		Menu: ComposedMenu,
    		DeleteConfirmation,
    		item
    	});

    	$$self.$inject_state = $$props => {
    		if ("closeMenu" in $$props) closeMenu = $$props.closeMenu;
    		if ("deleteConfirmation" in $$props) $$invalidate(0, deleteConfirmation = $$props.deleteConfirmation);
    		if ("deleteConfirmationCancel" in $$props) $$invalidate(1, deleteConfirmationCancel = $$props.deleteConfirmationCancel);
    		if ("destroy" in $$props) $$invalidate(2, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("indent" in $$props) indent = $$props.indent;
    		if ("menuButtonRef" in $$props) $$invalidate(3, menuButtonRef = $$props.menuButtonRef);
    		if ("openMenu" in $$props) $$invalidate(4, openMenu = $$props.openMenu);
    		if ("showDeleteConfirmation" in $$props) $$invalidate(5, showDeleteConfirmation = $$props.showDeleteConfirmation);
    		if ("showMenu" in $$props) $$invalidate(6, showMenu = $$props.showMenu);
    		if ("width" in $$props) $$invalidate(7, width = $$props.width);
    		if ("item" in $$props) $$invalidate(8, item = $$props.item);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width,
    		item,
    		closeMenu,
    		dispatch,
    		indent,
    		button_binding,
    		menu_showMenu_binding
    	];
    }

    class SubDocument extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { item: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SubDocument",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get item() {
    		throw new Error("<SubDocument>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<SubDocument>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var crypt = createCommonjsModule(function (module) {
    (function() {
      var base64map
          = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

      crypt = {
        // Bit-wise rotation left
        rotl: function(n, b) {
          return (n << b) | (n >>> (32 - b));
        },

        // Bit-wise rotation right
        rotr: function(n, b) {
          return (n << (32 - b)) | (n >>> b);
        },

        // Swap big-endian to little-endian and vice versa
        endian: function(n) {
          // If number given, swap endian
          if (n.constructor == Number) {
            return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
          }

          // Else, assume array and swap all items
          for (var i = 0; i < n.length; i++)
            n[i] = crypt.endian(n[i]);
          return n;
        },

        // Generate an array of any length of random bytes
        randomBytes: function(n) {
          for (var bytes = []; n > 0; n--)
            bytes.push(Math.floor(Math.random() * 256));
          return bytes;
        },

        // Convert a byte array to big-endian 32-bit words
        bytesToWords: function(bytes) {
          for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
            words[b >>> 5] |= bytes[i] << (24 - b % 32);
          return words;
        },

        // Convert big-endian 32-bit words to a byte array
        wordsToBytes: function(words) {
          for (var bytes = [], b = 0; b < words.length * 32; b += 8)
            bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
          return bytes;
        },

        // Convert a byte array to a hex string
        bytesToHex: function(bytes) {
          for (var hex = [], i = 0; i < bytes.length; i++) {
            hex.push((bytes[i] >>> 4).toString(16));
            hex.push((bytes[i] & 0xF).toString(16));
          }
          return hex.join('');
        },

        // Convert a hex string to a byte array
        hexToBytes: function(hex) {
          for (var bytes = [], c = 0; c < hex.length; c += 2)
            bytes.push(parseInt(hex.substr(c, 2), 16));
          return bytes;
        },

        // Convert a byte array to a base-64 string
        bytesToBase64: function(bytes) {
          for (var base64 = [], i = 0; i < bytes.length; i += 3) {
            var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
            for (var j = 0; j < 4; j++)
              if (i * 8 + j * 6 <= bytes.length * 8)
                base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
              else
                base64.push('=');
          }
          return base64.join('');
        },

        // Convert a base-64 string to a byte array
        base64ToBytes: function(base64) {
          // Remove non-base-64 characters
          base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

          for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
              imod4 = ++i % 4) {
            if (imod4 == 0) continue;
            bytes.push(((base64map.indexOf(base64.charAt(i - 1))
                & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
                | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
          }
          return bytes;
        }
      };

      module.exports = crypt;
    })();
    });

    var charenc = {
      // UTF-8 encoding
      utf8: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
        },

        // Convert a byte array to a string
        bytesToString: function(bytes) {
          return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
        }
      },

      // Binary encoding
      bin: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          for (var bytes = [], i = 0; i < str.length; i++)
            bytes.push(str.charCodeAt(i) & 0xFF);
          return bytes;
        },

        // Convert a byte array to a string
        bytesToString: function(bytes) {
          for (var str = [], i = 0; i < bytes.length; i++)
            str.push(String.fromCharCode(bytes[i]));
          return str.join('');
        }
      }
    };

    var charenc_1 = charenc;

    /*!
     * Determine if an object is a Buffer
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */

    // The _isBuffer check is for Safari 5-7 support, because it's missing
    // Object.prototype.constructor. Remove this eventually
    var isBuffer_1 = function (obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
    };

    function isBuffer (obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
    }

    // For Node v0.10 support. Remove this eventually.
    function isSlowBuffer (obj) {
      return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
    }

    var md5 = createCommonjsModule(function (module) {
    (function(){
      var crypt$1 = crypt,
          utf8 = charenc_1.utf8,
          isBuffer = isBuffer_1,
          bin = charenc_1.bin,

      // The core
      md5 = function (message, options) {
        // Convert to byte array
        if (message.constructor == String)
          if (options && options.encoding === 'binary')
            message = bin.stringToBytes(message);
          else
            message = utf8.stringToBytes(message);
        else if (isBuffer(message))
          message = Array.prototype.slice.call(message, 0);
        else if (!Array.isArray(message))
          message = message.toString();
        // else, assume byte array already

        var m = crypt$1.bytesToWords(message),
            l = message.length * 8,
            a =  1732584193,
            b = -271733879,
            c = -1732584194,
            d =  271733878;

        // Swap endian
        for (var i = 0; i < m.length; i++) {
          m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
                 ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
        }

        // Padding
        m[l >>> 5] |= 0x80 << (l % 32);
        m[(((l + 64) >>> 9) << 4) + 14] = l;

        // Method shortcuts
        var FF = md5._ff,
            GG = md5._gg,
            HH = md5._hh,
            II = md5._ii;

        for (var i = 0; i < m.length; i += 16) {

          var aa = a,
              bb = b,
              cc = c,
              dd = d;

          a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
          d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
          c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
          b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
          a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
          d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
          c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
          b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
          a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
          d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
          c = FF(c, d, a, b, m[i+10], 17, -42063);
          b = FF(b, c, d, a, m[i+11], 22, -1990404162);
          a = FF(a, b, c, d, m[i+12],  7,  1804603682);
          d = FF(d, a, b, c, m[i+13], 12, -40341101);
          c = FF(c, d, a, b, m[i+14], 17, -1502002290);
          b = FF(b, c, d, a, m[i+15], 22,  1236535329);

          a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
          d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
          c = GG(c, d, a, b, m[i+11], 14,  643717713);
          b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
          a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
          d = GG(d, a, b, c, m[i+10],  9,  38016083);
          c = GG(c, d, a, b, m[i+15], 14, -660478335);
          b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
          a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
          d = GG(d, a, b, c, m[i+14],  9, -1019803690);
          c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
          b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
          a = GG(a, b, c, d, m[i+13],  5, -1444681467);
          d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
          c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
          b = GG(b, c, d, a, m[i+12], 20, -1926607734);

          a = HH(a, b, c, d, m[i+ 5],  4, -378558);
          d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
          c = HH(c, d, a, b, m[i+11], 16,  1839030562);
          b = HH(b, c, d, a, m[i+14], 23, -35309556);
          a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
          d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
          c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
          b = HH(b, c, d, a, m[i+10], 23, -1094730640);
          a = HH(a, b, c, d, m[i+13],  4,  681279174);
          d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
          c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
          b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
          a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
          d = HH(d, a, b, c, m[i+12], 11, -421815835);
          c = HH(c, d, a, b, m[i+15], 16,  530742520);
          b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

          a = II(a, b, c, d, m[i+ 0],  6, -198630844);
          d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
          c = II(c, d, a, b, m[i+14], 15, -1416354905);
          b = II(b, c, d, a, m[i+ 5], 21, -57434055);
          a = II(a, b, c, d, m[i+12],  6,  1700485571);
          d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
          c = II(c, d, a, b, m[i+10], 15, -1051523);
          b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
          a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
          d = II(d, a, b, c, m[i+15], 10, -30611744);
          c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
          b = II(b, c, d, a, m[i+13], 21,  1309151649);
          a = II(a, b, c, d, m[i+ 4],  6, -145523070);
          d = II(d, a, b, c, m[i+11], 10, -1120210379);
          c = II(c, d, a, b, m[i+ 2], 15,  718787259);
          b = II(b, c, d, a, m[i+ 9], 21, -343485551);

          a = (a + aa) >>> 0;
          b = (b + bb) >>> 0;
          c = (c + cc) >>> 0;
          d = (d + dd) >>> 0;
        }

        return crypt$1.endian([a, b, c, d]);
      };

      // Auxiliary functions
      md5._ff  = function (a, b, c, d, x, s, t) {
        var n = a + (b & c | ~b & d) + (x >>> 0) + t;
        return ((n << s) | (n >>> (32 - s))) + b;
      };
      md5._gg  = function (a, b, c, d, x, s, t) {
        var n = a + (b & d | c & ~d) + (x >>> 0) + t;
        return ((n << s) | (n >>> (32 - s))) + b;
      };
      md5._hh  = function (a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + (x >>> 0) + t;
        return ((n << s) | (n >>> (32 - s))) + b;
      };
      md5._ii  = function (a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
        return ((n << s) | (n >>> (32 - s))) + b;
      };

      // Package private blocksize
      md5._blocksize = 16;
      md5._digestsize = 16;

      module.exports = function (message, options) {
        if (message === undefined || message === null)
          throw new Error('Illegal argument ' + message);

        var digestbytes = crypt$1.wordsToBytes(md5(message, options));
        return options && options.asBytes ? digestbytes :
            options && options.asString ? bin.bytesToString(digestbytes) :
            crypt$1.bytesToHex(digestbytes);
      };

    })();
    });

    /* src\svelte\components\External\Gravatar\Gravatar.svelte generated by Svelte v3.22.2 */
    const file$w = "src\\svelte\\components\\External\\Gravatar\\Gravatar.svelte";

    function create_fragment$A(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "https://www.gravatar.com/avatar/" + /*hash*/ ctx[1] + "?s=" + /*size*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "gravatar");
    			add_location(img, file$w, 6, 0, 181);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*hash, size*/ 3 && img.src !== (img_src_value = "https://www.gravatar.com/avatar/" + /*hash*/ ctx[1] + "?s=" + /*size*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { size = "24" } = $$props;
    	let { value = undefined } = $$props;
    	const writable_props = ["size", "value"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Gravatar> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Gravatar", $$slots, []);

    	$$self.$set = $$props => {
    		if ("size" in $$props) $$invalidate(0, size = $$props.size);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({ md5, size, value, hash });

    	$$self.$inject_state = $$props => {
    		if ("size" in $$props) $$invalidate(0, size = $$props.size);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    		if ("hash" in $$props) $$invalidate(1, hash = $$props.hash);
    	};

    	let hash;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 4) {
    			 $$invalidate(1, hash = value == undefined
    			? "unknown"
    			: md5(value.trim().toLowerCase()));
    		}
    	};

    	return [size, hash, value];
    }

    class Gravatar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { size: 0, value: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Gravatar",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get size() {
    		throw new Error("<Gravatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Gravatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Gravatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Gravatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Popovers\Checklist.svelte generated by Svelte v3.22.2 */

    const { console: console_1$f } = globals;
    const file$x = "src\\svelte\\pages\\_Common\\Popovers\\Checklist.svelte";

    // (93:4) {:else}
    function create_else_block$8(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$x, 93, 89, 2190);
    			attr_dev(path1, "d", "M18 7l-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41L6 19l1.41-1.41L1.83 12 .41 13.41z");
    			attr_dev(path1, "class", "fill");
    			add_location(path1, file$x, 93, 128, 2229);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$x, 93, 6, 2107);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(93:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:31) 
    function create_if_block_1$6(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$x, 91, 89, 1951);
    			attr_dev(path1, "d", "M21 3H3v18h18V3zM10 17l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z");
    			attr_dev(path1, "class", "fill");
    			add_location(path1, file$x, 91, 128, 1990);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$x, 91, 6, 1868);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(91:31) ",
    		ctx
    	});

    	return block;
    }

    // (89:4) {#if state == "empty"}
    function create_if_block$g(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$x, 89, 89, 1729);
    			attr_dev(path1, "d", "M19 5v14H5V5h14m2-2H3v18h18V3z");
    			attr_dev(path1, "class", "fill");
    			add_location(path1, file$x, 89, 128, 1768);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$x, 89, 6, 1646);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(89:4) {#if state == \\\"empty\\\"}",
    		ctx
    	});

    	return block;
    }

    // (88:2) <Tooltip content={item.checklists.length}>
    function create_default_slot$b(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*state*/ ctx[1] == "empty") return create_if_block$g;
    		if (/*state*/ ctx[1] == "partial") return create_if_block_1$6;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(88:2) <Tooltip content={item.checklists.length}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div;
    	let current;

    	const tooltip = new Tooltip({
    			props: {
    				content: /*item*/ ctx[0].checklists.length,
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tooltip.$$.fragment);
    			add_location(div, file$x, 86, 0, 1562);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tooltip, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tooltip_changes = {};
    			if (dirty & /*item*/ 1) tooltip_changes.content = /*item*/ ctx[0].checklists.length;

    			if (dirty & /*$$scope, state*/ 8194) {
    				tooltip_changes.$$scope = { dirty, ctx };
    			}

    			tooltip.$set(tooltip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tooltip);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	var cancel,
    		clear,
    		dispatch,
    		markComplete,
    		newValue,
    		progressMenuClick,
    		save,
    		show,
    		state,
    		triggerClick,
    		triggerRef;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	var { value = 0 } = $$props;
    	newValue = void 0;

    	// menu
    	show = false;

    	triggerClick = function () {
    		dispatch("open");
    		return show = true;
    	};

    	triggerRef = void 0;

    	progressMenuClick = function (e) {
    		return console.log("progressmenuclick");
    	};

    	cancel = function () {
    		show = false;
    		dispatch("close");
    		return newValue = value;
    	};

    	save = function () {
    		show = false;
    		dispatch("close");
    		return dispatch("save", { id: item.id, assigned_to_id: newValue });
    	};

    	markComplete = function () {
    		return newValue = 100;
    	};

    	clear = function () {
    		return newValue = null;
    	};

    	switch (item.assigned_to_id) {
    		case null:
    			state = "empty";
    			break;
    		default:
    			state = "green";
    	}

    	const writable_props = ["item", "value"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$f.warn(`<Checklist> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Checklist", $$slots, []);

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		cancel,
    		clear,
    		dispatch,
    		markComplete,
    		newValue,
    		progressMenuClick,
    		save,
    		show,
    		state,
    		triggerClick,
    		triggerRef,
    		createEventDispatcher,
    		item,
    		value,
    		Popover,
    		Tooltip,
    		Gravatar
    	});

    	$$self.$inject_state = $$props => {
    		if ("cancel" in $$props) cancel = $$props.cancel;
    		if ("clear" in $$props) clear = $$props.clear;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("markComplete" in $$props) markComplete = $$props.markComplete;
    		if ("newValue" in $$props) newValue = $$props.newValue;
    		if ("progressMenuClick" in $$props) progressMenuClick = $$props.progressMenuClick;
    		if ("save" in $$props) save = $$props.save;
    		if ("show" in $$props) show = $$props.show;
    		if ("state" in $$props) $$invalidate(1, state = $$props.state);
    		if ("triggerClick" in $$props) triggerClick = $$props.triggerClick;
    		if ("triggerRef" in $$props) triggerRef = $$props.triggerRef;
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 4) {
    			//}
    			 newValue = value || 0;
    		}
    	};

    	return [item, state, value];
    }

    class Checklist$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { item: 0, value: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checklist",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get item() {
    		throw new Error("<Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Popovers\Comment.svelte generated by Svelte v3.22.2 */

    const { console: console_1$g } = globals;
    const file$y = "src\\svelte\\pages\\_Common\\Popovers\\Comment.svelte";

    // (88:2) <Tooltip content={item.comments.length} comments>
    function create_default_slot$c(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			attr_dev(path0, "fill", "none");
    			add_location(path0, file$y, 88, 87, 1705);
    			attr_dev(path1, "d", "M21.99 2H2v16h16l4 4-.01-20zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z");
    			add_location(path1, file$y, 88, 126, 1744);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "width", "24");
    			add_location(svg, file$y, 88, 4, 1622);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(88:2) <Tooltip content={item.comments.length} comments>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let div;
    	let current;

    	const tooltip = new Tooltip({
    			props: {
    				content: /*item*/ ctx[0].comments.length,
    				comments: true,
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tooltip.$$.fragment);
    			add_location(div, file$y, 86, 0, 1560);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tooltip, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tooltip_changes = {};
    			if (dirty & /*item*/ 1) tooltip_changes.content = /*item*/ ctx[0].comments.length;

    			if (dirty & /*$$scope*/ 8192) {
    				tooltip_changes.$$scope = { dirty, ctx };
    			}

    			tooltip.$set(tooltip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tooltip);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	var cancel,
    		clear,
    		dispatch,
    		markComplete,
    		newValue,
    		progressMenuClick,
    		save,
    		show,
    		state,
    		triggerClick,
    		triggerRef;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	var { value = 0 } = $$props;
    	newValue = void 0;

    	// menu
    	show = false;

    	triggerClick = function () {
    		dispatch("open");
    		return show = true;
    	};

    	triggerRef = void 0;

    	progressMenuClick = function (e) {
    		return console.log("progressmenuclick");
    	};

    	cancel = function () {
    		show = false;
    		dispatch("close");
    		return newValue = value;
    	};

    	save = function () {
    		show = false;
    		dispatch("close");
    		return dispatch("save", { id: item.id, assigned_to_id: newValue });
    	};

    	markComplete = function () {
    		return newValue = 100;
    	};

    	clear = function () {
    		return newValue = null;
    	};

    	switch (item.assigned_to_id) {
    		case null:
    			state = "empty";
    			break;
    		default:
    			state = "green";
    	}

    	const writable_props = ["item", "value"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$g.warn(`<Comment> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Comment", $$slots, []);

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		cancel,
    		clear,
    		dispatch,
    		markComplete,
    		newValue,
    		progressMenuClick,
    		save,
    		show,
    		state,
    		triggerClick,
    		triggerRef,
    		createEventDispatcher,
    		item,
    		value,
    		Popover,
    		Tooltip,
    		Gravatar
    	});

    	$$self.$inject_state = $$props => {
    		if ("cancel" in $$props) cancel = $$props.cancel;
    		if ("clear" in $$props) clear = $$props.clear;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("markComplete" in $$props) markComplete = $$props.markComplete;
    		if ("newValue" in $$props) newValue = $$props.newValue;
    		if ("progressMenuClick" in $$props) progressMenuClick = $$props.progressMenuClick;
    		if ("save" in $$props) save = $$props.save;
    		if ("show" in $$props) show = $$props.show;
    		if ("state" in $$props) state = $$props.state;
    		if ("triggerClick" in $$props) triggerClick = $$props.triggerClick;
    		if ("triggerRef" in $$props) triggerRef = $$props.triggerRef;
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 2) {
    			//}
    			 newValue = value || 0;
    		}
    	};

    	return [item, value];
    }

    class Comment extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { item: 0, value: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Comment",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get item() {
    		throw new Error("<Comment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Comment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Comment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Comment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Content\Expandable.svelte generated by Svelte v3.22.2 */
    const file$z = "src\\svelte\\components\\Content\\Expandable.svelte";
    const get_default_slot_changes$1 = dirty => ({ open: dirty & /*open*/ 1 });
    const get_default_slot_context$1 = ctx => ({ open: /*open*/ ctx[0] });
    const get_header_slot_changes$1 = dirty => ({ open: dirty & /*open*/ 1 });
    const get_header_slot_context$1 = ctx => ({ open: /*open*/ ctx[0] });

    // (40:2) {#if open}
    function create_if_block$h(ctx) {
    	let div;
    	let div_transition;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$1);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			add_location(div, file$z, 40, 4, 717);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, open*/ 129) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$1), get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, get_default_slot_changes$1));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: /*transitionDuration*/ ctx[4] }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: /*transitionDuration*/ ctx[4] }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(40:2) {#if open}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let div;
    	let header;
    	let t;
    	let current;
    	let dispose;
    	const header_slot_template = /*$$slots*/ ctx[8].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[7], get_header_slot_context$1);
    	let if_block = /*open*/ ctx[0] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			header = element("header");
    			if (header_slot) header_slot.c();
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(header, "open", /*open*/ ctx[0]);
    			add_location(header, file$z, 38, 2, 631);
    			attr_dev(div, "expanded", /*open*/ ctx[0]);
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			attr_dev(div, "id", /*id*/ ctx[3]);
    			attr_dev(div, "class", /*classes*/ ctx[2]);
    			add_location(div, file$z, 37, 0, 578);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			append_dev(div, header);

    			if (header_slot) {
    				header_slot.m(header, null);
    			}

    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				header,
    				"click",
    				function () {
    					if (is_function(/*handleClick*/ ctx[5])) /*handleClick*/ ctx[5].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (header_slot) {
    				if (header_slot.p && dirty & /*$$scope, open*/ 129) {
    					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[7], get_header_slot_context$1), get_slot_changes(header_slot_template, /*$$scope*/ ctx[7], dirty, get_header_slot_changes$1));
    				}
    			}

    			if (!current || dirty & /*open*/ 1) {
    				attr_dev(header, "open", /*open*/ ctx[0]);
    			}

    			if (/*open*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*open*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*open*/ 1) {
    				attr_dev(div, "expanded", /*open*/ ctx[0]);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty & /*id*/ 8) {
    				attr_dev(div, "id", /*id*/ ctx[3]);
    			}

    			if (!current || dirty & /*classes*/ 4) {
    				attr_dev(div, "class", /*classes*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (header_slot) header_slot.d(detaching);
    			if (if_block) if_block.d();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	var handleClick;
    	var { open = true } = $$props;
    	var { headerClick = true } = $$props;
    	var { style = void 0 } = $$props;
    	var { classes = void 0 } = $$props;
    	var { id = void 0 } = $$props;
    	var { transitionDuration = 75 } = $$props;

    	handleClick = function (e) {
    		if (headerClick) {
    			return $$invalidate(0, open = !open);
    		}
    	};

    	const writable_props = ["open", "headerClick", "style", "classes", "id", "transitionDuration"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Expandable> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Expandable", $$slots, ['header','default']);

    	$$self.$set = $$props => {
    		if ("open" in $$props) $$invalidate(0, open = $$props.open);
    		if ("headerClick" in $$props) $$invalidate(6, headerClick = $$props.headerClick);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("classes" in $$props) $$invalidate(2, classes = $$props.classes);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("transitionDuration" in $$props) $$invalidate(4, transitionDuration = $$props.transitionDuration);
    		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		handleClick,
    		slide,
    		open,
    		headerClick,
    		style,
    		classes,
    		id,
    		transitionDuration
    	});

    	$$self.$inject_state = $$props => {
    		if ("handleClick" in $$props) $$invalidate(5, handleClick = $$props.handleClick);
    		if ("open" in $$props) $$invalidate(0, open = $$props.open);
    		if ("headerClick" in $$props) $$invalidate(6, headerClick = $$props.headerClick);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("classes" in $$props) $$invalidate(2, classes = $$props.classes);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("transitionDuration" in $$props) $$invalidate(4, transitionDuration = $$props.transitionDuration);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		open,
    		style,
    		classes,
    		id,
    		transitionDuration,
    		handleClick,
    		headerClick,
    		$$scope,
    		$$slots
    	];
    }

    class Expandable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {
    			open: 0,
    			headerClick: 6,
    			style: 1,
    			classes: 2,
    			id: 3,
    			transitionDuration: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Expandable",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get open() {
    		throw new Error("<Expandable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<Expandable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get headerClick() {
    		throw new Error("<Expandable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set headerClick(value) {
    		throw new Error("<Expandable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Expandable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Expandable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classes() {
    		throw new Error("<Expandable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classes(value) {
    		throw new Error("<Expandable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Expandable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Expandable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transitionDuration() {
    		throw new Error("<Expandable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transitionDuration(value) {
    		throw new Error("<Expandable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Sections\_Section.svelte generated by Svelte v3.22.2 */
    const file$A = "src\\svelte\\pages\\_Common\\Sections\\_Section.svelte";

    // (49:15) {:else}
    function create_else_block$9(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14l-6-6z");
    			attr_dev(path, "class", "fill svelte-1mye1au");
    			add_location(path, file$A, 49, 16, 1675);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(49:15) {:else}",
    		ctx
    	});

    	return block;
    }

    // (47:14) {#if open}
    function create_if_block_1$7(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z");
    			attr_dev(path, "class", "fill svelte-1mye1au");
    			add_location(path, file$A, 47, 16, 1556);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(47:14) {#if open}",
    		ctx
    	});

    	return block;
    }

    // (56:57) {#if !open}
    function create_if_block$i(ctx) {
    	let span;
    	let t;
    	let span_open_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text("…");
    			attr_dev(span, "open", span_open_value = /*open*/ ctx[0]);
    			attr_dev(span, "class", "svelte-1mye1au");
    			add_location(span, file$A, 55, 68, 1898);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    			if (remount) dispose();

    			dispose = listen_dev(
    				span,
    				"click",
    				function () {
    					if (is_function(/*toggleOpen*/ ctx[2])) /*toggleOpen*/ ctx[2].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*open*/ 1 && span_open_value !== (span_open_value = /*open*/ ctx[0])) {
    				attr_dev(span, "open", span_open_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(56:57) {#if !open}",
    		ctx
    	});

    	return block;
    }

    // (42:4) <header slot="header" let:open>
    function create_header_slot$1(ctx) {
    	let header;
    	let div2;
    	let div0;
    	let button;
    	let svg;
    	let path;
    	let t0;
    	let div1;
    	let h1;
    	let t1;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*open*/ ctx[0]) return create_if_block_1$7;
    		return create_else_block$9;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = !/*open*/ ctx[0] && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			header = element("header");
    			div2 = element("div");
    			div0 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if_block0.c();
    			t0 = space();
    			div1 = element("div");
    			h1 = element("h1");
    			t1 = text(/*name*/ ctx[1]);
    			if (if_block1) if_block1.c();
    			attr_dev(path, "fill", "none");
    			attr_dev(path, "d", "M0 0h24v24H0V0z");
    			add_location(path, file$A, 45, 95, 1475);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "28");
    			attr_dev(svg, "height", "28");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$A, 45, 12, 1392);
    			attr_dev(button, "type", "icon");
    			add_location(button, file$A, 44, 10, 1336);
    			attr_dev(div0, "flex", "initial");
    			attr_dev(div0, "toggle", "");
    			attr_dev(div0, "class", "svelte-1mye1au");
    			add_location(div0, file$A, 43, 8, 1298);
    			attr_dev(h1, "ellipsis", "");
    			attr_dev(h1, "class", "svelte-1mye1au");
    			add_location(h1, file$A, 55, 38, 1868);
    			set_style(div1, "overflow", "hidden");
    			add_location(div1, file$A, 55, 8, 1838);
    			attr_dev(div2, "layout", "row");
    			attr_dev(div2, "class", "svelte-1mye1au");
    			add_location(div2, file$A, 42, 6, 1271);
    			attr_dev(header, "slot", "header");
    			attr_dev(header, "class", "svelte-1mye1au");
    			add_location(header, file$A, 41, 4, 1233);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, header, anchor);
    			append_dev(header, div2);
    			append_dev(div2, div0);
    			append_dev(div0, button);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			if_block0.m(svg, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, h1);
    			append_dev(h1, t1);
    			if (if_block1) if_block1.m(h1, null);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*toggleOpen*/ ctx[2])) /*toggleOpen*/ ctx[2].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(svg, null);
    				}
    			}

    			if (dirty & /*name*/ 2) set_data_dev(t1, /*name*/ ctx[1]);

    			if (!/*open*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$i(ctx);
    					if_block1.c();
    					if_block1.m(h1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot$1.name,
    		type: "slot",
    		source: "(42:4) <header slot=\\\"header\\\" let:open>",
    		ctx
    	});

    	return block;
    }

    // (41:2) <Expandable bind:open={open} headerClick={false}>
    function create_default_slot$d(ctx) {
    	let t;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			t = space();
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 64) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[6], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(41:2) <Expandable bind:open={open} headerClick={false}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let section;
    	let updating_open;
    	let current;

    	function expandable_open_binding(value) {
    		/*expandable_open_binding*/ ctx[5].call(null, value);
    	}

    	let expandable_props = {
    		headerClick: false,
    		$$slots: {
    			default: [create_default_slot$d],
    			header: [
    				create_header_slot$1,
    				({ open }) => ({ 0: open }),
    				({ open }) => open ? 1 : 0
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*open*/ ctx[0] !== void 0) {
    		expandable_props.open = /*open*/ ctx[0];
    	}

    	const expandable = new Expandable({ props: expandable_props, $$inline: true });
    	binding_callbacks.push(() => bind(expandable, "open", expandable_open_binding));

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(expandable.$$.fragment);
    			attr_dev(section, "type", "group");
    			attr_dev(section, "class", "svelte-1mye1au");
    			add_location(section, file$A, 39, 0, 1154);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(expandable, section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const expandable_changes = {};

    			if (dirty & /*$$scope, open, toggleOpen, name*/ 71) {
    				expandable_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_open && dirty & /*open*/ 1) {
    				updating_open = true;
    				expandable_changes.open = /*open*/ ctx[0];
    				add_flush_callback(() => updating_open = false);
    			}

    			expandable.$set(expandable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(expandable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(expandable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(expandable);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	var toggleOpen;
    	var { list = void 0 } = $$props;
    	var { open = true } = $$props;
    	var { name = void 0 } = $$props;

    	toggleOpen = function () {
    		return $$invalidate(0, open = !open);
    	};

    	const writable_props = ["list", "open", "name"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Section> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Section", $$slots, ['default']);

    	function expandable_open_binding(value) {
    		open = value;
    		$$invalidate(0, open);
    	}

    	$$self.$set = $$props => {
    		if ("list" in $$props) $$invalidate(3, list = $$props.list);
    		if ("open" in $$props) $$invalidate(0, open = $$props.open);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ toggleOpen, Expandable, list, open, name });

    	$$self.$inject_state = $$props => {
    		if ("toggleOpen" in $$props) $$invalidate(2, toggleOpen = $$props.toggleOpen);
    		if ("list" in $$props) $$invalidate(3, list = $$props.list);
    		if ("open" in $$props) $$invalidate(0, open = $$props.open);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [open, name, toggleOpen, list, $$slots, expandable_open_binding, $$scope];
    }

    class Section extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, { list: 3, open: 0, name: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Section",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get list() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set list(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var SubDocument$1;

    SubDocument$1 = (function() {
      class SubDocument {
        model() {
          return {
            // if sourceversion < latest version, then some upgrades may be required
            // if null then return latest
            id: null,
            type: this.type,
            name: null,
            due_date: null,
            priority: null,
            is_favorite: false,
            is_locked: false,
            is_template: false,
            completion_date: null,
            estimate: null,
            progress: {
              percent_complete: 0,
              color: "light-gray"
            },
            ordinal: null,
            indent: 0,
            hierarchy: null,
            content: "",
            content_indexable: "",
            assigned_to: null,
            comments: [],
            time_entries: [],
            checklist_items: [],
            clips: [],
            attachments: [],
            created_at: null,
            updated_at: null,
            metadata: {
              icon: null,
              subtype: null
            },
            visits: 0,
            settings: {
              sections: {
                about: {
                  expanded: true,
                  enabled: true
                },
                checklist: {
                  expanded: true,
                  enabled: true
                },
                time_entries: {
                  expanded: true,
                  enabled: true
                },
                comments: {
                  expanded: true,
                  enabled: true
                },
                clips: {
                  expanded: true,
                  enabled: true
                },
                attachments: {
                  expanded: true,
                  enabled: true
                },
                settings: {
                  expanded: true
                }
              }
            }
          };
        }

        upgradeModel(item) {
          var latest;
          // check version
          //console.log "ugprade model..."
          latest = this.model();
          delete item.description;
          if (item.settings.sections == null) {
            //console.log "no sections found"
            item.settings["sections"] = latest.settings.sections; // get rid of obsolete
          } else {
            //console.log "should upgrade"
            if (item.settings.sections.description != null) {
              item.settings.sections["about"] = item.settings.sections.description;
              delete item.settings.sections.description;
            }
            if (item.settings.sections.details != null) {
              delete item.settings.sections.details;
            }
            if (item.settings.sections.settings == null) {
              item.settings.sections["settings"] = latest.settings.sections.settings;
            }
            // add enabled
            ["about", "checklist", "time_entries", "comments", "clips"].forEach(function(key) {
              return item.settings.sections[key]["enabled"] = true;
            });
          }
          if (item.metadata.subtype == null) {
            item.metadata["subtype"] = null; // used by assignment - undefined, person place thing etc.
          }
          if (item.metadata.icon == null) {
            item.metadata["icon"] = null; // used by assignment
          }
          if (item.metadata.gravatar == null) {
            item.metadata["gravatar"] = null; // used by assignment - if icon == 'gravatar', use default icon, otherwise store email address here
          }
          if (item.assigned_to == null) {
            item.assigned_to = [];
          }
          if (item.progress == null) {
            item["progress"] = {
              percent_complete: item.percent_complete,
              color: "gray"
            };
            delete item.percent_complete;
          }
          return item;
        }

        stub(override) {
          var base;
          base = this.model();
          base.id = uuid();
          base.name = `New ${this.type} created at ${Date.create().format('%Y-%m-%d %H:%M:%S')}`;
          base.created_at = Date.create();
          base.updated_at = Date.create();
          if (override != null) {
            return Object.merge(base, override, true);
          } else {
            return base;
          }
        }

        transformCollection(items) {
          var that;
          that = this;
          console.log(items);
          return items.map(function(item) {
            return that.transformModel(item);
          });
        }

        transformModel(item) {
          var base;
          base = this.model();
          base.id = item._id;
          return Object.merge(base, this.upgradeModel(item), true);
        }

        constructor(options) {
          this.after_construct();
        }

        after_construct() {}

      }
      SubDocument.prototype.name = "Resource Name";

      SubDocument.prototype.type = "resource";

      SubDocument.prototype.version = 1;

      return SubDocument;

    }).call(commonjsGlobal);

    var sub_document = SubDocument$1;

    var SubDocument$2, Task$1;

    SubDocument$2 = sub_document;

    Task$1 = (function() {
      class Task extends SubDocument$2 {}
      Task.prototype.name = "Task";

      Task.prototype.type = "task";

      return Task;

    }).call(commonjsGlobal);

    var task = Task$1;

    var Assignment$2, SubDocument$3;

    SubDocument$3 = sub_document;

    Assignment$2 = (function() {
      class Assignment extends SubDocument$3 {}
      Assignment.prototype.name = "Assignment";

      Assignment.prototype.type = "assignment";

      return Assignment;

    }).call(commonjsGlobal);

    var assignment = Assignment$2;

    var Document$1, SubDocument$4;

    SubDocument$4 = sub_document;

    Document$1 = (function() {
      class Document extends SubDocument$4 {}
      Document.prototype.name = "Document";

      Document.prototype.type = "document";

      return Document;

    }).call(commonjsGlobal);

    var document$1 = Document$1;

    /* src\svelte\pages\_Common\Sections\Home_SubDocumentList.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$4, console: console_1$h } = globals;
    const file$B = "src\\svelte\\pages\\_Common\\Sections\\Home_SubDocumentList.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[36] = list[i];
    	child_ctx[37] = list;
    	child_ctx[38] = i;
    	return child_ctx;
    }

    // (159:0) {#if mounted}
    function create_if_block$j(ctx) {
    	let section;
    	let current;
    	let each_value = /*list*/ ctx[10];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			section = element("section");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(section, file$B, 159, 2, 3519);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(section, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*findRawProject, project, list, updateChecklist, updateAttribute, showChecklist, style, goToItem, collection, showProgress*/ 1983 | dirty[1] & /*label*/ 256) {
    				each_value = /*list*/ ctx[10];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(section, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(159:0) {#if mounted}",
    		ctx
    	});

    	return block;
    }

    // (165:10) {#if showProgress}
    function create_if_block_4(ctx) {
    	let div;
    	let updating_value;
    	let current;

    	function progresspopover_value_binding(value) {
    		/*progresspopover_value_binding*/ ctx[22].call(null, value, /*listItem*/ ctx[36]);
    	}

    	let progresspopover_props = { item: /*listItem*/ ctx[36] };

    	if (/*listItem*/ ctx[36].progress !== void 0) {
    		progresspopover_props.value = /*listItem*/ ctx[36].progress;
    	}

    	const progresspopover = new Progress({
    			props: progresspopover_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(progresspopover, "value", progresspopover_value_binding));

    	progresspopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[8])) /*updateAttribute*/ ctx[8].apply(this, arguments);
    	});

    	progresspopover.$on("open", /*open_handler*/ ctx[23]);
    	progresspopover.$on("close", /*close_handler*/ ctx[24]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(progresspopover.$$.fragment);
    			attr_dev(div, "flex", "initial");
    			attr_dev(div, "section", "progress");
    			set_style(div, "padding-right", "8px");
    			add_location(div, file$B, 165, 12, 3658);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(progresspopover, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const progresspopover_changes = {};
    			if (dirty[0] & /*list*/ 1024) progresspopover_changes.item = /*listItem*/ ctx[36];

    			if (!updating_value && dirty[0] & /*list*/ 1024) {
    				updating_value = true;
    				progresspopover_changes.value = /*listItem*/ ctx[36].progress;
    				add_flush_callback(() => updating_value = false);
    			}

    			progresspopover.$set(progresspopover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(progresspopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(progresspopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(progresspopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(165:10) {#if showProgress}",
    		ctx
    	});

    	return block;
    }

    // (171:12) <InlineInput bind:value={listItem.name} on:update={updateAttribute({ detail: {id: listItem.id, name: listItem.name } })} on:clicked={goToItem(listItem)} {style} let:label>
    function create_default_slot$e(ctx) {
    	let span;
    	let a;
    	let em;
    	let t_value = (/*label*/ ctx[39] || "No Name") + "";
    	let t;
    	let a_href_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			a = element("a");
    			em = element("em");
    			t = text(t_value);
    			add_location(em, file$B, 171, 114, 4219);
    			attr_dev(a, "href", a_href_value = "#/projects/" + /*project*/ ctx[0].id + "/" + /*collection*/ ctx[3] + "/" + /*listItem*/ ctx[36].id);
    			add_location(a, file$B, 171, 29, 4134);
    			attr_dev(span, "ellipsis", "");
    			add_location(span, file$B, 171, 14, 4119);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, span, anchor);
    			append_dev(span, a);
    			append_dev(a, em);
    			append_dev(em, t);
    			if (remount) dispose();
    			dispose = listen_dev(a, "click", prevent_default(/*click_handler*/ ctx[21]), false, true, false);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*label*/ 256 && t_value !== (t_value = (/*label*/ ctx[39] || "No Name") + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*project, collection, list*/ 1033 && a_href_value !== (a_href_value = "#/projects/" + /*project*/ ctx[0].id + "/" + /*collection*/ ctx[3] + "/" + /*listItem*/ ctx[36].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(171:12) <InlineInput bind:value={listItem.name} on:update={updateAttribute({ detail: {id: listItem.id, name: listItem.name } })} on:clicked={goToItem(listItem)} {style} let:label>",
    		ctx
    	});

    	return block;
    }

    // (188:14) {#if showChecklist}
    function create_if_block_2$3(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = (/*listItem*/ ctx[36].checklists || []).length > 0 && create_if_block_3$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((/*listItem*/ ctx[36].checklists || []).length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*list*/ 1024) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(188:14) {#if showChecklist}",
    		ctx
    	});

    	return block;
    }

    // (189:16) {#if (listItem.checklists || []).length > 0}
    function create_if_block_3$2(ctx) {
    	let div;
    	let current;

    	const checklistpopover = new Checklist$1({
    			props: { item: /*listItem*/ ctx[36] },
    			$$inline: true
    		});

    	checklistpopover.$on("open", /*open_handler_3*/ ctx[30]);
    	checklistpopover.$on("close", /*close_handler_3*/ ctx[31]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(checklistpopover.$$.fragment);
    			attr_dev(div, "flex", "initial");
    			add_location(div, file$B, 189, 16, 4993);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(checklistpopover, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checklistpopover_changes = {};
    			if (dirty[0] & /*list*/ 1024) checklistpopover_changes.item = /*listItem*/ ctx[36];
    			checklistpopover.$set(checklistpopover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checklistpopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checklistpopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(checklistpopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(189:16) {#if (listItem.checklists || []).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (197:14) {#if (listItem.type != "assignment") && (project.assignments.length > 0)}
    function create_if_block_1$8(ctx) {
    	let div;
    	let updating_item;
    	let div_present_value;
    	let current;

    	function assignmentpopover_item_binding(value) {
    		/*assignmentpopover_item_binding*/ ctx[32].call(null, value, /*listItem*/ ctx[36], /*each_value*/ ctx[37], /*index*/ ctx[38]);
    	}

    	let assignmentpopover_props = {
    		project: /*findRawProject*/ ctx[4](/*project*/ ctx[0].id)
    	};

    	if (/*listItem*/ ctx[36] !== void 0) {
    		assignmentpopover_props.item = /*listItem*/ ctx[36];
    	}

    	const assignmentpopover = new Assignment$1({
    			props: assignmentpopover_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(assignmentpopover, "item", assignmentpopover_item_binding));

    	assignmentpopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[8])) /*updateAttribute*/ ctx[8].apply(this, arguments);
    	});

    	assignmentpopover.$on("open", /*open_handler_4*/ ctx[33]);
    	assignmentpopover.$on("close", /*close_handler_4*/ ctx[34]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(assignmentpopover.$$.fragment);
    			attr_dev(div, "flex", "initial");
    			attr_dev(div, "section", "assignment");
    			attr_dev(div, "present", div_present_value = (/*listItem*/ ctx[36].assigned_to || []).length > 0);
    			attr_dev(div, "class", "svelte-qjwsgt");
    			add_location(div, file$B, 197, 16, 5303);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(assignmentpopover, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const assignmentpopover_changes = {};
    			if (dirty[0] & /*findRawProject, project*/ 17) assignmentpopover_changes.project = /*findRawProject*/ ctx[4](/*project*/ ctx[0].id);

    			if (!updating_item && dirty[0] & /*list*/ 1024) {
    				updating_item = true;
    				assignmentpopover_changes.item = /*listItem*/ ctx[36];
    				add_flush_callback(() => updating_item = false);
    			}

    			assignmentpopover.$set(assignmentpopover_changes);

    			if (!current || dirty[0] & /*list*/ 1024 && div_present_value !== (div_present_value = (/*listItem*/ ctx[36].assigned_to || []).length > 0)) {
    				attr_dev(div, "present", div_present_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(assignmentpopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(assignmentpopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(assignmentpopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(197:14) {#if (listItem.type != \\\"assignment\\\") && (project.assignments.length > 0)}",
    		ctx
    	});

    	return block;
    }

    // (162:4) {#each list as listItem, index}
    function create_each_block$4(ctx) {
    	let div5;
    	let t0;
    	let div0;
    	let updating_value;
    	let t1;
    	let div4;
    	let div3;
    	let div1;
    	let div1_present_value;
    	let t2;
    	let div2;
    	let div2_present_value;
    	let t3;
    	let t4;
    	let t5;
    	let div6;
    	let updating_item;
    	let t6;
    	let current;
    	let if_block0 = /*showProgress*/ ctx[1] && create_if_block_4(ctx);

    	function inlineinput_value_binding(value) {
    		/*inlineinput_value_binding*/ ctx[25].call(null, value, /*listItem*/ ctx[36]);
    	}

    	let inlineinput_props = {
    		style: /*style*/ ctx[7],
    		$$slots: {
    			default: [
    				create_default_slot$e,
    				({ label }) => ({ 39: label }),
    				({ label }) => [0, label ? 256 : 0]
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*listItem*/ ctx[36].name !== void 0) {
    		inlineinput_props.value = /*listItem*/ ctx[36].name;
    	}

    	const inlineinput = new InlineInput({ props: inlineinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(inlineinput, "value", inlineinput_value_binding));

    	inlineinput.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[8]({
    			detail: {
    				id: /*listItem*/ ctx[36].id,
    				name: /*listItem*/ ctx[36].name
    			}
    		}))) /*updateAttribute*/ ctx[8]({
    			detail: {
    				id: /*listItem*/ ctx[36].id,
    				name: /*listItem*/ ctx[36].name
    			}
    		}).apply(this, arguments);
    	});

    	inlineinput.$on("clicked", function () {
    		if (is_function(/*goToItem*/ ctx[5](/*listItem*/ ctx[36]))) /*goToItem*/ ctx[5](/*listItem*/ ctx[36]).apply(this, arguments);
    	});

    	const duedatepopover = new DueDate({
    			props: {
    				item: /*listItem*/ ctx[36],
    				value: /*listItem*/ ctx[36].due_date
    			},
    			$$inline: true
    		});

    	duedatepopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[8])) /*updateAttribute*/ ctx[8].apply(this, arguments);
    	});

    	duedatepopover.$on("open", /*open_handler_1*/ ctx[26]);
    	duedatepopover.$on("close", /*close_handler_1*/ ctx[27]);

    	const timepopover = new Time({
    			props: {
    				item: /*listItem*/ ctx[36],
    				value: /*listItem*/ ctx[36].due_date,
    				showTimeForm: true
    			},
    			$$inline: true
    		});

    	timepopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[8])) /*updateAttribute*/ ctx[8].apply(this, arguments);
    	});

    	timepopover.$on("open", /*open_handler_2*/ ctx[28]);
    	timepopover.$on("close", /*close_handler_2*/ ctx[29]);
    	let if_block1 = /*showChecklist*/ ctx[2] && create_if_block_2$3(ctx);
    	let if_block2 = /*listItem*/ ctx[36].type != "assignment" && /*project*/ ctx[0].assignments.length > 0 && create_if_block_1$8(ctx);

    	function homechecklist_item_binding(value) {
    		/*homechecklist_item_binding*/ ctx[35].call(null, value, /*listItem*/ ctx[36], /*each_value*/ ctx[37], /*index*/ ctx[38]);
    	}

    	let homechecklist_props = {
    		project: /*findRawProject*/ ctx[4](/*project*/ ctx[0].id)
    	};

    	if (/*listItem*/ ctx[36] !== void 0) {
    		homechecklist_props.item = /*listItem*/ ctx[36];
    	}

    	const homechecklist = new Home_Checklist({
    			props: homechecklist_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(homechecklist, "item", homechecklist_item_binding));

    	homechecklist.$on("update", function () {
    		if (is_function(/*updateChecklist*/ ctx[9])) /*updateChecklist*/ ctx[9].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			create_component(inlineinput.$$.fragment);
    			t1 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			create_component(duedatepopover.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			create_component(timepopover.$$.fragment);
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			t5 = space();
    			div6 = element("div");
    			create_component(homechecklist.$$.fragment);
    			t6 = space();
    			attr_dev(div0, "flex", "");
    			attr_dev(div0, "ellipsis", "");
    			add_location(div0, file$B, 169, 10, 3899);
    			attr_dev(div1, "flex", "initial");
    			attr_dev(div1, "section", "due-date");
    			attr_dev(div1, "present", div1_present_value = /*listItem*/ ctx[36].due_date != null);
    			attr_dev(div1, "class", "svelte-qjwsgt");
    			add_location(div1, file$B, 180, 14, 4429);
    			attr_dev(div2, "flex", "initial");
    			attr_dev(div2, "section", "time");
    			attr_dev(div2, "present", div2_present_value = false);
    			attr_dev(div2, "class", "svelte-qjwsgt");
    			add_location(div2, file$B, 183, 14, 4664);
    			attr_dev(div3, "layout", "row");
    			add_location(div3, file$B, 175, 12, 4351);
    			attr_dev(div4, "flex", "initial");
    			add_location(div4, file$B, 174, 10, 4317);
    			attr_dev(div5, "layout", "row");
    			attr_dev(div5, "type", "list-item");
    			attr_dev(div5, "class", "svelte-qjwsgt");
    			add_location(div5, file$B, 163, 8, 3579);
    			add_location(div6, file$B, 206, 8, 5650);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			if (if_block0) if_block0.m(div5, null);
    			append_dev(div5, t0);
    			append_dev(div5, div0);
    			mount_component(inlineinput, div0, null);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			mount_component(duedatepopover, div1, null);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			mount_component(timepopover, div2, null);
    			append_dev(div3, t3);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t4);
    			if (if_block2) if_block2.m(div3, null);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div6, anchor);
    			mount_component(homechecklist, div6, null);
    			append_dev(div6, t6);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*showProgress*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*showProgress*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div5, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const inlineinput_changes = {};
    			if (dirty[0] & /*style*/ 128) inlineinput_changes.style = /*style*/ ctx[7];

    			if (dirty[0] & /*project, collection, list*/ 1033 | dirty[1] & /*$$scope, label*/ 768) {
    				inlineinput_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty[0] & /*list*/ 1024) {
    				updating_value = true;
    				inlineinput_changes.value = /*listItem*/ ctx[36].name;
    				add_flush_callback(() => updating_value = false);
    			}

    			inlineinput.$set(inlineinput_changes);
    			const duedatepopover_changes = {};
    			if (dirty[0] & /*list*/ 1024) duedatepopover_changes.item = /*listItem*/ ctx[36];
    			if (dirty[0] & /*list*/ 1024) duedatepopover_changes.value = /*listItem*/ ctx[36].due_date;
    			duedatepopover.$set(duedatepopover_changes);

    			if (!current || dirty[0] & /*list*/ 1024 && div1_present_value !== (div1_present_value = /*listItem*/ ctx[36].due_date != null)) {
    				attr_dev(div1, "present", div1_present_value);
    			}

    			const timepopover_changes = {};
    			if (dirty[0] & /*list*/ 1024) timepopover_changes.item = /*listItem*/ ctx[36];
    			if (dirty[0] & /*list*/ 1024) timepopover_changes.value = /*listItem*/ ctx[36].due_date;
    			timepopover.$set(timepopover_changes);

    			if (/*showChecklist*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*showChecklist*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t4);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*listItem*/ ctx[36].type != "assignment" && /*project*/ ctx[0].assignments.length > 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*list, project*/ 1025) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$8(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div3, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			const homechecklist_changes = {};
    			if (dirty[0] & /*findRawProject, project*/ 17) homechecklist_changes.project = /*findRawProject*/ ctx[4](/*project*/ ctx[0].id);

    			if (!updating_item && dirty[0] & /*list*/ 1024) {
    				updating_item = true;
    				homechecklist_changes.item = /*listItem*/ ctx[36];
    				add_flush_callback(() => updating_item = false);
    			}

    			homechecklist.$set(homechecklist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(inlineinput.$$.fragment, local);
    			transition_in(duedatepopover.$$.fragment, local);
    			transition_in(timepopover.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(homechecklist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(inlineinput.$$.fragment, local);
    			transition_out(duedatepopover.$$.fragment, local);
    			transition_out(timepopover.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(homechecklist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if (if_block0) if_block0.d();
    			destroy_component(inlineinput);
    			destroy_component(duedatepopover);
    			destroy_component(timepopover);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div6);
    			destroy_component(homechecklist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(162:4) {#each list as listItem, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*mounted*/ ctx[6] && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*mounted*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*mounted*/ 64) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	var dispatch,
    		findRawProject,
    		goToItem,
    		hasAssignments,
    		mounted,
    		resource,
    		sort,
    		style,
    		subDocument,
    		update,
    		updateAttribute,
    		updateChecklist;

    	dispatch = createEventDispatcher();
    	var { assignments = [] } = $$props;
    	var { showProgress = true } = $$props;
    	var { showAssignment = true } = $$props;
    	var { showChecklist = false } = $$props;
    	var { collection = "tasks" } = $$props;
    	var { item = void 0 } = $$props;
    	var { project: project$1 = void 0 } = $$props;
    	var { rawList = [] } = $$props;
    	resource = new project();
    	subDocument = void 0;
    	mounted = false;

    	onMount(function () {
    		switch (collection) {
    			case "tasks":
    				subDocument = new task();
    				break;
    			case "documents":
    				subDocument = new document$1();
    				break;
    			case "assignments":
    				subDocument = new assignment();
    		}

    		// }
    		project$1[collection].forEach(function (subitem) {
    			return subitem = subDocument.upgradeModel(subitem);
    		});

    		return $$invalidate(6, mounted = true);
    	});

    	findRawProject = function (id) {
    		var found;

    		//console.log "Find  Raw Project #{id}"
    		//console.log rawList
    		found = rawList.find({ id });

    		//console.log found
    		return found;
    	};

    	goToItem = function (childItem) {
    		return location.href = `#/projects/${project$1.id}/${collection}/${childItem.id}`;
    	};

    	style = ":hover {font-weight: bold}";

    	updateAttribute = function (e) {
    		var cb, change, changedTask;
    		console.log("HomeSubdocumentList updateAttribute");
    		console.log(e.detail);
    		change = e.detail;
    		changedTask = project$1[collection].find({ id: change.id });
    		Object.merge(changedTask, change);

    		cb = function (response) {
    			console.log("Subdocument updated");
    			console.log(response);
    			$$invalidate(0, project$1);
    			return dispatch("refresh");
    		};

    		return resource.updateSubdocument({ project: project$1, subDocument: changedTask }, cb);
    	};

    	// note the checklist collection has already been updated before
    	// this event has been called
    	updateChecklist = function (e) {
    		var cb;
    		console.log("Home_SubDocumentList.updateChecklist");
    		console.log(e.detail);

    		cb = function (response) {
    			console.log("checklist item updated");
    			console.log(response);
    			return dispatch("refresh");
    		};

    		return resource.updateChecklistItem(e.detail, cb);
    	};

    	hasAssignments = function () {
    		return true;
    	};

    	update = function () {
    		return dispatch("update");
    	};

    	sort = function (list) {
    		if (project$1[collection] != null) {
    			return project$1[collection].sortBy("ordinal");
    		} else {
    			return [];
    		}
    	};

    	const writable_props = [
    		"assignments",
    		"showProgress",
    		"showAssignment",
    		"showChecklist",
    		"collection",
    		"item",
    		"project",
    		"rawList"
    	];

    	Object_1$4.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$h.warn(`<Home_SubDocumentList> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Home_SubDocumentList", $$slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function progresspopover_value_binding(value, listItem) {
    		listItem.progress = value;
    		((($$invalidate(10, list), $$invalidate(18, sort)), $$invalidate(0, project$1)), $$invalidate(3, collection));
    	}

    	function open_handler(event) {
    		bubble($$self, event);
    	}

    	function close_handler(event) {
    		bubble($$self, event);
    	}

    	function inlineinput_value_binding(value, listItem) {
    		listItem.name = value;
    		((($$invalidate(10, list), $$invalidate(18, sort)), $$invalidate(0, project$1)), $$invalidate(3, collection));
    	}

    	function open_handler_1(event) {
    		bubble($$self, event);
    	}

    	function close_handler_1(event) {
    		bubble($$self, event);
    	}

    	function open_handler_2(event) {
    		bubble($$self, event);
    	}

    	function close_handler_2(event) {
    		bubble($$self, event);
    	}

    	function open_handler_3(event) {
    		bubble($$self, event);
    	}

    	function close_handler_3(event) {
    		bubble($$self, event);
    	}

    	function assignmentpopover_item_binding(value, listItem, each_value, index) {
    		each_value[index] = value;
    		((($$invalidate(10, list), $$invalidate(18, sort)), $$invalidate(0, project$1)), $$invalidate(3, collection));
    	}

    	function open_handler_4(event) {
    		bubble($$self, event);
    	}

    	function close_handler_4(event) {
    		bubble($$self, event);
    	}

    	function homechecklist_item_binding(value, listItem, each_value, index) {
    		each_value[index] = value;
    		((($$invalidate(10, list), $$invalidate(18, sort)), $$invalidate(0, project$1)), $$invalidate(3, collection));
    	}

    	$$self.$set = $$props => {
    		if ("assignments" in $$props) $$invalidate(12, assignments = $$props.assignments);
    		if ("showProgress" in $$props) $$invalidate(1, showProgress = $$props.showProgress);
    		if ("showAssignment" in $$props) $$invalidate(11, showAssignment = $$props.showAssignment);
    		if ("showChecklist" in $$props) $$invalidate(2, showChecklist = $$props.showChecklist);
    		if ("collection" in $$props) $$invalidate(3, collection = $$props.collection);
    		if ("item" in $$props) $$invalidate(13, item = $$props.item);
    		if ("project" in $$props) $$invalidate(0, project$1 = $$props.project);
    		if ("rawList" in $$props) $$invalidate(14, rawList = $$props.rawList);
    	};

    	$$self.$capture_state = () => ({
    		dispatch,
    		findRawProject,
    		goToItem,
    		hasAssignments,
    		mounted,
    		resource,
    		sort,
    		style,
    		subDocument,
    		update,
    		updateAttribute,
    		updateChecklist,
    		onMount,
    		createEventDispatcher,
    		HomeChecklist: Home_Checklist,
    		QuickEntry: GenericItem,
    		InlineInput,
    		Menu: SubDocument,
    		ProgressPopover: Progress,
    		DueDatePopover: DueDate,
    		AssignmentPopover: Assignment$1,
    		TimePopover: Time,
    		ChecklistPopover: Checklist$1,
    		CommentPopover: Comment,
    		Section,
    		assignments,
    		showProgress,
    		showAssignment,
    		showChecklist,
    		collection,
    		Task: task,
    		Assignment: assignment,
    		Document: document$1,
    		item,
    		project: project$1,
    		rawList,
    		Project: project,
    		list
    	});

    	$$self.$inject_state = $$props => {
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("findRawProject" in $$props) $$invalidate(4, findRawProject = $$props.findRawProject);
    		if ("goToItem" in $$props) $$invalidate(5, goToItem = $$props.goToItem);
    		if ("hasAssignments" in $$props) $$invalidate(16, hasAssignments = $$props.hasAssignments);
    		if ("mounted" in $$props) $$invalidate(6, mounted = $$props.mounted);
    		if ("resource" in $$props) resource = $$props.resource;
    		if ("sort" in $$props) $$invalidate(18, sort = $$props.sort);
    		if ("style" in $$props) $$invalidate(7, style = $$props.style);
    		if ("subDocument" in $$props) subDocument = $$props.subDocument;
    		if ("update" in $$props) update = $$props.update;
    		if ("updateAttribute" in $$props) $$invalidate(8, updateAttribute = $$props.updateAttribute);
    		if ("updateChecklist" in $$props) $$invalidate(9, updateChecklist = $$props.updateChecklist);
    		if ("assignments" in $$props) $$invalidate(12, assignments = $$props.assignments);
    		if ("showProgress" in $$props) $$invalidate(1, showProgress = $$props.showProgress);
    		if ("showAssignment" in $$props) $$invalidate(11, showAssignment = $$props.showAssignment);
    		if ("showChecklist" in $$props) $$invalidate(2, showChecklist = $$props.showChecklist);
    		if ("collection" in $$props) $$invalidate(3, collection = $$props.collection);
    		if ("item" in $$props) $$invalidate(13, item = $$props.item);
    		if ("project" in $$props) $$invalidate(0, project$1 = $$props.project);
    		if ("rawList" in $$props) $$invalidate(14, rawList = $$props.rawList);
    		if ("list" in $$props) $$invalidate(10, list = $$props.list);
    	};

    	let list;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*hasAssignments, item*/ 73728) {
    			 $$invalidate(11, showAssignment = hasAssignments(item));
    		}

    		if ($$self.$$.dirty[0] & /*sort, project, collection*/ 262153) {
    			 $$invalidate(10, list = sort(project$1[collection]));
    		}
    	};

    	return [
    		project$1,
    		showProgress,
    		showChecklist,
    		collection,
    		findRawProject,
    		goToItem,
    		mounted,
    		style,
    		updateAttribute,
    		updateChecklist,
    		list,
    		showAssignment,
    		assignments,
    		item,
    		rawList,
    		dispatch,
    		hasAssignments,
    		resource,
    		sort,
    		subDocument,
    		update,
    		click_handler,
    		progresspopover_value_binding,
    		open_handler,
    		close_handler,
    		inlineinput_value_binding,
    		open_handler_1,
    		close_handler_1,
    		open_handler_2,
    		close_handler_2,
    		open_handler_3,
    		close_handler_3,
    		assignmentpopover_item_binding,
    		open_handler_4,
    		close_handler_4,
    		homechecklist_item_binding
    	];
    }

    class Home_SubDocumentList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$F,
    			create_fragment$F,
    			safe_not_equal,
    			{
    				assignments: 12,
    				showProgress: 1,
    				showAssignment: 11,
    				showChecklist: 2,
    				collection: 3,
    				item: 13,
    				project: 0,
    				rawList: 14
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home_SubDocumentList",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get assignments() {
    		throw new Error("<Home_SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set assignments(value) {
    		throw new Error("<Home_SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showProgress() {
    		throw new Error("<Home_SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showProgress(value) {
    		throw new Error("<Home_SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showAssignment() {
    		throw new Error("<Home_SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showAssignment(value) {
    		throw new Error("<Home_SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showChecklist() {
    		throw new Error("<Home_SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showChecklist(value) {
    		throw new Error("<Home_SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collection() {
    		throw new Error("<Home_SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collection(value) {
    		throw new Error("<Home_SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Home_SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Home_SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get project() {
    		throw new Error("<Home_SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set project(value) {
    		throw new Error("<Home_SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rawList() {
    		throw new Error("<Home_SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rawList(value) {
    		throw new Error("<Home_SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Sections\Home_ProjectList.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$5, console: console_1$i } = globals;
    const file$C = "src\\svelte\\pages\\_Common\\Sections\\Home_ProjectList.svelte";

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[22] = list[i];
    	return child_ctx;
    }

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	child_ctx[20] = list;
    	child_ctx[21] = i;
    	return child_ctx;
    }

    // (121:0) {:else}
    function create_else_block$a(ctx) {
    	let section;
    	let p0;
    	let t1;
    	let p1;
    	let t2;
    	let a;
    	let t4;

    	const block = {
    		c: function create() {
    			section = element("section");
    			p0 = element("p");
    			p0.textContent = "You currently don't have any collections yet.";
    			t1 = space();
    			p1 = element("p");
    			t2 = text("Go to the ");
    			a = element("a");
    			a.textContent = "Collections";
    			t4 = text(" view and assign some due dates to see some content here.");
    			add_location(p0, file$C, 122, 4, 3419);
    			attr_dev(a, "href", "#/projects");
    			add_location(a, file$C, 123, 17, 3489);
    			add_location(p1, file$C, 123, 4, 3476);
    			attr_dev(section, "class", "svelte-eziui1");
    			add_location(section, file$C, 121, 2, 3405);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, p0);
    			append_dev(section, t1);
    			append_dev(section, p1);
    			append_dev(p1, t2);
    			append_dev(p1, a);
    			append_dev(p1, t4);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(121:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (77:0) {#if sortedList.length > 0}
    function create_if_block$k(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*sortedList*/ ctx[5];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rawList, sortedList, updateAttribute, refresh, style, goToItem, label*/ 33554495) {
    				each_value = /*sortedList*/ ctx[5];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(77:0) {#if sortedList.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (86:10) <InlineInput bind:value={project.name} on:update={ updateAttribute({ detail: {id: project.id, name: project.name} }) } on:clicked={goToItem(project)} {style} let:label>
    function create_default_slot$f(ctx) {
    	let h3;
    	let a;
    	let em;
    	let t_value = (/*label*/ ctx[25] || "No Name") + "";
    	let t;
    	let a_href_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			a = element("a");
    			em = element("em");
    			t = text(t_value);
    			add_location(em, file$C, 86, 83, 2188);
    			attr_dev(a, "href", a_href_value = "#/projects/" + /*project*/ ctx[19].id);
    			add_location(a, file$C, 86, 25, 2130);
    			attr_dev(h3, "ellipsis", "");
    			add_location(h3, file$C, 86, 12, 2117);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, a);
    			append_dev(a, em);
    			append_dev(em, t);
    			if (remount) dispose();
    			dispose = listen_dev(a, "click", prevent_default(/*click_handler*/ ctx[9]), false, true, false);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 33554432 && t_value !== (t_value = (/*label*/ ctx[25] || "No Name") + "")) set_data_dev(t, t_value);

    			if (dirty & /*sortedList*/ 32 && a_href_value !== (a_href_value = "#/projects/" + /*project*/ ctx[19].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(86:10) <InlineInput bind:value={project.name} on:update={ updateAttribute({ detail: {id: project.id, name: project.name} }) } on:clicked={goToItem(project)} {style} let:label>",
    		ctx
    	});

    	return block;
    }

    // (103:8) {#if (project[collection].length > 0)}
    function create_if_block_1$9(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let h4;
    	let t1_value = /*collection*/ ctx[22].titleize() + "";
    	let t1;
    	let t2;
    	let updating_project;
    	let current;

    	const indent = new Indent({
    			props: { level: 1, width: 32 },
    			$$inline: true
    		});

    	function homesubdocument_project_binding(value) {
    		/*homesubdocument_project_binding*/ ctx[18].call(null, value, /*project*/ ctx[19], /*each_value*/ ctx[20], /*project_index*/ ctx[21]);
    	}

    	let homesubdocument_props = {
    		collection: /*collection*/ ctx[22],
    		rawList: /*rawList*/ ctx[0]
    	};

    	if (/*project*/ ctx[19] !== void 0) {
    		homesubdocument_props.project = /*project*/ ctx[19];
    	}

    	const homesubdocument = new Home_SubDocumentList({
    			props: homesubdocument_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(homesubdocument, "project", homesubdocument_project_binding));

    	homesubdocument.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[4])) /*updateAttribute*/ ctx[4].apply(this, arguments);
    	});

    	homesubdocument.$on("refresh", function () {
    		if (is_function(/*refresh*/ ctx[2])) /*refresh*/ ctx[2].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(indent.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			t1 = text(t1_value);
    			t2 = space();
    			create_component(homesubdocument.$$.fragment);
    			attr_dev(div0, "flex", "initial");
    			add_location(div0, file$C, 104, 12, 2975);
    			add_location(h4, file$C, 108, 14, 3130);
    			attr_dev(div1, "flex", "");
    			set_style(div1, "width", "calc(100% - 24px)");
    			add_location(div1, file$C, 107, 12, 3072);
    			attr_dev(div2, "layout", "row");
    			attr_dev(div2, "type", "list-item");
    			attr_dev(div2, "class", "svelte-eziui1");
    			add_location(div2, file$C, 103, 10, 2927);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			mount_component(indent, div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t1);
    			append_dev(div1, t2);
    			mount_component(homesubdocument, div1, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const homesubdocument_changes = {};
    			if (dirty & /*rawList*/ 1) homesubdocument_changes.rawList = /*rawList*/ ctx[0];

    			if (!updating_project && dirty & /*sortedList*/ 32) {
    				updating_project = true;
    				homesubdocument_changes.project = /*project*/ ctx[19];
    				add_flush_callback(() => updating_project = false);
    			}

    			homesubdocument.$set(homesubdocument_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indent.$$.fragment, local);
    			transition_in(homesubdocument.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indent.$$.fragment, local);
    			transition_out(homesubdocument.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(indent);
    			destroy_component(homesubdocument);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(103:8) {#if (project[collection].length > 0)}",
    		ctx
    	});

    	return block;
    }

    // (102:6) {#each ["assignments","tasks","documents"] as collection }
    function create_each_block_1$2(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*project*/ ctx[19][/*collection*/ ctx[22]].length > 0 && create_if_block_1$9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*project*/ ctx[19][/*collection*/ ctx[22]].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*sortedList*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(102:6) {#each [\\\"assignments\\\",\\\"tasks\\\",\\\"documents\\\"] as collection }",
    		ctx
    	});

    	return block;
    }

    // (78:2) {#each sortedList as project }
    function create_each_block$5(ctx) {
    	let section;
    	let div6;
    	let div0;
    	let updating_value;
    	let t0;
    	let div1;
    	let updating_value_1;
    	let t1;
    	let div5;
    	let div4;
    	let div2;
    	let div2_present_value;
    	let t2;
    	let div3;
    	let div3_present_value;
    	let t3;
    	let t4;
    	let current;

    	function progresspopover_value_binding(value) {
    		/*progresspopover_value_binding*/ ctx[10].call(null, value, /*project*/ ctx[19]);
    	}

    	let progresspopover_props = { item: /*project*/ ctx[19] };

    	if (/*project*/ ctx[19].progress !== void 0) {
    		progresspopover_props.value = /*project*/ ctx[19].progress;
    	}

    	const progresspopover = new Progress({
    			props: progresspopover_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(progresspopover, "value", progresspopover_value_binding));

    	progresspopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[4])) /*updateAttribute*/ ctx[4].apply(this, arguments);
    	});

    	progresspopover.$on("open", /*open_handler*/ ctx[11]);
    	progresspopover.$on("close", /*close_handler*/ ctx[12]);

    	function inlineinput_value_binding(value) {
    		/*inlineinput_value_binding*/ ctx[13].call(null, value, /*project*/ ctx[19]);
    	}

    	let inlineinput_props = {
    		style: /*style*/ ctx[3],
    		$$slots: {
    			default: [
    				create_default_slot$f,
    				({ label }) => ({ 25: label }),
    				({ label }) => label ? 33554432 : 0
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*project*/ ctx[19].name !== void 0) {
    		inlineinput_props.value = /*project*/ ctx[19].name;
    	}

    	const inlineinput = new InlineInput({ props: inlineinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(inlineinput, "value", inlineinput_value_binding));

    	inlineinput.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[4]({
    			detail: {
    				id: /*project*/ ctx[19].id,
    				name: /*project*/ ctx[19].name
    			}
    		}))) /*updateAttribute*/ ctx[4]({
    			detail: {
    				id: /*project*/ ctx[19].id,
    				name: /*project*/ ctx[19].name
    			}
    		}).apply(this, arguments);
    	});

    	inlineinput.$on("clicked", function () {
    		if (is_function(/*goToItem*/ ctx[1](/*project*/ ctx[19]))) /*goToItem*/ ctx[1](/*project*/ ctx[19]).apply(this, arguments);
    	});

    	const duedatepopover = new DueDate({
    			props: {
    				item: /*project*/ ctx[19],
    				value: /*project*/ ctx[19].due_date
    			},
    			$$inline: true
    		});

    	duedatepopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[4])) /*updateAttribute*/ ctx[4].apply(this, arguments);
    	});

    	duedatepopover.$on("open", /*open_handler_1*/ ctx[14]);
    	duedatepopover.$on("close", /*close_handler_1*/ ctx[15]);

    	const estimatepopover = new Time({
    			props: {
    				item: /*project*/ ctx[19],
    				value: /*project*/ ctx[19].due_date
    			},
    			$$inline: true
    		});

    	estimatepopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[4])) /*updateAttribute*/ ctx[4].apply(this, arguments);
    	});

    	estimatepopover.$on("open", /*open_handler_2*/ ctx[16]);
    	estimatepopover.$on("close", /*close_handler_2*/ ctx[17]);
    	let each_value_1 = ["assignments", "tasks", "documents"];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < 3; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			section = element("section");
    			div6 = element("div");
    			div0 = element("div");
    			create_component(progresspopover.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(inlineinput.$$.fragment);
    			t1 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			create_component(duedatepopover.$$.fragment);
    			t2 = space();
    			div3 = element("div");
    			create_component(estimatepopover.$$.fragment);
    			t3 = space();

    			for (let i = 0; i < 3; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			attr_dev(div0, "flex", "initial");
    			attr_dev(div0, "section", "progress");
    			set_style(div0, "padding-right", "8px");
    			set_style(div0, "padding-top", "3px");
    			add_location(div0, file$C, 80, 8, 1677);
    			attr_dev(div1, "flex", "");
    			attr_dev(div1, "ellipsis", "");
    			add_location(div1, file$C, 84, 8, 1905);
    			attr_dev(div2, "flex", "initial");
    			attr_dev(div2, "present", div2_present_value = /*project*/ ctx[19].due_date != null);
    			attr_dev(div2, "class", "svelte-eziui1");
    			add_location(div2, file$C, 91, 12, 2381);
    			attr_dev(div3, "flex", "initial");
    			attr_dev(div3, "present", div3_present_value = false);
    			attr_dev(div3, "class", "svelte-eziui1");
    			add_location(div3, file$C, 94, 12, 2585);
    			attr_dev(div4, "layout", "row");
    			add_location(div4, file$C, 90, 10, 2350);
    			attr_dev(div5, "flex", "initial");
    			set_style(div5, "padding-left", "8px");
    			set_style(div5, "padding-top", "3px");
    			add_location(div5, file$C, 89, 8, 2275);
    			attr_dev(div6, "layout", "row");
    			attr_dev(div6, "type", "list-item");
    			attr_dev(div6, "class", "svelte-eziui1");
    			add_location(div6, file$C, 79, 6, 1633);
    			attr_dev(section, "class", "svelte-eziui1");
    			add_location(section, file$C, 78, 4, 1617);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div6);
    			append_dev(div6, div0);
    			mount_component(progresspopover, div0, null);
    			append_dev(div6, t0);
    			append_dev(div6, div1);
    			mount_component(inlineinput, div1, null);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			mount_component(duedatepopover, div2, null);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    			mount_component(estimatepopover, div3, null);
    			append_dev(section, t3);

    			for (let i = 0; i < 3; i += 1) {
    				each_blocks[i].m(section, null);
    			}

    			append_dev(section, t4);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const progresspopover_changes = {};
    			if (dirty & /*sortedList*/ 32) progresspopover_changes.item = /*project*/ ctx[19];

    			if (!updating_value && dirty & /*sortedList*/ 32) {
    				updating_value = true;
    				progresspopover_changes.value = /*project*/ ctx[19].progress;
    				add_flush_callback(() => updating_value = false);
    			}

    			progresspopover.$set(progresspopover_changes);
    			const inlineinput_changes = {};
    			if (dirty & /*style*/ 8) inlineinput_changes.style = /*style*/ ctx[3];

    			if (dirty & /*$$scope, sortedList, label*/ 100663328) {
    				inlineinput_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value_1 && dirty & /*sortedList*/ 32) {
    				updating_value_1 = true;
    				inlineinput_changes.value = /*project*/ ctx[19].name;
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			inlineinput.$set(inlineinput_changes);
    			const duedatepopover_changes = {};
    			if (dirty & /*sortedList*/ 32) duedatepopover_changes.item = /*project*/ ctx[19];
    			if (dirty & /*sortedList*/ 32) duedatepopover_changes.value = /*project*/ ctx[19].due_date;
    			duedatepopover.$set(duedatepopover_changes);

    			if (!current || dirty & /*sortedList*/ 32 && div2_present_value !== (div2_present_value = /*project*/ ctx[19].due_date != null)) {
    				attr_dev(div2, "present", div2_present_value);
    			}

    			const estimatepopover_changes = {};
    			if (dirty & /*sortedList*/ 32) estimatepopover_changes.item = /*project*/ ctx[19];
    			if (dirty & /*sortedList*/ 32) estimatepopover_changes.value = /*project*/ ctx[19].due_date;
    			estimatepopover.$set(estimatepopover_changes);

    			if (dirty & /*rawList, sortedList, updateAttribute, refresh*/ 53) {
    				each_value_1 = ["assignments", "tasks", "documents"];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < 3; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(section, t4);
    					}
    				}

    				group_outros();

    				for (i = 3; i < 3; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(progresspopover.$$.fragment, local);
    			transition_in(inlineinput.$$.fragment, local);
    			transition_in(duedatepopover.$$.fragment, local);
    			transition_in(estimatepopover.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(progresspopover.$$.fragment, local);
    			transition_out(inlineinput.$$.fragment, local);
    			transition_out(duedatepopover.$$.fragment, local);
    			transition_out(estimatepopover.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < 3; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(progresspopover);
    			destroy_component(inlineinput);
    			destroy_component(duedatepopover);
    			destroy_component(estimatepopover);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(78:2) {#each sortedList as project }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$k, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*sortedList*/ ctx[5].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	var dispatch, goToItem, refresh, style, updateAttribute, updateProject;
    	dispatch = createEventDispatcher();
    	var { list = [] } = $$props;
    	var { rawList = [] } = $$props;
    	style = ":hover {font-weight: bold}";

    	updateAttribute = function (e) {
    		var projectToUpdate;

    		// Update Project Attribute
    		console.log("HomeProjectList.updateAttribute");

    		console.log(e.detail);
    		projectToUpdate = list.find({ id: e.detail.id });

    		if (projectToUpdate != null) {
    			Object.merge(projectToUpdate, e.detail);
    			$$invalidate(6, list);
    			return dispatch("update", e.detail); // this will save the change to the proejct
    		}
    	};

    	updateProject = function (e) {
    		console.log("updateProject");
    		console.log(e.detail);
    		return dispatch("update", e.detail);
    	};

    	goToItem = function (p) {
    		console.log("gotoitem");
    		console.log(`#/projects/${p.id}`);
    		return push(`#/projects/${p.id}`);
    	};

    	refresh = function () {
    		return dispatch("refresh");
    	};

    	const writable_props = ["list", "rawList"];

    	Object_1$5.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$i.warn(`<Home_ProjectList> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Home_ProjectList", $$slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function progresspopover_value_binding(value, project) {
    		project.progress = value;
    		($$invalidate(5, sortedList), $$invalidate(6, list));
    	}

    	function open_handler(event) {
    		bubble($$self, event);
    	}

    	function close_handler(event) {
    		bubble($$self, event);
    	}

    	function inlineinput_value_binding(value, project) {
    		project.name = value;
    		($$invalidate(5, sortedList), $$invalidate(6, list));
    	}

    	function open_handler_1(event) {
    		bubble($$self, event);
    	}

    	function close_handler_1(event) {
    		bubble($$self, event);
    	}

    	function open_handler_2(event) {
    		bubble($$self, event);
    	}

    	function close_handler_2(event) {
    		bubble($$self, event);
    	}

    	function homesubdocument_project_binding(value, project, each_value, project_index) {
    		each_value[project_index] = value;
    		($$invalidate(5, sortedList), $$invalidate(6, list));
    	}

    	$$self.$set = $$props => {
    		if ("list" in $$props) $$invalidate(6, list = $$props.list);
    		if ("rawList" in $$props) $$invalidate(0, rawList = $$props.rawList);
    	};

    	$$self.$capture_state = () => ({
    		dispatch,
    		goToItem,
    		refresh,
    		style,
    		updateAttribute,
    		updateProject,
    		onMount,
    		createEventDispatcher,
    		push,
    		pop,
    		replace,
    		location: location$1,
    		Indent,
    		Menu: Project,
    		InlineInput,
    		ProgressPopover: Progress,
    		DueDatePopover: DueDate,
    		EstimatePopover: Time,
    		HomeSubDocument: Home_SubDocumentList,
    		list,
    		rawList,
    		sortedList
    	});

    	$$self.$inject_state = $$props => {
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("goToItem" in $$props) $$invalidate(1, goToItem = $$props.goToItem);
    		if ("refresh" in $$props) $$invalidate(2, refresh = $$props.refresh);
    		if ("style" in $$props) $$invalidate(3, style = $$props.style);
    		if ("updateAttribute" in $$props) $$invalidate(4, updateAttribute = $$props.updateAttribute);
    		if ("updateProject" in $$props) updateProject = $$props.updateProject;
    		if ("list" in $$props) $$invalidate(6, list = $$props.list);
    		if ("rawList" in $$props) $$invalidate(0, rawList = $$props.rawList);
    		if ("sortedList" in $$props) $$invalidate(5, sortedList = $$props.sortedList);
    	};

    	let sortedList;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*list*/ 64) {
    			 $$invalidate(5, sortedList = list.sortBy("ordinal"));
    		}
    	};

    	return [
    		rawList,
    		goToItem,
    		refresh,
    		style,
    		updateAttribute,
    		sortedList,
    		list,
    		dispatch,
    		updateProject,
    		click_handler,
    		progresspopover_value_binding,
    		open_handler,
    		close_handler,
    		inlineinput_value_binding,
    		open_handler_1,
    		close_handler_1,
    		open_handler_2,
    		close_handler_2,
    		homesubdocument_project_binding
    	];
    }

    class Home_ProjectList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { list: 6, rawList: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home_ProjectList",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get list() {
    		throw new Error("<Home_ProjectList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set list(value) {
    		throw new Error("<Home_ProjectList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rawList() {
    		throw new Error("<Home_ProjectList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rawList(value) {
    		throw new Error("<Home_ProjectList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\Home\Home.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$6, console: console_1$j } = globals;
    const file$D = "src\\svelte\\pages\\Home\\Home.svelte";

    // (96:2) <PageHeader>
    function create_default_slot_1$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Current Work");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(96:2) <PageHeader>",
    		ctx
    	});

    	return block;
    }

    // (94:0) <PageContent>
    function create_default_slot$g(ctx) {
    	let a;
    	let t0;
    	let t1;
    	let section;
    	let div;
    	let t2;
    	let p;
    	let current;

    	const pageheader = new PageHeader({
    			props: {
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const homeprojectlist = new Home_ProjectList({
    			props: {
    				list: /*itemsWithDueDates*/ ctx[1](/*list*/ ctx[2]),
    				rawList: /*rawList*/ ctx[3]
    			},
    			$$inline: true
    		});

    	homeprojectlist.$on("update", function () {
    		if (is_function(/*updateProject*/ ctx[4])) /*updateProject*/ ctx[4].apply(this, arguments);
    	});

    	homeprojectlist.$on("refresh", function () {
    		if (is_function(/*getProjects*/ ctx[0])) /*getProjects*/ ctx[0].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			a = element("a");
    			t0 = space();
    			create_component(pageheader.$$.fragment);
    			t1 = space();
    			section = element("section");
    			div = element("div");
    			create_component(homeprojectlist.$$.fragment);
    			t2 = space();
    			p = element("p");
    			p.textContent = "Current Work is any project, task, document, assignment or check list item that has a due date.";
    			attr_dev(a, "name", "top");
    			add_location(a, file$D, 94, 2, 2626);
    			add_location(div, file$D, 98, 4, 2706);
    			add_location(p, file$D, 101, 4, 2847);
    			attr_dev(section, "class", "svelte-1jadye5");
    			add_location(section, file$D, 97, 2, 2691);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(pageheader, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, section, anchor);
    			append_dev(section, div);
    			mount_component(homeprojectlist, div, null);
    			append_dev(section, t2);
    			append_dev(section, p);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const pageheader_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				pageheader_changes.$$scope = { dirty, ctx };
    			}

    			pageheader.$set(pageheader_changes);
    			const homeprojectlist_changes = {};
    			if (dirty & /*itemsWithDueDates, list*/ 6) homeprojectlist_changes.list = /*itemsWithDueDates*/ ctx[1](/*list*/ ctx[2]);
    			if (dirty & /*rawList*/ 8) homeprojectlist_changes.rawList = /*rawList*/ ctx[3];
    			homeprojectlist.$set(homeprojectlist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pageheader.$$.fragment, local);
    			transition_in(homeprojectlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pageheader.$$.fragment, local);
    			transition_out(homeprojectlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t0);
    			destroy_component(pageheader, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(section);
    			destroy_component(homeprojectlist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(94:0) <PageContent>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let current;

    	const pagecontent = new PageContent({
    			props: {
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pagecontent.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagecontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const pagecontent_changes = {};

    			if (dirty & /*$$scope, itemsWithDueDates, list, rawList, updateProject, getProjects*/ 159) {
    				pagecontent_changes.$$scope = { dirty, ctx };
    			}

    			pagecontent.$set(pagecontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagecontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagecontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagecontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	var getProjects, itemsWithDueDates, jump, list, rawList, resource, updateProject;

    	jump = function (anchorName) {
    		var elem, scrollContainer;
    		elem = u(`[name=${anchorName}]`);
    		scrollContainer = u("body > main > section").first();
    		return scrollContainer.scrollTop = elem.first().offsetTop - 40;
    	};

    	list = [];
    	rawList = [];
    	resource = new project();

    	getProjects = function () {
    		var projectLoadedScb;

    		projectLoadedScb = function (projects) {
    			$$invalidate(2, list = projects);

    			// console.log projects
    			return $$invalidate(3, rawList = projects.map(function (p) {
    				return Object.select(p, ["id", "assignments"]); // this creates a discrete copy of the object. array.clone() does not do that.
    			}));
    		};

    		return resource.select(projectLoadedScb, null, null);
    	};

    	getProjects();

    	updateProject = function (e) {
    		var ecb, scb;

    		scb = function (updated) {
    			return getProjects();
    		};

    		ecb = function (err) {
    			console.log("udpate err");
    			console.log(err);
    			return getProjects();
    		};

    		return resource.updateAttributes(e.detail, scb, ecb, null);
    	};

    	itemsWithDueDates = function (projects) {
    		var clonedProjects, output;
    		output = [];
    		clonedProjects = projects.clone();

    		output = clonedProjects.filter(function (project) {
    			["tasks", "assignments", "documents"].filter(function (collection) {
    				return project[collection] = project[collection].filter(function (collectionItem) {
    					//console.log "collectionItme"
    					//console.log collectionItem
    					collectionItem.checklist_items = collectionItem.checklist_items.filter(function (checklist_item) {
    						return checklist_item.due_date != null;
    					});

    					return collectionItem.checklist_items.length > 0 || collectionItem.due_date != null;
    				});
    			});

    			return project["tasks"].length > 0 || project["assignments"].length > 0 || project["documents"].length > 0 || project.due_date != null;
    		});

    		return output;
    	};

    	const writable_props = [];

    	Object_1$6.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$j.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Home", $$slots, []);

    	$$self.$capture_state = () => ({
    		getProjects,
    		itemsWithDueDates,
    		jump,
    		list,
    		rawList,
    		resource,
    		updateProject,
    		PageContent,
    		PageHeader,
    		HomeProjectList: Home_ProjectList,
    		Project: project
    	});

    	$$self.$inject_state = $$props => {
    		if ("getProjects" in $$props) $$invalidate(0, getProjects = $$props.getProjects);
    		if ("itemsWithDueDates" in $$props) $$invalidate(1, itemsWithDueDates = $$props.itemsWithDueDates);
    		if ("jump" in $$props) jump = $$props.jump;
    		if ("list" in $$props) $$invalidate(2, list = $$props.list);
    		if ("rawList" in $$props) $$invalidate(3, rawList = $$props.rawList);
    		if ("resource" in $$props) resource = $$props.resource;
    		if ("updateProject" in $$props) $$invalidate(4, updateProject = $$props.updateProject);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [getProjects, itemsWithDueDates, list, rawList, updateProject];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src\svelte\pages\_Common\Lists\Nestable\DraggableIndentableItem.svelte generated by Svelte v3.22.2 */

    const { console: console_1$k } = globals;
    const file$E = "src\\svelte\\pages\\_Common\\Lists\\Nestable\\DraggableIndentableItem.svelte";

    const get_menu_slot_changes = dirty => ({
    	item: dirty[0] & /*item*/ 1,
    	index: dirty[0] & /*index*/ 2
    });

    const get_menu_slot_context = ctx => ({
    	item: /*item*/ ctx[0],
    	index: /*index*/ ctx[1]
    });

    const get_default_slot_changes$2 = dirty => ({
    	item: dirty[0] & /*item*/ 1,
    	index: dirty[0] & /*index*/ 2
    });

    const get_default_slot_context$2 = ctx => ({
    	item: /*item*/ ctx[0],
    	index: /*index*/ ctx[1]
    });

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[31] = list[i];
    	return child_ctx;
    }

    const get_grabber_slot_changes = dirty => ({
    	item: dirty[0] & /*item*/ 1,
    	index: dirty[0] & /*index*/ 2
    });

    const get_grabber_slot_context = ctx => ({
    	item: /*item*/ ctx[0],
    	index: /*index*/ ctx[1]
    });

    // (157:29)            
    function fallback_block$4(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M9,3H11V5H9V3M13,3H15V5H13V3M9,7H11V9H9V7M13,7H15V9H13V7M9,11H11V13H9V11M13,11H15V13H13V11M9,15H11V17H9V15M13,15H15V17H13V15M9,19H11V21H9V19M13,19H15V21H13V19Z");
    			add_location(path, file$E, 157, 122, 3339);
    			attr_dev(svg, "class", "handle");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$E, 157, 10, 3227);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$4.name,
    		type: "fallback",
    		source: "(157:29)            ",
    		ctx
    	});

    	return block;
    }

    // (168:14) {#each [0,1,2,3,4,5] as indentLevel}
    function create_each_block$6(ctx) {
    	let button;
    	let t;
    	let button_disabled_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(/*indentLevel*/ ctx[31]);
    			attr_dev(button, "type", "button");
    			button.disabled = button_disabled_value = (/*item*/ ctx[0].indent || 0) == /*indentLevel*/ ctx[31];
    			attr_dev(button, "indent", "");
    			add_location(button, file$E, 168, 16, 4091);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*indent*/ ctx[6](/*indentLevel*/ ctx[31]))) /*indent*/ ctx[6](/*indentLevel*/ ctx[31]).apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*item*/ 1 && button_disabled_value !== (button_disabled_value = (/*item*/ ctx[0].indent || 0) == /*indentLevel*/ ctx[31])) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(168:14) {#each [0,1,2,3,4,5] as indentLevel}",
    		ctx
    	});

    	return block;
    }

    // (165:8) <Menu trigger={indentButtonRef} bind:showMenu={showIndentMenu} align="left" width="189px">
    function create_default_slot$h(ctx) {
    	let ul;
    	let li;
    	let each_value = [0, 1, 2, 3, 4, 5];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < 6; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li = element("li");

    			for (let i = 0; i < 6; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(li, file$E, 166, 12, 4019);
    			add_location(ul, file$E, 165, 10, 4002);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li);

    			for (let i = 0; i < 6; i += 1) {
    				each_blocks[i].m(li, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*item, indent*/ 65) {
    				each_value = [0, 1, 2, 3, 4, 5];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < 6; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(li, null);
    					}
    				}

    				for (; i < 6; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(165:8) <Menu trigger={indentButtonRef} bind:showMenu={showIndentMenu} align=\\\"left\\\" width=\\\"189px\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div1;
    	let button;
    	let svg;
    	let path;
    	let t1;
    	let updating_showMenu;
    	let t2;
    	let div2;
    	let t3;
    	let div3;
    	let div4_data_id_value;
    	let current;
    	let dispose;
    	const grabber_slot_template = /*$$slots*/ ctx[26].grabber;
    	const grabber_slot = create_slot(grabber_slot_template, ctx, /*$$scope*/ ctx[30], get_grabber_slot_context);
    	const grabber_slot_or_fallback = grabber_slot || fallback_block$4(ctx);

    	function menu_showMenu_binding(value) {
    		/*menu_showMenu_binding*/ ctx[28].call(null, value);
    	}

    	let menu_props = {
    		trigger: /*indentButtonRef*/ ctx[7],
    		align: "left",
    		width: "189px",
    		$$slots: { default: [create_default_slot$h] },
    		$$scope: { ctx }
    	};

    	if (/*showIndentMenu*/ ctx[14] !== void 0) {
    		menu_props.showMenu = /*showIndentMenu*/ ctx[14];
    	}

    	const menu = new ComposedMenu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "showMenu", menu_showMenu_binding));
    	const default_slot_template = /*$$slots*/ ctx[26].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[30], get_default_slot_context$2);
    	const menu_slot_template = /*$$slots*/ ctx[26].menu;
    	const menu_slot = create_slot(menu_slot_template, ctx, /*$$scope*/ ctx[30], get_menu_slot_context);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			if (grabber_slot_or_fallback) grabber_slot_or_fallback.c();
    			t0 = space();
    			div1 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t1 = space();
    			create_component(menu.$$.fragment);
    			t2 = space();
    			div2 = element("div");
    			if (default_slot) default_slot.c();
    			t3 = space();
    			div3 = element("div");
    			if (menu_slot) menu_slot.c();
    			attr_dev(div0, "flex", "initial");
    			attr_dev(div0, "handle", "");
    			add_location(div0, file$E, 155, 6, 3101);
    			attr_dev(path, "d", "M20,18H22V6H20M11.59,7.41L15.17,11H1V13H15.17L11.59,16.58L13,18L19,12L13,6L11.59,7.41Z");
    			add_location(path, file$E, 162, 107, 3770);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "18");
    			attr_dev(svg, "height", "18");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$E, 162, 10, 3673);
    			attr_dev(button, "icon", "");
    			add_location(button, file$E, 161, 8, 3593);
    			attr_dev(div1, "flex", "initial");
    			attr_dev(div1, "indent-menu", "");
    			add_location(div1, file$E, 160, 6, 3552);
    			attr_dev(div2, "flex", "");
    			attr_dev(div2, "class", "slot");
    			add_location(div2, file$E, 174, 6, 4310);
    			attr_dev(div3, "flex", "initial");
    			attr_dev(div3, "draggable-item-menu", "");
    			set_style(div3, "padding-left", "24px");
    			set_style(div3, "padding-right", "4px");
    			add_location(div3, file$E, 175, 6, 4379);
    			attr_dev(div4, "item-draggable", "");
    			attr_dev(div4, "draggable", /*draggable*/ ctx[3]);
    			attr_dev(div4, "data-id", div4_data_id_value = /*item*/ ctx[0].id);
    			attr_dev(div4, "indentable", /*indentable*/ ctx[2]);
    			toggle_class(div4, "over", /*isOver*/ ctx[9]);
    			toggle_class(div4, "invalid", /*isInvalid*/ ctx[8]);
    			add_location(div4, file$E, 140, 0, 2860);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);

    			if (grabber_slot_or_fallback) {
    				grabber_slot_or_fallback.m(div0, null);
    			}

    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div1, button);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			/*button_binding*/ ctx[27](button);
    			append_dev(div1, t1);
    			mount_component(menu, div1, null);
    			append_dev(div4, t2);
    			append_dev(div4, div2);

    			if (default_slot) {
    				default_slot.m(div2, null);
    			}

    			append_dev(div4, t3);
    			append_dev(div4, div3);

    			if (menu_slot) {
    				menu_slot.m(div3, null);
    			}

    			/*div4_binding*/ ctx[29](div4);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					div0,
    					"mouseup",
    					function () {
    						if (is_function(/*mouseup*/ ctx[12](/*item*/ ctx[0]))) /*mouseup*/ ctx[12](/*item*/ ctx[0]).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					div0,
    					"mousedown",
    					function () {
    						if (is_function(/*mousedown*/ ctx[11](/*item*/ ctx[0]))) /*mousedown*/ ctx[11](/*item*/ ctx[0]).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*toggleIndentMenu*/ ctx[16])) /*toggleIndentMenu*/ ctx[16].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					div4,
    					"drop",
    					function () {
    						if (is_function(/*drop*/ ctx[5])) /*drop*/ ctx[5].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					div4,
    					"dragover",
    					function () {
    						if (is_function(/*over*/ ctx[13])) /*over*/ ctx[13].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					div4,
    					"dragstart",
    					function () {
    						if (is_function(/*start*/ ctx[15])) /*start*/ ctx[15].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					div4,
    					"dragleave",
    					function () {
    						if (is_function(/*leave*/ ctx[10])) /*leave*/ ctx[10].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (grabber_slot) {
    				if (grabber_slot.p && dirty[0] & /*$$scope, item, index*/ 1073741827) {
    					grabber_slot.p(get_slot_context(grabber_slot_template, ctx, /*$$scope*/ ctx[30], get_grabber_slot_context), get_slot_changes(grabber_slot_template, /*$$scope*/ ctx[30], dirty, get_grabber_slot_changes));
    				}
    			}

    			const menu_changes = {};
    			if (dirty[0] & /*indentButtonRef*/ 128) menu_changes.trigger = /*indentButtonRef*/ ctx[7];

    			if (dirty[0] & /*$$scope, item, indent*/ 1073741889) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_showMenu && dirty[0] & /*showIndentMenu*/ 16384) {
    				updating_showMenu = true;
    				menu_changes.showMenu = /*showIndentMenu*/ ctx[14];
    				add_flush_callback(() => updating_showMenu = false);
    			}

    			menu.$set(menu_changes);

    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope, item, index*/ 1073741827) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[30], get_default_slot_context$2), get_slot_changes(default_slot_template, /*$$scope*/ ctx[30], dirty, get_default_slot_changes$2));
    				}
    			}

    			if (menu_slot) {
    				if (menu_slot.p && dirty[0] & /*$$scope, item, index*/ 1073741827) {
    					menu_slot.p(get_slot_context(menu_slot_template, ctx, /*$$scope*/ ctx[30], get_menu_slot_context), get_slot_changes(menu_slot_template, /*$$scope*/ ctx[30], dirty, get_menu_slot_changes));
    				}
    			}

    			if (!current || dirty[0] & /*draggable*/ 8) {
    				attr_dev(div4, "draggable", /*draggable*/ ctx[3]);
    			}

    			if (!current || dirty[0] & /*item*/ 1 && div4_data_id_value !== (div4_data_id_value = /*item*/ ctx[0].id)) {
    				attr_dev(div4, "data-id", div4_data_id_value);
    			}

    			if (!current || dirty[0] & /*indentable*/ 4) {
    				attr_dev(div4, "indentable", /*indentable*/ ctx[2]);
    			}

    			if (dirty[0] & /*isOver*/ 512) {
    				toggle_class(div4, "over", /*isOver*/ ctx[9]);
    			}

    			if (dirty[0] & /*isInvalid*/ 256) {
    				toggle_class(div4, "invalid", /*isInvalid*/ ctx[8]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(grabber_slot_or_fallback, local);
    			transition_in(menu.$$.fragment, local);
    			transition_in(default_slot, local);
    			transition_in(menu_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(grabber_slot_or_fallback, local);
    			transition_out(menu.$$.fragment, local);
    			transition_out(default_slot, local);
    			transition_out(menu_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if (grabber_slot_or_fallback) grabber_slot_or_fallback.d(detaching);
    			/*button_binding*/ ctx[27](null);
    			destroy_component(menu);
    			if (default_slot) default_slot.d(detaching);
    			if (menu_slot) menu_slot.d(detaching);
    			/*div4_binding*/ ctx[29](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	var checkTypesForListId,
    		closeMenu,
    		dispatch,
    		draggable,
    		draggableEl,
    		drop,
    		enter,
    		getWidth,
    		indent,
    		indentButtonRef,
    		isInvalid,
    		isOver,
    		leave,
    		mousedown,
    		mouseup,
    		over,
    		showIndentMenu,
    		start,
    		toggleIndentMenu;

    	dispatch = createEventDispatcher();
    	var { index = void 0 } = $$props;
    	var { item = void 0 } = $$props;
    	var { listId = void 0 } = $$props;
    	var { indentable = true } = $$props;
    	var { sameListOnly = false } = $$props;
    	var { showMenu = true } = $$props;
    	showIndentMenu = false;
    	indentButtonRef = void 0;
    	draggableEl = void 0;
    	draggable = false;
    	isOver = false;
    	isInvalid = false;

    	checkTypesForListId = function (types) {
    		return types.find(function (t) {
    			return t.startsWith("listid:");
    		});
    	};

    	start = function (e) {
    		$$invalidate(0, item["listId"] = listId, item);
    		$$invalidate(0, item["index"] = index || null, item);
    		e.dataTransfer.setData("text/plain", JSON.stringify(item));
    		return e.dataTransfer.setData(`listid:${listId}`, JSON.stringify(item));
    	};

    	over = function (e) {
    		var draggedListId;
    		e.preventDefault();
    		$$invalidate(9, isOver = true);

    		if (!!sameListOnly) {
    			draggedListId = checkTypesForListId(e.dataTransfer.types);

    			if (draggedListId != null) {
    				return $$invalidate(8, isInvalid = !(listId === draggedListId.replace("listid:", "")));
    			} else {
    				return $$invalidate(8, isInvalid = true);
    			}
    		}
    	};

    	leave = function (e) {
    		$$invalidate(3, draggable = false);
    		$$invalidate(9, isOver = false);
    		return $$invalidate(8, isInvalid = false);
    	};

    	drop = function (e) {
    		var dragItem, dropped;
    		$$invalidate(9, isOver = false);
    		$$invalidate(8, isInvalid = false);
    		$$invalidate(3, draggable = false);
    		e.preventDefault();
    		dragItem = JSON.parse(e.dataTransfer.getData("text/plain"));
    		dropped = true;

    		if (!!sameListOnly) {
    			// console.log "This list: #{listId} :: itemList #{dragItem.listId}"
    			dropped = listId === dragItem.listId;
    		}

    		if (dropped) {
    			return dispatch("drop", {
    				dragItem,
    				dragIndex: dragItem.index,
    				dragListId: dragItem.listId,
    				dropItem: item,
    				dropIndex: index,
    				dropListId: listId
    			});
    		}
    	};

    	enter = function (e) {
    		console.log("etnered");
    		return console.log(e);
    	};

    	mouseup = function () {
    		$$invalidate(3, draggable = false);
    		return $$invalidate(8, isInvalid = false);
    	};

    	mousedown = function () {
    		return $$invalidate(3, draggable = true);
    	};

    	getWidth = function (el) {
    		if (el != null) {
    			return el.clientWidth - 48;
    		} else {
    			return 0;
    		}
    	};

    	closeMenu = function () {
    		return $$invalidate(14, showIndentMenu = false);
    	};

    	indent = function (indentLevel) {
    		console.log(`indent ${indentLevel}`);
    		dispatch("update", { id: item.id, indent: indentLevel });

    		// console.log {id: item.id, indent: indentLevel }
    		return closeMenu();
    	};

    	toggleIndentMenu = function () {
    		return $$invalidate(14, showIndentMenu = true);
    	};

    	const writable_props = ["index", "item", "listId", "indentable", "sameListOnly", "showMenu"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$k.warn(`<DraggableIndentableItem> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DraggableIndentableItem", $$slots, ['grabber','default','menu']);

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(7, indentButtonRef = $$value);
    		});
    	}

    	function menu_showMenu_binding(value) {
    		showIndentMenu = value;
    		$$invalidate(14, showIndentMenu);
    	}

    	function div4_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(4, draggableEl = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("index" in $$props) $$invalidate(1, index = $$props.index);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(17, listId = $$props.listId);
    		if ("indentable" in $$props) $$invalidate(2, indentable = $$props.indentable);
    		if ("sameListOnly" in $$props) $$invalidate(18, sameListOnly = $$props.sameListOnly);
    		if ("showMenu" in $$props) $$invalidate(19, showMenu = $$props.showMenu);
    		if ("$$scope" in $$props) $$invalidate(30, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		checkTypesForListId,
    		closeMenu,
    		dispatch,
    		draggable,
    		draggableEl,
    		drop,
    		enter,
    		getWidth,
    		indent,
    		indentButtonRef,
    		isInvalid,
    		isOver,
    		leave,
    		mousedown,
    		mouseup,
    		over,
    		showIndentMenu,
    		start,
    		toggleIndentMenu,
    		Row,
    		RowCell,
    		Menu: ComposedMenu,
    		createEventDispatcher,
    		index,
    		item,
    		listId,
    		indentable,
    		sameListOnly,
    		showMenu,
    		draggableWidth
    	});

    	$$self.$inject_state = $$props => {
    		if ("checkTypesForListId" in $$props) checkTypesForListId = $$props.checkTypesForListId;
    		if ("closeMenu" in $$props) closeMenu = $$props.closeMenu;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("draggable" in $$props) $$invalidate(3, draggable = $$props.draggable);
    		if ("draggableEl" in $$props) $$invalidate(4, draggableEl = $$props.draggableEl);
    		if ("drop" in $$props) $$invalidate(5, drop = $$props.drop);
    		if ("enter" in $$props) enter = $$props.enter;
    		if ("getWidth" in $$props) $$invalidate(24, getWidth = $$props.getWidth);
    		if ("indent" in $$props) $$invalidate(6, indent = $$props.indent);
    		if ("indentButtonRef" in $$props) $$invalidate(7, indentButtonRef = $$props.indentButtonRef);
    		if ("isInvalid" in $$props) $$invalidate(8, isInvalid = $$props.isInvalid);
    		if ("isOver" in $$props) $$invalidate(9, isOver = $$props.isOver);
    		if ("leave" in $$props) $$invalidate(10, leave = $$props.leave);
    		if ("mousedown" in $$props) $$invalidate(11, mousedown = $$props.mousedown);
    		if ("mouseup" in $$props) $$invalidate(12, mouseup = $$props.mouseup);
    		if ("over" in $$props) $$invalidate(13, over = $$props.over);
    		if ("showIndentMenu" in $$props) $$invalidate(14, showIndentMenu = $$props.showIndentMenu);
    		if ("start" in $$props) $$invalidate(15, start = $$props.start);
    		if ("toggleIndentMenu" in $$props) $$invalidate(16, toggleIndentMenu = $$props.toggleIndentMenu);
    		if ("index" in $$props) $$invalidate(1, index = $$props.index);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(17, listId = $$props.listId);
    		if ("indentable" in $$props) $$invalidate(2, indentable = $$props.indentable);
    		if ("sameListOnly" in $$props) $$invalidate(18, sameListOnly = $$props.sameListOnly);
    		if ("showMenu" in $$props) $$invalidate(19, showMenu = $$props.showMenu);
    		if ("draggableWidth" in $$props) draggableWidth = $$props.draggableWidth;
    	};

    	let draggableWidth;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*getWidth, draggableEl*/ 16777232) {
    			 draggableWidth = getWidth(draggableEl);
    		}
    	};

    	return [
    		item,
    		index,
    		indentable,
    		draggable,
    		draggableEl,
    		drop,
    		indent,
    		indentButtonRef,
    		isInvalid,
    		isOver,
    		leave,
    		mousedown,
    		mouseup,
    		over,
    		showIndentMenu,
    		start,
    		toggleIndentMenu,
    		listId,
    		sameListOnly,
    		showMenu,
    		checkTypesForListId,
    		closeMenu,
    		dispatch,
    		enter,
    		getWidth,
    		draggableWidth,
    		$$slots,
    		button_binding,
    		menu_showMenu_binding,
    		div4_binding,
    		$$scope
    	];
    }

    class DraggableIndentableItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$I,
    			create_fragment$I,
    			safe_not_equal,
    			{
    				index: 1,
    				item: 0,
    				listId: 17,
    				indentable: 2,
    				sameListOnly: 18,
    				showMenu: 19
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DraggableIndentableItem",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get index() {
    		throw new Error("<DraggableIndentableItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<DraggableIndentableItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<DraggableIndentableItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<DraggableIndentableItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listId() {
    		throw new Error("<DraggableIndentableItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listId(value) {
    		throw new Error("<DraggableIndentableItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indentable() {
    		throw new Error("<DraggableIndentableItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indentable(value) {
    		throw new Error("<DraggableIndentableItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sameListOnly() {
    		throw new Error("<DraggableIndentableItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sameListOnly(value) {
    		throw new Error("<DraggableIndentableItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showMenu() {
    		throw new Error("<DraggableIndentableItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showMenu(value) {
    		throw new Error("<DraggableIndentableItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Lists\Nestable\DroppableDivider.svelte generated by Svelte v3.22.2 */
    const file$F = "src\\svelte\\pages\\_Common\\Lists\\Nestable\\DroppableDivider.svelte";

    function create_fragment$J(ctx) {
    	let div;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "index", /*index*/ ctx[0]);
    			attr_dev(div, "class", "svelte-5o0mfi");
    			toggle_class(div, "over", /*isOver*/ ctx[3]);
    			toggle_class(div, "invalid", /*isInvalid*/ ctx[2]);
    			add_location(div, file$F, 90, 0, 1984);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					div,
    					"drop",
    					function () {
    						if (is_function(/*drop*/ ctx[1])) /*drop*/ ctx[1].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					div,
    					"dragover",
    					function () {
    						if (is_function(/*over*/ ctx[5])) /*over*/ ctx[5].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					div,
    					"dragleave",
    					function () {
    						if (is_function(/*leave*/ ctx[4])) /*leave*/ ctx[4].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (dirty & /*index*/ 1) {
    				attr_dev(div, "index", /*index*/ ctx[0]);
    			}

    			if (dirty & /*isOver*/ 8) {
    				toggle_class(div, "over", /*isOver*/ ctx[3]);
    			}

    			if (dirty & /*isInvalid*/ 4) {
    				toggle_class(div, "invalid", /*isInvalid*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	var checkTypesForListId, dispatch, drop, isInvalid, isOver, leave, over;
    	dispatch = createEventDispatcher();
    	var { index = void 0 } = $$props;
    	var { item = void 0 } = $$props;
    	var { listId = void 0 } = $$props;
    	var { sameListOnly = false } = $$props;
    	isOver = false;
    	isInvalid = false;

    	checkTypesForListId = function (types) {
    		return types.find(function (t) {
    			return t.startsWith("listid:");
    		});
    	};

    	over = function (e) {
    		var draggedListId;
    		e.preventDefault();
    		e.stopPropagation();
    		$$invalidate(3, isOver = true);
    		$$invalidate(2, isInvalid = false);

    		if (!!sameListOnly) {
    			draggedListId = checkTypesForListId(e.dataTransfer.types);

    			if (draggedListId != null) {
    				return $$invalidate(2, isInvalid = !(listId === draggedListId.replace("listid:", "")));
    			} else {
    				return $$invalidate(2, isInvalid = true);
    			}
    		}
    	};

    	//if isInvalid
    	//  return e.preventDefault()
    	//console.log "return is invalid: #{!isInvalid}"
    	// return !isInvalid
    	leave = function (e) {
    		$$invalidate(3, isOver = false);
    		return $$invalidate(2, isInvalid = false);
    	};

    	drop = function (e) {
    		var dragItem, dropped;
    		$$invalidate(3, isOver = false);
    		$$invalidate(2, isInvalid = false);
    		e.preventDefault();
    		dragItem = JSON.parse(e.dataTransfer.getData("text/plain"));
    		dropped = true;

    		if (!!sameListOnly) {
    			// console.log "This list: #{listId} :: itemList #{dragItem.listId}"
    			dropped = listId === dragItem.listId;
    		}

    		if (dropped) {
    			return dispatch("drop", {
    				divider: true,
    				dragItem,
    				dragIndex: dragItem.index,
    				dragListId: dragItem.listId,
    				dropItem: item,
    				dropIndex: index,
    				dropListId: listId
    			});
    		}
    	};

    	const writable_props = ["index", "item", "listId", "sameListOnly"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DroppableDivider> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DroppableDivider", $$slots, []);

    	$$self.$set = $$props => {
    		if ("index" in $$props) $$invalidate(0, index = $$props.index);
    		if ("item" in $$props) $$invalidate(6, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(7, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(8, sameListOnly = $$props.sameListOnly);
    	};

    	$$self.$capture_state = () => ({
    		checkTypesForListId,
    		dispatch,
    		drop,
    		isInvalid,
    		isOver,
    		leave,
    		over,
    		createEventDispatcher,
    		index,
    		item,
    		listId,
    		sameListOnly
    	});

    	$$self.$inject_state = $$props => {
    		if ("checkTypesForListId" in $$props) checkTypesForListId = $$props.checkTypesForListId;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("drop" in $$props) $$invalidate(1, drop = $$props.drop);
    		if ("isInvalid" in $$props) $$invalidate(2, isInvalid = $$props.isInvalid);
    		if ("isOver" in $$props) $$invalidate(3, isOver = $$props.isOver);
    		if ("leave" in $$props) $$invalidate(4, leave = $$props.leave);
    		if ("over" in $$props) $$invalidate(5, over = $$props.over);
    		if ("index" in $$props) $$invalidate(0, index = $$props.index);
    		if ("item" in $$props) $$invalidate(6, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(7, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(8, sameListOnly = $$props.sameListOnly);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [index, drop, isInvalid, isOver, leave, over, item, listId, sameListOnly];
    }

    class DroppableDivider extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {
    			index: 0,
    			item: 6,
    			listId: 7,
    			sameListOnly: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DroppableDivider",
    			options,
    			id: create_fragment$J.name
    		});
    	}

    	get index() {
    		throw new Error("<DroppableDivider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<DroppableDivider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<DroppableDivider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<DroppableDivider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listId() {
    		throw new Error("<DroppableDivider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listId(value) {
    		throw new Error("<DroppableDivider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sameListOnly() {
    		throw new Error("<DroppableDivider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sameListOnly(value) {
    		throw new Error("<DroppableDivider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var HierarchicalList;

    HierarchicalList = (function() {
      class HierarchicalList {
        constructor(list) {
          console.log("hierarchical_list.constructor");
          this.list = list;
        }

        treeify() {
          var reverseList, tree;
          tree = [];
          reverseList = this.list.clone().sort("ordinal", true);
          reverseList.forEach(function(item, index) {
            var ancestors, currentIndent, finishedParents;
            finishedParents = false;
            ancestors = [];
            if (indent > 0) {
              // go up the list until indent = 0
              currentIndent = item.indent;
              reverseList.forEach(function(parent, parentIndex) {
                if (!finishedParents) {
                  if (parent.indent < currentIndent) {
                    ancestors.append(parent.id);
                    currentIndent = parent.indent;
                    if (parent.indent === 0) {
                      return finishedParents = true;
                    }
                  }
                }
              });
            }
            item.ancestors = ancestors;
            return tree.append(item);
          });
          return console.log(tree);
        }

        flatten(tree) {}

        getDragGroup(eventDetail) {
          var dragGroup, draggedIndex, draggedItem, endLoop;
          draggedItem = eventDetail.dragItem;
          draggedIndex = eventDetail.dragIndex;
          dragGroup = [draggedItem];
          endLoop = false;
          this.list.forEach(function(i, index) {
            if (index > draggedIndex) { // do not include the dragged item
              if (i.indent <= draggedItem.indent) {
                endLoop = true;
              }
              if (!endLoop) {
                return dragGroup.append(i);
              }
            }
          });
          return dragGroup;
        }

        shiftOrdinals(insertionIndex, dragGroup) {
          var that;
          that = this;
          return this.list.forEach(function(i, index) {
            if (index > insertionIndex) {
              return that.list[index].ordinal = i.ordinal + dragGroup.length;
            }
          });
        }

        dividerDrop(eventDetail) {
          var dragGroup, dropTarget, indentBase, insertionIndex, matchingItem, minimumIndent, nextItem, ordinalBase, refresh, that;
          that = this;
          refresh = true;
          dragGroup = this.getDragGroup(eventDetail, this.list);
          dropTarget = eventDetail.dropItem;
          insertionIndex = eventDetail.dropIndex;
          this.shiftOrdinals(insertionIndex, dragGroup, this.list);
          if ((eventDetail.dropIndex === -1) || (eventDetail.dropIndex === this.list.length - 1)) { // first or last item, move to root
            indentBase = 0;
          } else {
            if (eventDetail.dragIndex !== eventDetail.dropIndex) {
              console.log(`eventDetail.dragIndex: ${eventDetail.dragIndex}  eventDetail.dropIndex  ${eventDetail.dropIndex}`);
              matchingItem = this.list[eventDetail.dropIndex];
              if (dragGroup.find({
                id: matchingItem.id
              }) == null) {
                // grab the next item after the drop target
                nextItem = this.list[eventDetail.dropIndex + 1];
                // rule
                // match the indent of the item below the divider
                // shift the ordinals after the drop target
                indentBase = nextItem.indent;
              } else {
                refresh = false;
              }
            } else {
              refresh = false;
            }
          }
          if (refresh) {
            console.log(dropTarget);
            if (dropTarget != null) {
              ordinalBase = dropTarget.ordinal + 1;
            } else {
              ordinalBase = 0;
            }
            // need to implement some indentation rules here
            minimumIndent = dragGroup.min(function(i) {
              return i.indent;
            });
            minimumIndent = minimumIndent.indent;
            console.log(`indentBase ${indentBase}, minimumIndent ${minimumIndent}`);
            dragGroup.forEach(function(i, index) {
              var itemToChange;
              console.log(`, (dragGroup[index].indent - minimumIndent) ${dragGroup[index].indent - minimumIndent}`);
              itemToChange = that.list.findIndex({
                id: i.id
              });
              that.list[itemToChange].ordinal = ordinalBase + index;
              return that.list[itemToChange].indent = indentBase + (dragGroup[index].indent - minimumIndent);
            });
            this.list.sortBy("ordinal");
            this.list.forEach(function(i, index) {
              return i.ordinal = index;
            });
          }
          return refresh;
        }

        isInvalidDrop(eventDetail) {
          var dragGroup, matchingItem;
          dragGroup = this.getDragGroup(eventDetail, this.list);
          if (eventDetail.divider == null) {
            if (eventDetail.dragItem.id === eventDetail.dropItem.id) { // otherwise do nothing
              return "Can't drop an item on itself";
            } else if (dragGroup.find({
              id: eventDetail.dropItem.id // otherwise dropped on a child, invalid
            })) {
              return "Can't nest an item as a child in itself";
            } else {
              return null;
            }
          } else {
            matchingItem = this.list[eventDetail.dropIndex];
            console.log("-- Divider Drop");
            console.log(`eventDetail.dragIndex: ${eventDetail.dragIndex} || eventDetail.dropIndex: ${eventDetail.dropIndex}`);
            if ((eventDetail.dragIndex === eventDetail.dropIndex) || (eventDetail.dragIndex === (eventDetail.dropIndex + 1))) {
              console.log("same location");
              return "Same location";
            } else if (eventDetail.dropIndex === -1) {
              return null;
            } else if (dragGroup.find({
              id: matchingItem.id
            }) != null) {
              if (eventDetail.dropIndex === (this.list.length - 1)) { // last item exception
                return null;
              } else {
                console.log("Can't nest an item as a child in itself");
                return "Can't nest an item as a child in itself";
              }
            } else {
              return null;
            }
          }
        }

        itemDrop(eventDetail) {
          var dragGroup, dropTarget, indentBase, insertionIndex, minimumIndent, ordinalBase, refresh, that;
          that = this;
          refresh = false;
          insertionIndex = eventDetail.dropIndex;
          dropTarget = eventDetail.dropItem;
          // todo: what if dropped on a child?
          dragGroup = this.getDragGroup(eventDetail, this.list);
          if (eventDetail.dragItem.id !== eventDetail.dropItem.id) { // otherwise do nothing
            if (!dragGroup.find({
              id: eventDetail.dropItem.id // otherwise dropped on a child, invalid
            })) {
              // shift the ordinals after the drop target
              this.shiftOrdinals(insertionIndex, dragGroup, this.list);
              // move the items

              //---
              indentBase = dropTarget.indent + 1;
              ordinalBase = dropTarget.ordinal + 1;
              // need to implement some indentation rules here
              minimumIndent = dragGroup.min(function(i) {
                return i.indent;
              });
              minimumIndent = minimumIndent.indent;
              dragGroup.forEach(function(i, index) {
                return dragGroup[index].indent = dragGroup[index].indent - minimumIndent;
              });
              dragGroup.forEach(function(i, index) {
                var itemToChange;
                itemToChange = that.list.findIndex({
                  id: i.id
                });
                that.list[itemToChange].ordinal = ordinalBase + index;
                return that.list[itemToChange].indent = indentBase + i.indent;
              });
              //---
              this.list.sortBy("ordinal");
              this.list.forEach(function(i, index) {
                return i.ordinal = index;
              });
              refresh = true;
              refresh = true;
            }
          }
          return refresh;
        }

        dropEvent(eventDetail) {
          var refresh;
          refresh = false;
          if (eventDetail.divider != null) {
            refresh = this.dividerDrop(eventDetail);
          } else {
            refresh = this.itemDrop(eventDetail);
          }
          return refresh;
        }

      }
      HierarchicalList.prototype.list = [];

      return HierarchicalList;

    }).call(commonjsGlobal);

    var hierarchical_list = HierarchicalList;

    /* src\svelte\pages\_Common\Sections\ProjectList.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$7, console: console_1$l } = globals;
    const file$G = "src\\svelte\\pages\\_Common\\Sections\\ProjectList.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[30] = list;
    	child_ctx[31] = i;
    	return child_ctx;
    }

    // (190:2) <PageHeader>
    function create_default_slot_2$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Collections");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(190:2) <PageHeader>",
    		ctx
    	});

    	return block;
    }

    // (192:4) {#if list && list.length}
    function create_if_block$l(ctx) {
    	let div;
    	let t;
    	let current;

    	const droppabledivider = new DroppableDivider({
    			props: {
    				index: -1,
    				listId: /*listId*/ ctx[1],
    				sameListOnly: /*sameListOnly*/ ctx[2]
    			},
    			$$inline: true
    		});

    	droppabledivider.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[6])) /*dropEvent*/ ctx[6].apply(this, arguments);
    	});

    	let each_value = /*sortedlist*/ ctx[12];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(droppabledivider.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$G, 192, 6, 4247);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(droppabledivider, div, null);
    			append_dev(div, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const droppabledivider_changes = {};
    			if (dirty[0] & /*listId*/ 2) droppabledivider_changes.listId = /*listId*/ ctx[1];
    			if (dirty[0] & /*sameListOnly*/ 4) droppabledivider_changes.sameListOnly = /*sameListOnly*/ ctx[2];
    			droppabledivider.$set(droppabledivider_changes);

    			if (dirty[0] & /*sortedlist, listId, sameListOnly, dropEvent, updateAttribute, destroy, style, updateProject, goToItem, itemUrl*/ 8166 | dirty[1] & /*label*/ 2) {
    				each_value = /*sortedlist*/ ctx[12];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(droppabledivider.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(droppabledivider.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(droppabledivider);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(192:4) {#if list && list.length}",
    		ctx
    	});

    	return block;
    }

    // (205:16) <InlineInput bind:value={item.name} on:update={updateProject(item)} on:clicked={goToItem(item)} {style} let:label>
    function create_default_slot_1$6(ctx) {
    	let span;
    	let a;
    	let em;
    	let t_value = (/*label*/ ctx[32] || "No Name") + "";
    	let t;
    	let a_href_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			a = element("a");
    			em = element("em");
    			t = text(t_value);
    			add_location(em, file$G, 205, 86, 5048);
    			attr_dev(a, "href", a_href_value = "" + (/*itemUrl*/ ctx[8] + /*item*/ ctx[3].id));
    			add_location(a, file$G, 205, 33, 4995);
    			attr_dev(span, "ellipsis", "");
    			add_location(span, file$G, 205, 18, 4980);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, span, anchor);
    			append_dev(span, a);
    			append_dev(a, em);
    			append_dev(em, t);
    			if (remount) dispose();
    			dispose = listen_dev(a, "click", prevent_default(/*click_handler*/ ctx[21]), false, true, false);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*label*/ 2 && t_value !== (t_value = (/*label*/ ctx[32] || "No Name") + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*itemUrl, sortedlist*/ 4352 && a_href_value !== (a_href_value = "" + (/*itemUrl*/ ctx[8] + /*item*/ ctx[3].id))) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(205:16) <InlineInput bind:value={item.name} on:update={updateProject(item)} on:clicked={goToItem(item)} {style} let:label>",
    		ctx
    	});

    	return block;
    }

    // (229:12) <div slot="menu">
    function create_menu_slot(ctx) {
    	let div;
    	let current;

    	const menu = new Project({
    			props: { item: /*item*/ ctx[3] },
    			$$inline: true
    		});

    	menu.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[10])) /*updateAttribute*/ ctx[10].apply(this, arguments);
    	});

    	menu.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[5])) /*destroy*/ ctx[5].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(menu.$$.fragment);
    			attr_dev(div, "slot", "menu");
    			add_location(div, file$G, 228, 12, 5760);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(menu, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const menu_changes = {};
    			if (dirty[0] & /*sortedlist*/ 4096) menu_changes.item = /*item*/ ctx[3];
    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(menu);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_menu_slot.name,
    		type: "slot",
    		source: "(229:12) <div slot=\\\"menu\\\">",
    		ctx
    	});

    	return block;
    }

    // (196:10) <DraggableItem item={item} index={index} {listId} {sameListOnly} on:drop={dropEvent} on:update={updateAttribute}>
    function create_default_slot$i(ctx) {
    	let div6;
    	let t0;
    	let div0;
    	let updating_value;
    	let t1;
    	let div1;
    	let updating_value_1;
    	let t2;
    	let div5;
    	let div4;
    	let div2;
    	let div2_present_value;
    	let t3;
    	let div3;
    	let div3_present_value;
    	let t4;
    	let current;

    	const indent = new Indent({
    			props: {
    				level: /*item*/ ctx[3].indent.clamp(0, 5)
    			},
    			$$inline: true
    		});

    	function progresspopover_value_binding(value) {
    		/*progresspopover_value_binding*/ ctx[22].call(null, value, /*item*/ ctx[3]);
    	}

    	let progresspopover_props = { item: /*item*/ ctx[3] };

    	if (/*item*/ ctx[3].progress !== void 0) {
    		progresspopover_props.value = /*item*/ ctx[3].progress;
    	}

    	const progresspopover = new Progress({
    			props: progresspopover_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(progresspopover, "value", progresspopover_value_binding));

    	progresspopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[10])) /*updateAttribute*/ ctx[10].apply(this, arguments);
    	});

    	progresspopover.$on("open", /*open_handler*/ ctx[23]);
    	progresspopover.$on("close", /*close_handler*/ ctx[24]);

    	function inlineinput_value_binding(value) {
    		/*inlineinput_value_binding*/ ctx[25].call(null, value, /*item*/ ctx[3]);
    	}

    	let inlineinput_props = {
    		style: /*style*/ ctx[9],
    		$$slots: {
    			default: [
    				create_default_slot_1$6,
    				({ label }) => ({ 32: label }),
    				({ label }) => [0, label ? 2 : 0]
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*item*/ ctx[3].name !== void 0) {
    		inlineinput_props.value = /*item*/ ctx[3].name;
    	}

    	const inlineinput = new InlineInput({ props: inlineinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(inlineinput, "value", inlineinput_value_binding));

    	inlineinput.$on("update", function () {
    		if (is_function(/*updateProject*/ ctx[11](/*item*/ ctx[3]))) /*updateProject*/ ctx[11](/*item*/ ctx[3]).apply(this, arguments);
    	});

    	inlineinput.$on("clicked", function () {
    		if (is_function(/*goToItem*/ ctx[7](/*item*/ ctx[3]))) /*goToItem*/ ctx[7](/*item*/ ctx[3]).apply(this, arguments);
    	});

    	const duedatepopover = new DueDate({
    			props: {
    				item: /*item*/ ctx[3],
    				value: /*item*/ ctx[3].due_date
    			},
    			$$inline: true
    		});

    	duedatepopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[10])) /*updateAttribute*/ ctx[10].apply(this, arguments);
    	});

    	duedatepopover.$on("open", /*open_handler_1*/ ctx[26]);
    	duedatepopover.$on("close", /*close_handler_1*/ ctx[27]);

    	const estimatepopover = new Time({
    			props: { item: /*item*/ ctx[3] },
    			$$inline: true
    		});

    	estimatepopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[10])) /*updateAttribute*/ ctx[10].apply(this, arguments);
    	});

    	estimatepopover.$on("open", /*open_handler_2*/ ctx[28]);
    	estimatepopover.$on("close", /*close_handler_2*/ ctx[29]);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			create_component(indent.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			create_component(progresspopover.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			create_component(inlineinput.$$.fragment);
    			t2 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			create_component(duedatepopover.$$.fragment);
    			t3 = space();
    			div3 = element("div");
    			create_component(estimatepopover.$$.fragment);
    			t4 = space();
    			attr_dev(div0, "flex", "initial");
    			attr_dev(div0, "section", "progress");
    			add_location(div0, file$G, 199, 14, 4621);
    			attr_dev(div1, "flex", "");
    			attr_dev(div1, "ellipsis", "");
    			add_location(div1, file$G, 203, 14, 4811);
    			attr_dev(div2, "flex", "initial");
    			attr_dev(div2, "present", div2_present_value = /*item*/ ctx[3].due_date != null);
    			attr_dev(div2, "class", "svelte-j6f7mf");
    			add_location(div2, file$G, 214, 18, 5273);
    			attr_dev(div3, "flex", "initial");
    			attr_dev(div3, "present", div3_present_value = (/*item*/ ctx[3].estimate || 0) > 0);
    			set_style(div3, "padding-left", "8px");
    			attr_dev(div3, "class", "svelte-j6f7mf");
    			add_location(div3, file$G, 217, 18, 5481);
    			attr_dev(div4, "layout", "row");
    			add_location(div4, file$G, 209, 16, 5192);
    			attr_dev(div5, "flex", "initial");
    			add_location(div5, file$G, 208, 14, 5155);
    			attr_dev(div6, "layout", "row");
    			attr_dev(div6, "type", "list-item");
    			attr_dev(div6, "class", "svelte-j6f7mf");
    			add_location(div6, file$G, 196, 12, 4515);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			mount_component(indent, div6, null);
    			append_dev(div6, t0);
    			append_dev(div6, div0);
    			mount_component(progresspopover, div0, null);
    			append_dev(div6, t1);
    			append_dev(div6, div1);
    			mount_component(inlineinput, div1, null);
    			append_dev(div6, t2);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			mount_component(duedatepopover, div2, null);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			mount_component(estimatepopover, div3, null);
    			insert_dev(target, t4, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const indent_changes = {};
    			if (dirty[0] & /*sortedlist*/ 4096) indent_changes.level = /*item*/ ctx[3].indent.clamp(0, 5);
    			indent.$set(indent_changes);
    			const progresspopover_changes = {};
    			if (dirty[0] & /*sortedlist*/ 4096) progresspopover_changes.item = /*item*/ ctx[3];

    			if (!updating_value && dirty[0] & /*sortedlist*/ 4096) {
    				updating_value = true;
    				progresspopover_changes.value = /*item*/ ctx[3].progress;
    				add_flush_callback(() => updating_value = false);
    			}

    			progresspopover.$set(progresspopover_changes);
    			const inlineinput_changes = {};
    			if (dirty[0] & /*style*/ 512) inlineinput_changes.style = /*style*/ ctx[9];

    			if (dirty[0] & /*itemUrl, sortedlist*/ 4352 | dirty[1] & /*$$scope, label*/ 6) {
    				inlineinput_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value_1 && dirty[0] & /*sortedlist*/ 4096) {
    				updating_value_1 = true;
    				inlineinput_changes.value = /*item*/ ctx[3].name;
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			inlineinput.$set(inlineinput_changes);
    			const duedatepopover_changes = {};
    			if (dirty[0] & /*sortedlist*/ 4096) duedatepopover_changes.item = /*item*/ ctx[3];
    			if (dirty[0] & /*sortedlist*/ 4096) duedatepopover_changes.value = /*item*/ ctx[3].due_date;
    			duedatepopover.$set(duedatepopover_changes);

    			if (!current || dirty[0] & /*sortedlist*/ 4096 && div2_present_value !== (div2_present_value = /*item*/ ctx[3].due_date != null)) {
    				attr_dev(div2, "present", div2_present_value);
    			}

    			const estimatepopover_changes = {};
    			if (dirty[0] & /*sortedlist*/ 4096) estimatepopover_changes.item = /*item*/ ctx[3];
    			estimatepopover.$set(estimatepopover_changes);

    			if (!current || dirty[0] & /*sortedlist*/ 4096 && div3_present_value !== (div3_present_value = (/*item*/ ctx[3].estimate || 0) > 0)) {
    				attr_dev(div3, "present", div3_present_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indent.$$.fragment, local);
    			transition_in(progresspopover.$$.fragment, local);
    			transition_in(inlineinput.$$.fragment, local);
    			transition_in(duedatepopover.$$.fragment, local);
    			transition_in(estimatepopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indent.$$.fragment, local);
    			transition_out(progresspopover.$$.fragment, local);
    			transition_out(inlineinput.$$.fragment, local);
    			transition_out(duedatepopover.$$.fragment, local);
    			transition_out(estimatepopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(indent);
    			destroy_component(progresspopover);
    			destroy_component(inlineinput);
    			destroy_component(duedatepopover);
    			destroy_component(estimatepopover);
    			if (detaching) detach_dev(t4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(196:10) <DraggableItem item={item} index={index} {listId} {sameListOnly} on:drop={dropEvent} on:update={updateAttribute}>",
    		ctx
    	});

    	return block;
    }

    // (195:8) {#each sortedlist as item, index}
    function create_each_block$7(ctx) {
    	let t;
    	let current;

    	const draggableitem = new DraggableIndentableItem({
    			props: {
    				item: /*item*/ ctx[3],
    				index: /*index*/ ctx[31],
    				listId: /*listId*/ ctx[1],
    				sameListOnly: /*sameListOnly*/ ctx[2],
    				$$slots: {
    					default: [create_default_slot$i],
    					menu: [create_menu_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	draggableitem.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[6])) /*dropEvent*/ ctx[6].apply(this, arguments);
    	});

    	draggableitem.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[10])) /*updateAttribute*/ ctx[10].apply(this, arguments);
    	});

    	const droppabledivider = new DroppableDivider({
    			props: {
    				item: /*item*/ ctx[3],
    				index: /*index*/ ctx[31],
    				listId: /*listId*/ ctx[1],
    				sameListOnly: /*sameListOnly*/ ctx[2]
    			},
    			$$inline: true
    		});

    	droppabledivider.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[6])) /*dropEvent*/ ctx[6].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(draggableitem.$$.fragment);
    			t = space();
    			create_component(droppabledivider.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(draggableitem, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(droppabledivider, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const draggableitem_changes = {};
    			if (dirty[0] & /*sortedlist*/ 4096) draggableitem_changes.item = /*item*/ ctx[3];
    			if (dirty[0] & /*listId*/ 2) draggableitem_changes.listId = /*listId*/ ctx[1];
    			if (dirty[0] & /*sameListOnly*/ 4) draggableitem_changes.sameListOnly = /*sameListOnly*/ ctx[2];

    			if (dirty[0] & /*sortedlist, updateAttribute, destroy, style, updateProject, goToItem, itemUrl*/ 8096 | dirty[1] & /*$$scope*/ 4) {
    				draggableitem_changes.$$scope = { dirty, ctx };
    			}

    			draggableitem.$set(draggableitem_changes);
    			const droppabledivider_changes = {};
    			if (dirty[0] & /*sortedlist*/ 4096) droppabledivider_changes.item = /*item*/ ctx[3];
    			if (dirty[0] & /*listId*/ 2) droppabledivider_changes.listId = /*listId*/ ctx[1];
    			if (dirty[0] & /*sameListOnly*/ 4) droppabledivider_changes.sameListOnly = /*sameListOnly*/ ctx[2];
    			droppabledivider.$set(droppabledivider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(draggableitem.$$.fragment, local);
    			transition_in(droppabledivider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(draggableitem.$$.fragment, local);
    			transition_out(droppabledivider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(draggableitem, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(droppabledivider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(195:8) {#each sortedlist as item, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let t0;
    	let section;
    	let t1;
    	let current;

    	const pageheader = new PageHeader({
    			props: {
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*list*/ ctx[0] && /*list*/ ctx[0].length && create_if_block$l(ctx);

    	const quickentry = new GenericItem({
    			props: { stubPlaceholder: "Add Collection" },
    			$$inline: true
    		});

    	quickentry.$on("add", function () {
    		if (is_function(/*add*/ ctx[4])) /*add*/ ctx[4].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(pageheader.$$.fragment);
    			t0 = space();
    			section = element("section");
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(quickentry.$$.fragment);
    			attr_dev(section, "class", "svelte-j6f7mf");
    			add_location(section, file$G, 190, 2, 4201);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(pageheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, section, anchor);
    			if (if_block) if_block.m(section, null);
    			append_dev(section, t1);
    			mount_component(quickentry, section, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const pageheader_changes = {};

    			if (dirty[1] & /*$$scope*/ 4) {
    				pageheader_changes.$$scope = { dirty, ctx };
    			}

    			pageheader.$set(pageheader_changes);

    			if (/*list*/ ctx[0] && /*list*/ ctx[0].length) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*list*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(section, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pageheader.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(quickentry.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pageheader.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(quickentry.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pageheader, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(section);
    			if (if_block) if_block.d();
    			destroy_component(quickentry);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	var add,
    		destroy,
    		dispatch,
    		dropEvent,
    		goToItem,
    		hasAssignments,
    		itemUrl,
    		showComments,
    		sort,
    		style,
    		subDocument,
    		update,
    		updateAttribute,
    		updateProject;

    	dispatch = createEventDispatcher();
    	var { assignments = [] } = $$props;
    	var { collection = "tasks" } = $$props;
    	var { list = void 0 } = $$props;
    	var { item = void 0 } = $$props;
    	itemUrl = "#/projects/";
    	subDocument = new project();

    	showComments = function (item) {
    		if (item.comments != null) {
    			return item.comments.length > 0;
    		} else {
    			return false;
    		}
    	};

    	goToItem = function (item) {
    		return push(`/projects/${item.id}`);
    	};

    	updateProject = function (p) {
    		$$invalidate(0, list); // refresh array

    		// preclean the ordinals
    		list.forEach(function (item, index) {
    			item.ordinal = index;

    			if (isNaN(item.indent) || item.indent == null) {
    				return item.indent = 0;
    			}
    		});

    		console.log(p);
    		return dispatch("update", p);
    	};

    	updateAttribute = function (e) {
    		var change, changedItem;
    		console.log("ListItme.svelte updateAttribute");
    		console.log(e.detail);
    		change = e.detail;

    		// change["id"] = item.id
    		changedItem = list.find({ id: change.id });

    		Object.merge(changedItem, change);
    		$$invalidate(0, list); // refresh array

    		// preclean the ordinals
    		list.forEach(function (item, index) {
    			item.ordinal = index;

    			if (isNaN(item.indent) || item.indent == null) {
    				return item.indent = 0;
    			}
    		});

    		console.log(change);
    		return dispatch("update", change);
    	};

    	add = function (e) {
    		return dispatch("add", e.detail);
    	};

    	hasAssignments = function () {
    		var output;
    		output = false;

    		if (item.assignments != null) {
    			output = item.assignments.length > 0;
    		}

    		return output;
    	};

    	update = function () {
    		return dispatch("update");
    	};

    	destroy = function (e) {
    		return dispatch("destroy", e.detail);
    	};

    	sort = function (list) {
    		if (list != null) {
    			return list.sortBy("ordinal");
    		} else {
    			return [];
    		}
    	};

    	var { listId = uuid() } = $$props;
    	var { sameListOnly = true } = $$props;

    	// drag and drop
    	dropEvent = function (e) {
    		var invalidDrop, refresh, tree;
    		refresh = false;
    		tree = new hierarchical_list(list);
    		invalidDrop = tree.isInvalidDrop(e.detail);

    		if (invalidDrop != null) ; else {
    			refresh = tree.dropEvent(e.detail);
    		}

    		if (refresh) {
    			$$invalidate(0, list = tree.list);
    			return dispatch("update");
    		}
    	};

    	style = ":hover {font-weight: bold}";

    	add = function (event) {
    		var newRecord, scb;
    		newRecord = subDocument.stub(event.detail);

    		scb = function (inserted) {
    			console.log(inserted);
    			return push(`/projects/${inserted.id}`);
    		};

    		newRecord.ordinal = (list || []).length;
    		return subDocument.insert(newRecord, scb, null, null);
    	};

    	const writable_props = ["assignments", "collection", "list", "item", "listId", "sameListOnly"];

    	Object_1$7.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$l.warn(`<ProjectList> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ProjectList", $$slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function progresspopover_value_binding(value, item) {
    		item.progress = value;
    		(($$invalidate(12, sortedlist), $$invalidate(18, sort)), $$invalidate(0, list));
    	}

    	function open_handler(event) {
    		bubble($$self, event);
    	}

    	function close_handler(event) {
    		bubble($$self, event);
    	}

    	function inlineinput_value_binding(value, item) {
    		item.name = value;
    		(($$invalidate(12, sortedlist), $$invalidate(18, sort)), $$invalidate(0, list));
    	}

    	function open_handler_1(event) {
    		bubble($$self, event);
    	}

    	function close_handler_1(event) {
    		bubble($$self, event);
    	}

    	function open_handler_2(event) {
    		bubble($$self, event);
    	}

    	function close_handler_2(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("assignments" in $$props) $$invalidate(13, assignments = $$props.assignments);
    		if ("collection" in $$props) $$invalidate(14, collection = $$props.collection);
    		if ("list" in $$props) $$invalidate(0, list = $$props.list);
    		if ("item" in $$props) $$invalidate(3, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(1, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(2, sameListOnly = $$props.sameListOnly);
    	};

    	$$self.$capture_state = () => ({
    		add,
    		destroy,
    		dispatch,
    		dropEvent,
    		goToItem,
    		hasAssignments,
    		itemUrl,
    		showComments,
    		sort,
    		style,
    		subDocument,
    		update,
    		updateAttribute,
    		updateProject,
    		onMount,
    		createEventDispatcher,
    		push,
    		pop,
    		replace,
    		location: location$1,
    		Indent,
    		DraggableItem: DraggableIndentableItem,
    		DroppableDivider,
    		QuickEntry: GenericItem,
    		Menu: Project,
    		InlineInput,
    		PageHeader,
    		ProgressPopover: Progress,
    		DueDatePopover: DueDate,
    		EstimatePopover: Time,
    		HierarchicalList: hierarchical_list,
    		Section,
    		assignments,
    		collection,
    		Project: project,
    		Assignment: assignment,
    		list,
    		item,
    		listId,
    		sameListOnly,
    		sortedlist
    	});

    	$$self.$inject_state = $$props => {
    		if ("add" in $$props) $$invalidate(4, add = $$props.add);
    		if ("destroy" in $$props) $$invalidate(5, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("dropEvent" in $$props) $$invalidate(6, dropEvent = $$props.dropEvent);
    		if ("goToItem" in $$props) $$invalidate(7, goToItem = $$props.goToItem);
    		if ("hasAssignments" in $$props) hasAssignments = $$props.hasAssignments;
    		if ("itemUrl" in $$props) $$invalidate(8, itemUrl = $$props.itemUrl);
    		if ("showComments" in $$props) showComments = $$props.showComments;
    		if ("sort" in $$props) $$invalidate(18, sort = $$props.sort);
    		if ("style" in $$props) $$invalidate(9, style = $$props.style);
    		if ("subDocument" in $$props) subDocument = $$props.subDocument;
    		if ("update" in $$props) update = $$props.update;
    		if ("updateAttribute" in $$props) $$invalidate(10, updateAttribute = $$props.updateAttribute);
    		if ("updateProject" in $$props) $$invalidate(11, updateProject = $$props.updateProject);
    		if ("assignments" in $$props) $$invalidate(13, assignments = $$props.assignments);
    		if ("collection" in $$props) $$invalidate(14, collection = $$props.collection);
    		if ("list" in $$props) $$invalidate(0, list = $$props.list);
    		if ("item" in $$props) $$invalidate(3, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(1, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(2, sameListOnly = $$props.sameListOnly);
    		if ("sortedlist" in $$props) $$invalidate(12, sortedlist = $$props.sortedlist);
    	};

    	let sortedlist;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*sort, list*/ 262145) {
    			 $$invalidate(12, sortedlist = sort(list));
    		}
    	};

    	return [
    		list,
    		listId,
    		sameListOnly,
    		item,
    		add,
    		destroy,
    		dropEvent,
    		goToItem,
    		itemUrl,
    		style,
    		updateAttribute,
    		updateProject,
    		sortedlist,
    		assignments,
    		collection,
    		dispatch,
    		hasAssignments,
    		showComments,
    		sort,
    		subDocument,
    		update,
    		click_handler,
    		progresspopover_value_binding,
    		open_handler,
    		close_handler,
    		inlineinput_value_binding,
    		open_handler_1,
    		close_handler_1,
    		open_handler_2,
    		close_handler_2
    	];
    }

    class ProjectList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$K,
    			create_fragment$K,
    			safe_not_equal,
    			{
    				assignments: 13,
    				collection: 14,
    				list: 0,
    				item: 3,
    				listId: 1,
    				sameListOnly: 2
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ProjectList",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get assignments() {
    		throw new Error("<ProjectList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set assignments(value) {
    		throw new Error("<ProjectList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collection() {
    		throw new Error("<ProjectList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collection(value) {
    		throw new Error("<ProjectList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get list() {
    		throw new Error("<ProjectList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set list(value) {
    		throw new Error("<ProjectList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<ProjectList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<ProjectList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listId() {
    		throw new Error("<ProjectList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listId(value) {
    		throw new Error("<ProjectList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sameListOnly() {
    		throw new Error("<ProjectList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sameListOnly(value) {
    		throw new Error("<ProjectList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\Projects\Index.svelte generated by Svelte v3.22.2 */

    // (64:0) <PageContent>
    function create_default_slot$j(ctx) {
    	let current;

    	const projectlist = new ProjectList({
    			props: {
    				list: /*list*/ ctx[1],
    				itemUrl: "#/projects/"
    			},
    			$$inline: true
    		});

    	projectlist.$on("update", function () {
    		if (is_function(/*updateProject*/ ctx[2])) /*updateProject*/ ctx[2].apply(this, arguments);
    	});

    	projectlist.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[0])) /*destroy*/ ctx[0].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(projectlist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(projectlist, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const projectlist_changes = {};
    			if (dirty & /*list*/ 2) projectlist_changes.list = /*list*/ ctx[1];
    			projectlist.$set(projectlist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(projectlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(projectlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(projectlist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(64:0) <PageContent>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let t;
    	let current;

    	const pagecontent = new PageContent({
    			props: {
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(pagecontent.$$.fragment);
    			document.title = "Collections";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(pagecontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const pagecontent_changes = {};

    			if (dirty & /*$$scope, list, updateProject, destroy*/ 263) {
    				pagecontent_changes.$$scope = { dirty, ctx };
    			}

    			pagecontent.$set(pagecontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagecontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagecontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(pagecontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	var deferredUpdate,
    		destroy,
    		getProject,
    		getProjects,
    		jump,
    		list,
    		resource,
    		updateProject;

    	list = [];
    	resource = new project();

    	getProjects = function () {
    		var scb;

    		scb = function (projects) {
    			return $$invalidate(1, list = projects);
    		};

    		return resource.select(scb, null, null);
    	};

    	getProjects();

    	getProject = function () {
    		var scb;

    		scb = function (doc) {
    			var project;
    			return project = doc;
    		};

    		return resource.selectOne(id, scb, null, null);
    	};

    	destroy = function (e) {
    		var scb;

    		scb = function () {
    			return getProjects();
    		};

    		return resource.destroy(e.detail.id, scb, null, null);
    	};

    	updateProject = function (e) {
    		var ecb, scb;

    		scb = function (updated) {
    			return getProjects();
    		};

    		ecb = function (err) {
    			return getProjects();
    		};

    		return resource.updateAttributes(e.detail, scb, ecb, null);
    	};

    	deferredUpdate = updateProject.debounce(500);

    	jump = function (anchorName) {
    		var elem, scrollContainer;
    		elem = u(`[name=${anchorName}]`);
    		scrollContainer = u("body > main > section").first();
    		return scrollContainer.scrollTop = elem.first().offsetTop - 40;
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Index> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Index", $$slots, []);

    	$$self.$capture_state = () => ({
    		deferredUpdate,
    		destroy,
    		getProject,
    		getProjects,
    		jump,
    		list,
    		resource,
    		updateProject,
    		Project: project,
    		PageContent,
    		ProjectList
    	});

    	$$self.$inject_state = $$props => {
    		if ("deferredUpdate" in $$props) deferredUpdate = $$props.deferredUpdate;
    		if ("destroy" in $$props) $$invalidate(0, destroy = $$props.destroy);
    		if ("getProject" in $$props) getProject = $$props.getProject;
    		if ("getProjects" in $$props) getProjects = $$props.getProjects;
    		if ("jump" in $$props) jump = $$props.jump;
    		if ("list" in $$props) $$invalidate(1, list = $$props.list);
    		if ("resource" in $$props) resource = $$props.resource;
    		if ("updateProject" in $$props) $$invalidate(2, updateProject = $$props.updateProject);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [destroy, list, updateProject];
    }

    class Index extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Index",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* src\svelte\pages\_Common\Menus\Favorites.svelte generated by Svelte v3.22.2 */
    const file$H = "src\\svelte\\pages\\_Common\\Menus\\Favorites.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[0] = list[i];
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (108:4) {#if list}
    function create_if_block$m(ctx) {
    	let hr;
    	let t;
    	let each_1_anchor;
    	let each_value = /*sortedlist*/ ctx[8];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			attr_dev(hr, "class", "svelte-1alz1sx");
    			add_location(hr, file$H, 108, 4, 2304);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*goToProject, sortedlist*/ 264) {
    				each_value = /*sortedlist*/ ctx[8];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(108:4) {#if list}",
    		ctx
    	});

    	return block;
    }

    // (110:4) {#each sortedlist as item, index}
    function create_each_block$8(ctx) {
    	let li;
    	let button;
    	let span;
    	let t0_value = /*item*/ ctx[0].name + "";
    	let t0;
    	let t1;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(span, "ellipsis", "");
    			attr_dev(span, "class", "svelte-1alz1sx");
    			add_location(span, file$H, 111, 66, 2423);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "ellipsis", "");
    			attr_dev(button, "class", "svelte-1alz1sx");
    			add_location(button, file$H, 111, 6, 2363);
    			attr_dev(li, "class", "svelte-1alz1sx");
    			add_location(li, file$H, 110, 4, 2352);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			append_dev(button, span);
    			append_dev(span, t0);
    			append_dev(li, t1);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*goToProject*/ ctx[3](/*item*/ ctx[0]))) /*goToProject*/ ctx[3](/*item*/ ctx[0]).apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*sortedlist*/ 256 && t0_value !== (t0_value = /*item*/ ctx[0].name + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(110:4) {#each sortedlist as item, index}",
    		ctx
    	});

    	return block;
    }

    // (101:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align="left" {width} matchTrigger={true}>
    function create_default_slot$k(ctx) {
    	let ul;
    	let li;
    	let button;
    	let t1;
    	let dispose;
    	let if_block = /*list*/ ctx[4] && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li = element("li");
    			button = element("button");
    			button.textContent = "Collections";
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "svelte-1alz1sx");
    			add_location(button, file$H, 104, 6, 2204);
    			attr_dev(li, "class", "svelte-1alz1sx");
    			add_location(li, file$H, 103, 4, 2193);
    			attr_dev(ul, "class", "svelte-1alz1sx");
    			add_location(ul, file$H, 101, 2, 2183);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li);
    			append_dev(li, button);
    			append_dev(ul, t1);
    			if (if_block) if_block.m(ul, null);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*goToCollections*/ ctx[2])) /*goToCollections*/ ctx[2].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*list*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$m(ctx);
    					if_block.c();
    					if_block.m(ul, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (if_block) if_block.d();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(101:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align=\\\"left\\\" {width} matchTrigger={true}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let span;
    	let a;
    	let em;
    	let t1;
    	let updating_showMenu;
    	let current;
    	let dispose;

    	function menu_showMenu_binding(value) {
    		/*menu_showMenu_binding*/ ctx[16].call(null, value);
    	}

    	let menu_props = {
    		trigger: /*menuButtonRef*/ ctx[5],
    		align: "left",
    		width: /*width*/ ctx[7],
    		matchTrigger: true,
    		$$slots: { default: [create_default_slot$k] },
    		$$scope: { ctx }
    	};

    	if (/*showMenu*/ ctx[6] !== void 0) {
    		menu_props.showMenu = /*showMenu*/ ctx[6];
    	}

    	const menu = new ComposedMenuFavorites({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "showMenu", menu_showMenu_binding));

    	const block = {
    		c: function create() {
    			span = element("span");
    			a = element("a");
    			em = element("em");
    			em.textContent = "Collections";
    			t1 = space();
    			create_component(menu.$$.fragment);
    			add_location(em, file$H, 99, 77, 2059);
    			attr_dev(a, "href", "#/projects");
    			add_location(a, file$H, 99, 0, 1982);
    			attr_dev(span, "class", "svelte-1alz1sx");
    			add_location(span, file$H, 98, 0, 1975);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, span, anchor);
    			append_dev(span, a);
    			append_dev(a, em);
    			/*a_binding*/ ctx[15](a);
    			append_dev(span, t1);
    			mount_component(menu, span, null);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				a,
    				"mouseover",
    				function () {
    					if (is_function(/*debouncedMenu*/ ctx[1])) /*debouncedMenu*/ ctx[1].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const menu_changes = {};
    			if (dirty & /*menuButtonRef*/ 32) menu_changes.trigger = /*menuButtonRef*/ ctx[5];
    			if (dirty & /*width*/ 128) menu_changes.width = /*width*/ ctx[7];

    			if (dirty & /*$$scope, sortedlist, goToProject, list, goToCollections*/ 524572) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_showMenu && dirty & /*showMenu*/ 64) {
    				updating_showMenu = true;
    				menu_changes.showMenu = /*showMenu*/ ctx[6];
    				add_flush_callback(() => updating_showMenu = false);
    			}

    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			/*a_binding*/ ctx[15](null);
    			destroy_component(menu);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	var closeMenu,
    		debouncedMenu,
    		dispatch,
    		getProjects,
    		goToCollections,
    		goToProject,
    		list,
    		menuButtonRef,
    		openMenu,
    		resource,
    		showMenu,
    		sort,
    		width;

    	dispatch = createEventDispatcher();
    	resource = new project();
    	list = [];

    	getProjects = function () {
    		var scb;

    		scb = function (projects) {
    			return $$invalidate(4, list = projects);
    		};

    		return resource.select(scb, null, null);
    	};

    	getProjects();
    	var { item = void 0 } = $$props;
    	menuButtonRef = void 0;
    	showMenu = false;

    	goToCollections = function () {
    		return push("#/projects");
    	};

    	goToProject = function (item) {
    		$$invalidate(6, showMenu = false);
    		return push(`#/projects/${item.id}`);
    	};

    	openMenu = function () {
    		return $$invalidate(6, showMenu = true);
    	};

    	closeMenu = function () {
    		return $$invalidate(6, showMenu = false);
    	};

    	debouncedMenu = openMenu.debounce(500);
    	width = "200px";

    	sort = function (list) {
    		if (list != null) {
    			return list.sortBy("ordinal");
    		} else {
    			return [];
    		}
    	};

    	const writable_props = ["item"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Favorites> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Favorites", $$slots, []);

    	function a_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(5, menuButtonRef = $$value);
    		});
    	}

    	function menu_showMenu_binding(value) {
    		showMenu = value;
    		$$invalidate(6, showMenu);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({
    		closeMenu,
    		debouncedMenu,
    		dispatch,
    		getProjects,
    		goToCollections,
    		goToProject,
    		list,
    		menuButtonRef,
    		openMenu,
    		resource,
    		showMenu,
    		sort,
    		width,
    		createEventDispatcher,
    		push,
    		Menu: ComposedMenuFavorites,
    		Project: project,
    		item,
    		sortedlist
    	});

    	$$self.$inject_state = $$props => {
    		if ("closeMenu" in $$props) closeMenu = $$props.closeMenu;
    		if ("debouncedMenu" in $$props) $$invalidate(1, debouncedMenu = $$props.debouncedMenu);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("getProjects" in $$props) getProjects = $$props.getProjects;
    		if ("goToCollections" in $$props) $$invalidate(2, goToCollections = $$props.goToCollections);
    		if ("goToProject" in $$props) $$invalidate(3, goToProject = $$props.goToProject);
    		if ("list" in $$props) $$invalidate(4, list = $$props.list);
    		if ("menuButtonRef" in $$props) $$invalidate(5, menuButtonRef = $$props.menuButtonRef);
    		if ("openMenu" in $$props) openMenu = $$props.openMenu;
    		if ("resource" in $$props) resource = $$props.resource;
    		if ("showMenu" in $$props) $$invalidate(6, showMenu = $$props.showMenu);
    		if ("sort" in $$props) $$invalidate(14, sort = $$props.sort);
    		if ("width" in $$props) $$invalidate(7, width = $$props.width);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("sortedlist" in $$props) $$invalidate(8, sortedlist = $$props.sortedlist);
    	};

    	let sortedlist;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*sort, list*/ 16400) {
    			 $$invalidate(8, sortedlist = sort(list));
    		}
    	};

    	return [
    		item,
    		debouncedMenu,
    		goToCollections,
    		goToProject,
    		list,
    		menuButtonRef,
    		showMenu,
    		width,
    		sortedlist,
    		closeMenu,
    		dispatch,
    		getProjects,
    		openMenu,
    		resource,
    		sort,
    		a_binding,
    		menu_showMenu_binding
    	];
    }

    class Favorites extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, { item: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Favorites",
    			options,
    			id: create_fragment$M.name
    		});
    	}

    	get item() {
    		throw new Error("<Favorites>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Favorites>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Quill\Quill.svelte generated by Svelte v3.22.2 */
    const file$I = "src\\svelte\\pages\\_Common\\Quill\\Quill.svelte";

    function create_fragment$N(ctx) {
    	let div;
    	let raw_value = (/*content*/ ctx[0] || "") + "";

    	const block = {
    		c: function create() {
    			div = element("div");
    			add_location(div, file$I, 445, 0, 52786);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    			/*div_binding*/ ctx[6](div);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*content*/ 1 && raw_value !== (raw_value = (/*content*/ ctx[0] || "") + "")) div.innerHTML = raw_value;		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[6](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	var dispatch, editorRef, quill;
    	dispatch = createEventDispatcher();

    	var { toolbarOptions = [
    		[{ header: 1 }, { header: 2 }, "blockquote", "link", "image", "video"],
    		["bold", "italic", "underline", "strike", "code"],
    		["image", "code-block"],
    		[{ list: "ordered" }, { list: "ordered" }],
    		[{ align: [] }],
    		["clean"]
    	] } = $$props;

    	var { placeholder = "Type something..." } = $$props;
    	var { content = void 0 } = $$props;
    	editorRef = void 0;
    	quill = void 0;

    	hljs.configure({
    		languages: ["javascript", "ruby", "python"]
    	});

    	onMount(function () {
    		quill = new Quill(editorRef,
    		{
    				modules: {
    					// syntax: true
    					toolbar: toolbarOptions,
    					markdownShortcuts: {},
    					table: true
    				},
    				//tableUI: true
    				//magicUrl:
    				//  # Regex used to check URLs during typing
    				//  urlRegularExpression: /(https?:\/\/[\S]+)|(www.[\S]+)|(mailto:[\S]+)|(tel:[\S]+)/,
    				//  # Regex used to check URLs on paste
    				//  globalRegularExpression: /(https?:\/\/|www\.|mailto:|tel:)[\S]+/g
    				// table: false # disable table module
    				//"better-table":
    				//  operationMenu:
    				//    items:
    				//      unmergeCells:
    				//        text: 'Another unmerge cells name'
    				//keyboard:
    				//  bindings: QuillBetterTable.keyboardBindings
    				placeholder,
    				theme: "bubble"
    			});

    		return quill.on("editor-change", function (eventName, ...args) {
    			var changes, html, text;
    			html = editorRef.children[0].innerHTML;
    			text = editorRef.children[0].innerText;

    			changes = {
    				type: "selection-change",
    				html,
    				text,
    				event: eventName,
    				args
    			};

    			return dispatch("change", changes);
    		});
    	});

    	const writable_props = ["toolbarOptions", "placeholder", "content"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Quill> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Quill", $$slots, []);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(1, editorRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("toolbarOptions" in $$props) $$invalidate(2, toolbarOptions = $$props.toolbarOptions);
    		if ("placeholder" in $$props) $$invalidate(3, placeholder = $$props.placeholder);
    		if ("content" in $$props) $$invalidate(0, content = $$props.content);
    	};

    	$$self.$capture_state = () => ({
    		dispatch,
    		editorRef,
    		quill,
    		createEventDispatcher,
    		onMount,
    		toolbarOptions,
    		placeholder,
    		content
    	});

    	$$self.$inject_state = $$props => {
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("editorRef" in $$props) $$invalidate(1, editorRef = $$props.editorRef);
    		if ("quill" in $$props) quill = $$props.quill;
    		if ("toolbarOptions" in $$props) $$invalidate(2, toolbarOptions = $$props.toolbarOptions);
    		if ("placeholder" in $$props) $$invalidate(3, placeholder = $$props.placeholder);
    		if ("content" in $$props) $$invalidate(0, content = $$props.content);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [content, editorRef, toolbarOptions, placeholder, dispatch, quill, div_binding];
    }

    class Quill_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {
    			toolbarOptions: 2,
    			placeholder: 3,
    			content: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Quill_1",
    			options,
    			id: create_fragment$N.name
    		});
    	}

    	get toolbarOptions() {
    		throw new Error("<Quill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toolbarOptions(value) {
    		throw new Error("<Quill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Quill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Quill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content() {
    		throw new Error("<Quill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<Quill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Quill\Viewer.svelte generated by Svelte v3.22.2 */

    const file$J = "src\\svelte\\pages\\_Common\\Quill\\Viewer.svelte";

    function create_fragment$O(ctx) {
    	let div1;
    	let article;
    	let div0;
    	let raw_value = /*setContent*/ ctx[1](/*content*/ ctx[0]) + "";
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			article = element("article");
    			div0 = element("div");
    			attr_dev(div0, "class", "ql-editor");
    			add_location(div0, file$J, 31, 42, 730);
    			attr_dev(article, "class", "ql-container ql-bubble");
    			add_location(article, file$J, 31, 2, 690);
    			add_location(div1, file$J, 30, 0, 670);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, article);
    			append_dev(article, div0);
    			div0.innerHTML = raw_value;
    			if (remount) dispose();
    			dispose = listen_dev(div1, "dblclick", /*dblclick_handler*/ ctx[8], false, false, false);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*setContent, content*/ 3 && raw_value !== (raw_value = /*setContent*/ ctx[1](/*content*/ ctx[0]) + "")) div0.innerHTML = raw_value;		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	var setContent;
    	var { actions = [] } = $$props;
    	var { height = "300px" } = $$props;
    	var { html = "" } = $$props;
    	var { useMarkdown = false } = $$props;
    	var { content = void 0 } = $$props;
    	var { id = `viewer-${uuid()}` } = $$props;
    	var { placeholder = "This document is currently empty. Edit it to add content." } = $$props;

    	setContent = function (content) {
    		if ((content || "").trim().compact().length === 0) {
    			return `<div class='placeholder' style='color: var(--gray);'>${placeholder}</div>`;
    		} else {
    			return content;
    		}
    	};

    	const writable_props = ["actions", "height", "html", "useMarkdown", "content", "id", "placeholder"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Viewer> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Viewer", $$slots, []);

    	function dblclick_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("actions" in $$props) $$invalidate(2, actions = $$props.actions);
    		if ("height" in $$props) $$invalidate(3, height = $$props.height);
    		if ("html" in $$props) $$invalidate(4, html = $$props.html);
    		if ("useMarkdown" in $$props) $$invalidate(5, useMarkdown = $$props.useMarkdown);
    		if ("content" in $$props) $$invalidate(0, content = $$props.content);
    		if ("id" in $$props) $$invalidate(6, id = $$props.id);
    		if ("placeholder" in $$props) $$invalidate(7, placeholder = $$props.placeholder);
    	};

    	$$self.$capture_state = () => ({
    		setContent,
    		actions,
    		height,
    		html,
    		useMarkdown,
    		content,
    		id,
    		placeholder
    	});

    	$$self.$inject_state = $$props => {
    		if ("setContent" in $$props) $$invalidate(1, setContent = $$props.setContent);
    		if ("actions" in $$props) $$invalidate(2, actions = $$props.actions);
    		if ("height" in $$props) $$invalidate(3, height = $$props.height);
    		if ("html" in $$props) $$invalidate(4, html = $$props.html);
    		if ("useMarkdown" in $$props) $$invalidate(5, useMarkdown = $$props.useMarkdown);
    		if ("content" in $$props) $$invalidate(0, content = $$props.content);
    		if ("id" in $$props) $$invalidate(6, id = $$props.id);
    		if ("placeholder" in $$props) $$invalidate(7, placeholder = $$props.placeholder);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		content,
    		setContent,
    		actions,
    		height,
    		html,
    		useMarkdown,
    		id,
    		placeholder,
    		dblclick_handler
    	];
    }

    class Viewer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {
    			actions: 2,
    			height: 3,
    			html: 4,
    			useMarkdown: 5,
    			content: 0,
    			id: 6,
    			placeholder: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Viewer",
    			options,
    			id: create_fragment$O.name
    		});
    	}

    	get actions() {
    		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set actions(value) {
    		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get html() {
    		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set html(value) {
    		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get useMarkdown() {
    		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set useMarkdown(value) {
    		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content() {
    		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Viewer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Viewer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Quill\TogglableEditor.svelte generated by Svelte v3.22.2 */
    const file$K = "src\\svelte\\pages\\_Common\\Quill\\TogglableEditor.svelte";

    // (429:0) {:else}
    function create_else_block$b(ctx) {
    	let div;
    	let current;

    	const viewer = new Viewer({
    			props: {
    				content: /*viewerContent*/ ctx[6],
    				placeholder: "This has no description at the moment. Double click to edit"
    			},
    			$$inline: true
    		});

    	viewer.$on("dblclick", function () {
    		if (is_function(/*edit*/ ctx[2])) /*edit*/ ctx[2].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(viewer.$$.fragment);
    			attr_dev(div, "class", "togglable-editor");
    			attr_dev(div, "isediting", /*isEditing*/ ctx[4]);
    			add_location(div, file$K, 429, 2, 51120);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(viewer, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const viewer_changes = {};
    			if (dirty & /*viewerContent*/ 64) viewer_changes.content = /*viewerContent*/ ctx[6];
    			viewer.$set(viewer_changes);

    			if (!current || dirty & /*isEditing*/ 16) {
    				attr_dev(div, "isediting", /*isEditing*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(viewer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(viewer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(viewer);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(429:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (424:0) {#if isEditing}
    function create_if_block$n(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let current;
    	let dispose;

    	const editor = new Quill_1({
    			props: {
    				content: /*editorContent*/ ctx[3],
    				placeholder: /*placeholder*/ ctx[0]
    			},
    			$$inline: true
    		});

    	editor.$on("change", function () {
    		if (is_function(/*changeContent*/ ctx[1])) /*changeContent*/ ctx[1].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = text("Editing....Click here to save changes.");
    			t1 = space();
    			div1 = element("div");
    			create_component(editor.$$.fragment);
    			attr_dev(div0, "class", "togglable-notice");
    			attr_dev(div0, "isediting", /*isEditing*/ ctx[4]);
    			add_location(div0, file$K, 424, 2, 50861);
    			attr_dev(div1, "class", "togglable-editor");
    			attr_dev(div1, "isediting", /*isEditing*/ ctx[4]);
    			add_location(div1, file$K, 425, 2, 50976);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(editor, div1, null);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div0,
    				"click",
    				function () {
    					if (is_function(/*saveAndCancel*/ ctx[5])) /*saveAndCancel*/ ctx[5].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (!current || dirty & /*isEditing*/ 16) {
    				attr_dev(div0, "isediting", /*isEditing*/ ctx[4]);
    			}

    			const editor_changes = {};
    			if (dirty & /*editorContent*/ 8) editor_changes.content = /*editorContent*/ ctx[3];
    			if (dirty & /*placeholder*/ 1) editor_changes.placeholder = /*placeholder*/ ctx[0];
    			editor.$set(editor_changes);

    			if (!current || dirty & /*isEditing*/ 16) {
    				attr_dev(div1, "isediting", /*isEditing*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(editor);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(424:0) {#if isEditing}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$n, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isEditing*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	var changeContent,
    		debouncedChange,
    		dispatch,
    		edit,
    		editorContent,
    		isEditing,
    		saveAndCancel,
    		saveObject,
    		viewerContent;

    	dispatch = createEventDispatcher();
    	var { height = "100%" } = $$props;
    	var { placeholder = "Type in some content here" } = $$props;
    	var { content = void 0 } = $$props;
    	var { text = void 0 } = $$props;
    	var { markdown = void 0 } = $$props;
    	editorContent = void 0;
    	viewerContent = void 0;
    	saveObject = void 0;
    	isEditing = false;

    	edit = function (e) {
    		return $$invalidate(4, isEditing = true);
    	};

    	changeContent = function (e) {
    		return saveObject = e.detail;
    	};

    	debouncedChange = changeContent.debounce(500);

    	saveAndCancel = function () {
    		dispatch("save", saveObject);
    		return $$invalidate(4, isEditing = false);
    	};

    	const writable_props = ["height", "placeholder", "content", "text", "markdown"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TogglableEditor> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TogglableEditor", $$slots, []);

    	$$self.$set = $$props => {
    		if ("height" in $$props) $$invalidate(7, height = $$props.height);
    		if ("placeholder" in $$props) $$invalidate(0, placeholder = $$props.placeholder);
    		if ("content" in $$props) $$invalidate(8, content = $$props.content);
    		if ("text" in $$props) $$invalidate(9, text = $$props.text);
    		if ("markdown" in $$props) $$invalidate(10, markdown = $$props.markdown);
    	};

    	$$self.$capture_state = () => ({
    		changeContent,
    		debouncedChange,
    		dispatch,
    		edit,
    		editorContent,
    		isEditing,
    		saveAndCancel,
    		saveObject,
    		viewerContent,
    		createEventDispatcher,
    		onMount,
    		Editor: Quill_1,
    		Viewer,
    		height,
    		placeholder,
    		content,
    		text,
    		markdown
    	});

    	$$self.$inject_state = $$props => {
    		if ("changeContent" in $$props) $$invalidate(1, changeContent = $$props.changeContent);
    		if ("debouncedChange" in $$props) debouncedChange = $$props.debouncedChange;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("edit" in $$props) $$invalidate(2, edit = $$props.edit);
    		if ("editorContent" in $$props) $$invalidate(3, editorContent = $$props.editorContent);
    		if ("isEditing" in $$props) $$invalidate(4, isEditing = $$props.isEditing);
    		if ("saveAndCancel" in $$props) $$invalidate(5, saveAndCancel = $$props.saveAndCancel);
    		if ("saveObject" in $$props) saveObject = $$props.saveObject;
    		if ("viewerContent" in $$props) $$invalidate(6, viewerContent = $$props.viewerContent);
    		if ("height" in $$props) $$invalidate(7, height = $$props.height);
    		if ("placeholder" in $$props) $$invalidate(0, placeholder = $$props.placeholder);
    		if ("content" in $$props) $$invalidate(8, content = $$props.content);
    		if ("text" in $$props) $$invalidate(9, text = $$props.text);
    		if ("markdown" in $$props) $$invalidate(10, markdown = $$props.markdown);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*content*/ 256) {
    			 $$invalidate(6, viewerContent = $$invalidate(3, editorContent = content));
    		}
    	};

    	return [
    		placeholder,
    		changeContent,
    		edit,
    		editorContent,
    		isEditing,
    		saveAndCancel,
    		viewerContent,
    		height,
    		content,
    		text,
    		markdown
    	];
    }

    class TogglableEditor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$P, create_fragment$P, safe_not_equal, {
    			height: 7,
    			placeholder: 0,
    			content: 8,
    			text: 9,
    			markdown: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TogglableEditor",
    			options,
    			id: create_fragment$P.name
    		});
    	}

    	get height() {
    		throw new Error("<TogglableEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<TogglableEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<TogglableEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<TogglableEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content() {
    		throw new Error("<TogglableEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<TogglableEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<TogglableEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<TogglableEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get markdown() {
    		throw new Error("<TogglableEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set markdown(value) {
    		throw new Error("<TogglableEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Sections\Description.svelte generated by Svelte v3.22.2 */

    // (24:0) <Section {open} name="About">
    function create_default_slot$l(ctx) {
    	let updating_content;
    	let current;

    	function togglableeditor_content_binding(value) {
    		/*togglableeditor_content_binding*/ ctx[3].call(null, value);
    	}

    	let togglableeditor_props = {
    		text: /*item*/ ctx[0].content_indexable,
    		height: "calc(100vh - 200px)"
    	};

    	if (/*item*/ ctx[0].content !== void 0) {
    		togglableeditor_props.content = /*item*/ ctx[0].content;
    	}

    	const togglableeditor = new TogglableEditor({
    			props: togglableeditor_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(togglableeditor, "content", togglableeditor_content_binding));

    	togglableeditor.$on("save", function () {
    		if (is_function(/*save*/ ctx[1])) /*save*/ ctx[1].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(togglableeditor.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(togglableeditor, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const togglableeditor_changes = {};
    			if (dirty & /*item*/ 1) togglableeditor_changes.text = /*item*/ ctx[0].content_indexable;

    			if (!updating_content && dirty & /*item*/ 1) {
    				updating_content = true;
    				togglableeditor_changes.content = /*item*/ ctx[0].content;
    				add_flush_callback(() => updating_content = false);
    			}

    			togglableeditor.$set(togglableeditor_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(togglableeditor.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(togglableeditor.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(togglableeditor, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(24:0) <Section {open} name=\\\"About\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				open,
    				name: "About",
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const section_changes = {};

    			if (dirty & /*$$scope, item, save*/ 19) {
    				section_changes.$$scope = { dirty, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	var dispatch, save;
    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;

    	save = function (e) {
    		$$invalidate(0, item.content = e.detail.html, item);
    		$$invalidate(0, item.content_indexable = e.detail.text, item);
    		return dispatch("update");
    	};

    	const writable_props = ["item"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Description> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Description", $$slots, []);

    	function togglableeditor_content_binding(value) {
    		item.content = value;
    		$$invalidate(0, item);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({
    		dispatch,
    		save,
    		createEventDispatcher,
    		Section,
    		TogglableEditor,
    		item
    	});

    	$$self.$inject_state = $$props => {
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("save" in $$props) $$invalidate(1, save = $$props.save);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [item, save, dispatch, togglableeditor_content_binding];
    }

    class Description extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { item: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Description",
    			options,
    			id: create_fragment$Q.name
    		});
    	}

    	get item() {
    		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Sections\SubDocumentList.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$8, console: console_1$m } = globals;
    const file$L = "src\\svelte\\pages\\_Common\\Sections\\SubDocumentList.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i];
    	child_ctx[43] = list;
    	child_ctx[44] = i;
    	return child_ctx;
    }

    // (205:2) {#if mounted}
    function create_if_block$o(ctx) {
    	let div;
    	let t;
    	let current;

    	const droppabledivider = new DroppableDivider({
    			props: {
    				index: -1,
    				listId: /*listId*/ ctx[4],
    				sameListOnly: /*sameListOnly*/ ctx[5]
    			},
    			$$inline: true
    		});

    	droppabledivider.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[8])) /*dropEvent*/ ctx[8].apply(this, arguments);
    	});

    	let each_value = /*list*/ ctx[17];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(droppabledivider.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$L, 205, 4, 4696);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(droppabledivider, div, null);
    			append_dev(div, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const droppabledivider_changes = {};
    			if (dirty[0] & /*listId*/ 16) droppabledivider_changes.listId = /*listId*/ ctx[4];
    			if (dirty[0] & /*sameListOnly*/ 32) droppabledivider_changes.sameListOnly = /*sameListOnly*/ ctx[5];
    			droppabledivider.$set(droppabledivider_changes);

    			if (dirty[0] & /*list, listId, sameListOnly, dropEvent, updateAttribute, destroy, item, showComments, showChecklist, style, updateName, goToItem, collection, showProgress*/ 250815 | dirty[1] & /*label*/ 16384) {
    				each_value = /*list*/ ctx[17];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(droppabledivider.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(droppabledivider.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(droppabledivider);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(205:2) {#if mounted}",
    		ctx
    	});

    	return block;
    }

    // (212:12) {#if showProgress}
    function create_if_block_6(ctx) {
    	let div;
    	let updating_value;
    	let current;

    	function progresspopover_value_binding(value) {
    		/*progresspopover_value_binding*/ ctx[26].call(null, value, /*listItem*/ ctx[42]);
    	}

    	let progresspopover_props = { item: /*listItem*/ ctx[42] };

    	if (/*listItem*/ ctx[42].progress !== void 0) {
    		progresspopover_props.value = /*listItem*/ ctx[42].progress;
    	}

    	const progresspopover = new Progress({
    			props: progresspopover_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(progresspopover, "value", progresspopover_value_binding));

    	progresspopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[15])) /*updateAttribute*/ ctx[15].apply(this, arguments);
    	});

    	progresspopover.$on("open", /*open_handler*/ ctx[27]);
    	progresspopover.$on("close", /*close_handler*/ ctx[28]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(progresspopover.$$.fragment);
    			attr_dev(div, "flex", "initial");
    			attr_dev(div, "section", "progress");
    			add_location(div, file$L, 212, 14, 5103);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(progresspopover, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const progresspopover_changes = {};
    			if (dirty[0] & /*list*/ 131072) progresspopover_changes.item = /*listItem*/ ctx[42];

    			if (!updating_value && dirty[0] & /*list*/ 131072) {
    				updating_value = true;
    				progresspopover_changes.value = /*listItem*/ ctx[42].progress;
    				add_flush_callback(() => updating_value = false);
    			}

    			progresspopover.$set(progresspopover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(progresspopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(progresspopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(progresspopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(212:12) {#if showProgress}",
    		ctx
    	});

    	return block;
    }

    // (218:14) <InlineInput bind:value={listItem.name} on:update={updateName} on:clicked={goToItem(listItem)} {style} let:label>
    function create_default_slot_2$5(ctx) {
    	let span;
    	let a;
    	let em;
    	let t_value = (/*label*/ ctx[45] || "No Name") + "";
    	let t;
    	let a_href_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			a = element("a");
    			em = element("em");
    			t = text(t_value);
    			add_location(em, file$L, 218, 113, 5593);
    			attr_dev(a, "href", a_href_value = "#/projects/" + /*item*/ ctx[0].id + "/" + /*collection*/ ctx[3] + "/" + /*listItem*/ ctx[42].id);
    			add_location(a, file$L, 218, 31, 5511);
    			attr_dev(span, "ellipsis", "");
    			add_location(span, file$L, 218, 16, 5496);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, span, anchor);
    			append_dev(span, a);
    			append_dev(a, em);
    			append_dev(em, t);
    			if (remount) dispose();
    			dispose = listen_dev(a, "click", prevent_default(/*click_handler*/ ctx[25]), false, true, false);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*label*/ 16384 && t_value !== (t_value = (/*label*/ ctx[45] || "No Name") + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*item, collection, list*/ 131081 && a_href_value !== (a_href_value = "#/projects/" + /*item*/ ctx[0].id + "/" + /*collection*/ ctx[3] + "/" + /*listItem*/ ctx[42].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(218:14) <InlineInput bind:value={listItem.name} on:update={updateName} on:clicked={goToItem(listItem)} {style} let:label>",
    		ctx
    	});

    	return block;
    }

    // (236:16) {#if showChecklist}
    function create_if_block_4$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = (/*listItem*/ ctx[42].checklists || []).length > 0 && create_if_block_5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((/*listItem*/ ctx[42].checklists || []).length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*list*/ 131072) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(236:16) {#if showChecklist}",
    		ctx
    	});

    	return block;
    }

    // (237:18) {#if (listItem.checklists || []).length > 0}
    function create_if_block_5(ctx) {
    	let div;
    	let current;

    	const checklistpopover = new Checklist$1({
    			props: { item: /*listItem*/ ctx[42] },
    			$$inline: true
    		});

    	checklistpopover.$on("open", /*open_handler_3*/ ctx[34]);
    	checklistpopover.$on("close", /*close_handler_3*/ ctx[35]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(checklistpopover.$$.fragment);
    			attr_dev(div, "flex", "initial");
    			add_location(div, file$L, 237, 18, 6497);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(checklistpopover, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checklistpopover_changes = {};
    			if (dirty[0] & /*list*/ 131072) checklistpopover_changes.item = /*listItem*/ ctx[42];
    			checklistpopover.$set(checklistpopover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checklistpopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checklistpopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(checklistpopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(237:18) {#if (listItem.checklists || []).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (243:16) {#if showComments(item)}
    function create_if_block_2$4(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = (/*listItem*/ ctx[42].comments || []).length > 0 && create_if_block_3$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((/*listItem*/ ctx[42].comments || []).length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*list*/ 131072) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(243:16) {#if showComments(item)}",
    		ctx
    	});

    	return block;
    }

    // (244:18) {#if (listItem.comments || []).length > 0}
    function create_if_block_3$3(ctx) {
    	let div;
    	let current;

    	const commentpopover = new Comment({
    			props: { item: /*listItem*/ ctx[42] },
    			$$inline: true
    		});

    	commentpopover.$on("open", /*open_handler_4*/ ctx[36]);
    	commentpopover.$on("close", /*close_handler_4*/ ctx[37]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(commentpopover.$$.fragment);
    			attr_dev(div, "flex", "initial");
    			add_location(div, file$L, 244, 18, 6789);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(commentpopover, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const commentpopover_changes = {};
    			if (dirty[0] & /*list*/ 131072) commentpopover_changes.item = /*listItem*/ ctx[42];
    			commentpopover.$set(commentpopover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(commentpopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(commentpopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(commentpopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(244:18) {#if (listItem.comments || []).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (251:16) {#if (listItem.type != "assignment") && (item.assignments.length > 0)}
    function create_if_block_1$a(ctx) {
    	let div;
    	let updating_item;
    	let div_present_value;
    	let current;

    	function assignmentpopover_item_binding(value) {
    		/*assignmentpopover_item_binding*/ ctx[38].call(null, value, /*listItem*/ ctx[42], /*each_value*/ ctx[43], /*index*/ ctx[44]);
    	}

    	let assignmentpopover_props = { project: /*item*/ ctx[0] };

    	if (/*listItem*/ ctx[42] !== void 0) {
    		assignmentpopover_props.item = /*listItem*/ ctx[42];
    	}

    	const assignmentpopover = new Assignment$1({
    			props: assignmentpopover_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(assignmentpopover, "item", assignmentpopover_item_binding));

    	assignmentpopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[15])) /*updateAttribute*/ ctx[15].apply(this, arguments);
    	});

    	assignmentpopover.$on("open", /*open_handler_5*/ ctx[39]);
    	assignmentpopover.$on("close", /*close_handler_5*/ ctx[40]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(assignmentpopover.$$.fragment);
    			attr_dev(div, "flex", "initial");
    			attr_dev(div, "section", "assignment");
    			attr_dev(div, "present", div_present_value = (/*listItem*/ ctx[42].assigned_to || []).length > 0);
    			attr_dev(div, "class", "svelte-1qu2uzy");
    			add_location(div, file$L, 251, 18, 7105);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(assignmentpopover, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const assignmentpopover_changes = {};
    			if (dirty[0] & /*item*/ 1) assignmentpopover_changes.project = /*item*/ ctx[0];

    			if (!updating_item && dirty[0] & /*list*/ 131072) {
    				updating_item = true;
    				assignmentpopover_changes.item = /*listItem*/ ctx[42];
    				add_flush_callback(() => updating_item = false);
    			}

    			assignmentpopover.$set(assignmentpopover_changes);

    			if (!current || dirty[0] & /*list*/ 131072 && div_present_value !== (div_present_value = (/*listItem*/ ctx[42].assigned_to || []).length > 0)) {
    				attr_dev(div, "present", div_present_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(assignmentpopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(assignmentpopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(assignmentpopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(251:16) {#if (listItem.type != \\\"assignment\\\") && (item.assignments.length > 0)}",
    		ctx
    	});

    	return block;
    }

    // (262:10) <div slot="menu">
    function create_menu_slot$1(ctx) {
    	let div;
    	let current;

    	const menu = new SubDocument({
    			props: { item: /*listItem*/ ctx[42] },
    			$$inline: true
    		});

    	menu.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[15])) /*updateAttribute*/ ctx[15].apply(this, arguments);
    	});

    	menu.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[7])) /*destroy*/ ctx[7].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(menu.$$.fragment);
    			attr_dev(div, "slot", "menu");
    			add_location(div, file$L, 261, 10, 7446);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(menu, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const menu_changes = {};
    			if (dirty[0] & /*list*/ 131072) menu_changes.item = /*listItem*/ ctx[42];
    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(menu);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_menu_slot$1.name,
    		type: "slot",
    		source: "(262:10) <div slot=\\\"menu\\\">",
    		ctx
    	});

    	return block;
    }

    // (209:8) <DraggableItem item={listItem} index={index} {listId} {sameListOnly} on:drop={dropEvent} on:update={updateAttribute}>
    function create_default_slot_1$7(ctx) {
    	let div5;
    	let t0;
    	let t1;
    	let div0;
    	let updating_value;
    	let t2;
    	let div4;
    	let div3;
    	let div1;
    	let div1_present_value;
    	let t3;
    	let div2;
    	let div2_present_value;
    	let t4;
    	let t5;
    	let show_if = /*showComments*/ ctx[12](/*item*/ ctx[0]);
    	let t6;
    	let t7;
    	let current;

    	const indent = new Indent({
    			props: {
    				level: /*listItem*/ ctx[42].indent.clamp(0, 5)
    			},
    			$$inline: true
    		});

    	let if_block0 = /*showProgress*/ ctx[1] && create_if_block_6(ctx);

    	function inlineinput_value_binding(value) {
    		/*inlineinput_value_binding*/ ctx[29].call(null, value, /*listItem*/ ctx[42]);
    	}

    	let inlineinput_props = {
    		style: /*style*/ ctx[14],
    		$$slots: {
    			default: [
    				create_default_slot_2$5,
    				({ label }) => ({ 45: label }),
    				({ label }) => [0, label ? 16384 : 0]
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*listItem*/ ctx[42].name !== void 0) {
    		inlineinput_props.value = /*listItem*/ ctx[42].name;
    	}

    	const inlineinput = new InlineInput({ props: inlineinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(inlineinput, "value", inlineinput_value_binding));

    	inlineinput.$on("update", function () {
    		if (is_function(/*updateName*/ ctx[16])) /*updateName*/ ctx[16].apply(this, arguments);
    	});

    	inlineinput.$on("clicked", function () {
    		if (is_function(/*goToItem*/ ctx[9](/*listItem*/ ctx[42]))) /*goToItem*/ ctx[9](/*listItem*/ ctx[42]).apply(this, arguments);
    	});

    	const duedatepopover = new DueDate({
    			props: {
    				item: /*listItem*/ ctx[42],
    				value: /*listItem*/ ctx[42].due_date
    			},
    			$$inline: true
    		});

    	duedatepopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[15])) /*updateAttribute*/ ctx[15].apply(this, arguments);
    	});

    	duedatepopover.$on("open", /*open_handler_1*/ ctx[30]);
    	duedatepopover.$on("close", /*close_handler_1*/ ctx[31]);

    	const timepopover = new Time({
    			props: {
    				item: /*listItem*/ ctx[42],
    				value: /*listItem*/ ctx[42].due_date,
    				showTimeForm: true
    			},
    			$$inline: true
    		});

    	timepopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[15])) /*updateAttribute*/ ctx[15].apply(this, arguments);
    	});

    	timepopover.$on("open", /*open_handler_2*/ ctx[32]);
    	timepopover.$on("close", /*close_handler_2*/ ctx[33]);
    	let if_block1 = /*showChecklist*/ ctx[2] && create_if_block_4$1(ctx);
    	let if_block2 = show_if && create_if_block_2$4(ctx);
    	let if_block3 = /*listItem*/ ctx[42].type != "assignment" && /*item*/ ctx[0].assignments.length > 0 && create_if_block_1$a(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			create_component(indent.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div0 = element("div");
    			create_component(inlineinput.$$.fragment);
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			create_component(duedatepopover.$$.fragment);
    			t3 = space();
    			div2 = element("div");
    			create_component(timepopover.$$.fragment);
    			t4 = space();
    			if (if_block1) if_block1.c();
    			t5 = space();
    			if (if_block2) if_block2.c();
    			t6 = space();
    			if (if_block3) if_block3.c();
    			t7 = space();
    			attr_dev(div0, "flex", "");
    			attr_dev(div0, "ellipsis", "");
    			attr_dev(div0, "main", "");
    			add_location(div0, file$L, 216, 12, 5325);
    			attr_dev(div1, "flex", "initial");
    			attr_dev(div1, "section", "due-date");
    			attr_dev(div1, "present", div1_present_value = /*listItem*/ ctx[42].due_date != null);
    			attr_dev(div1, "class", "svelte-1qu2uzy");
    			add_location(div1, file$L, 228, 16, 5917);
    			attr_dev(div2, "flex", "initial");
    			attr_dev(div2, "section", "time");
    			attr_dev(div2, "present", div2_present_value = false);
    			attr_dev(div2, "class", "svelte-1qu2uzy");
    			add_location(div2, file$L, 231, 16, 6158);
    			attr_dev(div3, "layout", "row");
    			add_location(div3, file$L, 223, 14, 5835);
    			attr_dev(div4, "flex", "initial");
    			add_location(div4, file$L, 222, 12, 5799);
    			attr_dev(div5, "layout", "row");
    			attr_dev(div5, "type", "list-item");
    			attr_dev(div5, "class", "svelte-1qu2uzy");
    			add_location(div5, file$L, 209, 10, 4962);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			mount_component(indent, div5, null);
    			append_dev(div5, t0);
    			if (if_block0) if_block0.m(div5, null);
    			append_dev(div5, t1);
    			append_dev(div5, div0);
    			mount_component(inlineinput, div0, null);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			mount_component(duedatepopover, div1, null);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			mount_component(timepopover, div2, null);
    			append_dev(div3, t4);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t5);
    			if (if_block2) if_block2.m(div3, null);
    			append_dev(div3, t6);
    			if (if_block3) if_block3.m(div3, null);
    			insert_dev(target, t7, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const indent_changes = {};
    			if (dirty[0] & /*list*/ 131072) indent_changes.level = /*listItem*/ ctx[42].indent.clamp(0, 5);
    			indent.$set(indent_changes);

    			if (/*showProgress*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*showProgress*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div5, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const inlineinput_changes = {};
    			if (dirty[0] & /*style*/ 16384) inlineinput_changes.style = /*style*/ ctx[14];

    			if (dirty[0] & /*item, collection, list*/ 131081 | dirty[1] & /*$$scope, label*/ 49152) {
    				inlineinput_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty[0] & /*list*/ 131072) {
    				updating_value = true;
    				inlineinput_changes.value = /*listItem*/ ctx[42].name;
    				add_flush_callback(() => updating_value = false);
    			}

    			inlineinput.$set(inlineinput_changes);
    			const duedatepopover_changes = {};
    			if (dirty[0] & /*list*/ 131072) duedatepopover_changes.item = /*listItem*/ ctx[42];
    			if (dirty[0] & /*list*/ 131072) duedatepopover_changes.value = /*listItem*/ ctx[42].due_date;
    			duedatepopover.$set(duedatepopover_changes);

    			if (!current || dirty[0] & /*list*/ 131072 && div1_present_value !== (div1_present_value = /*listItem*/ ctx[42].due_date != null)) {
    				attr_dev(div1, "present", div1_present_value);
    			}

    			const timepopover_changes = {};
    			if (dirty[0] & /*list*/ 131072) timepopover_changes.item = /*listItem*/ ctx[42];
    			if (dirty[0] & /*list*/ 131072) timepopover_changes.value = /*listItem*/ ctx[42].due_date;
    			timepopover.$set(timepopover_changes);

    			if (/*showChecklist*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*showChecklist*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t5);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*showComments, item*/ 4097) show_if = /*showComments*/ ctx[12](/*item*/ ctx[0]);

    			if (show_if) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*showComments, item*/ 4097) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div3, t6);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*listItem*/ ctx[42].type != "assignment" && /*item*/ ctx[0].assignments.length > 0) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*list, item*/ 131073) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1$a(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div3, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indent.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(inlineinput.$$.fragment, local);
    			transition_in(duedatepopover.$$.fragment, local);
    			transition_in(timepopover.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indent.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(inlineinput.$$.fragment, local);
    			transition_out(duedatepopover.$$.fragment, local);
    			transition_out(timepopover.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(indent);
    			if (if_block0) if_block0.d();
    			destroy_component(inlineinput);
    			destroy_component(duedatepopover);
    			destroy_component(timepopover);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (detaching) detach_dev(t7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(209:8) <DraggableItem item={listItem} index={index} {listId} {sameListOnly} on:drop={dropEvent} on:update={updateAttribute}>",
    		ctx
    	});

    	return block;
    }

    // (208:6) {#each list as listItem, index}
    function create_each_block$9(ctx) {
    	let t;
    	let current;

    	const draggableitem = new DraggableIndentableItem({
    			props: {
    				item: /*listItem*/ ctx[42],
    				index: /*index*/ ctx[44],
    				listId: /*listId*/ ctx[4],
    				sameListOnly: /*sameListOnly*/ ctx[5],
    				$$slots: {
    					default: [create_default_slot_1$7],
    					menu: [create_menu_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	draggableitem.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[8])) /*dropEvent*/ ctx[8].apply(this, arguments);
    	});

    	draggableitem.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[15])) /*updateAttribute*/ ctx[15].apply(this, arguments);
    	});

    	const droppabledivider = new DroppableDivider({
    			props: {
    				item: /*listItem*/ ctx[42],
    				index: /*index*/ ctx[44],
    				listId: /*listId*/ ctx[4],
    				sameListOnly: /*sameListOnly*/ ctx[5]
    			},
    			$$inline: true
    		});

    	droppabledivider.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[8])) /*dropEvent*/ ctx[8].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(draggableitem.$$.fragment);
    			t = space();
    			create_component(droppabledivider.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(draggableitem, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(droppabledivider, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const draggableitem_changes = {};
    			if (dirty[0] & /*list*/ 131072) draggableitem_changes.item = /*listItem*/ ctx[42];
    			if (dirty[0] & /*listId*/ 16) draggableitem_changes.listId = /*listId*/ ctx[4];
    			if (dirty[0] & /*sameListOnly*/ 32) draggableitem_changes.sameListOnly = /*sameListOnly*/ ctx[5];

    			if (dirty[0] & /*list, updateAttribute, destroy, item, showComments, showChecklist, style, updateName, goToItem, collection, showProgress*/ 250511 | dirty[1] & /*$$scope*/ 32768) {
    				draggableitem_changes.$$scope = { dirty, ctx };
    			}

    			draggableitem.$set(draggableitem_changes);
    			const droppabledivider_changes = {};
    			if (dirty[0] & /*list*/ 131072) droppabledivider_changes.item = /*listItem*/ ctx[42];
    			if (dirty[0] & /*listId*/ 16) droppabledivider_changes.listId = /*listId*/ ctx[4];
    			if (dirty[0] & /*sameListOnly*/ 32) droppabledivider_changes.sameListOnly = /*sameListOnly*/ ctx[5];
    			droppabledivider.$set(droppabledivider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(draggableitem.$$.fragment, local);
    			transition_in(droppabledivider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(draggableitem.$$.fragment, local);
    			transition_out(droppabledivider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(draggableitem, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(droppabledivider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(208:6) {#each list as listItem, index}",
    		ctx
    	});

    	return block;
    }

    // (203:0) <Section name={collection.titleize()} {open}>
    function create_default_slot$m(ctx) {
    	let t0;
    	let t1;
    	let updating_show;
    	let current;
    	let if_block = /*mounted*/ ctx[11] && create_if_block$o(ctx);

    	const quickentry = new GenericItem({
    			props: {
    				stubPlaceholder: "Add " + /*collection*/ ctx[3].singularize().titleize()
    			},
    			$$inline: true
    		});

    	quickentry.$on("add", function () {
    		if (is_function(/*add*/ ctx[6])) /*add*/ ctx[6].apply(this, arguments);
    	});

    	function toast_show_binding(value) {
    		/*toast_show_binding*/ ctx[41].call(null, value);
    	}

    	let toast_props = { message: /*message*/ ctx[10] };

    	if (/*showToast*/ ctx[13] !== void 0) {
    		toast_props.show = /*showToast*/ ctx[13];
    	}

    	const toast = new Toast({ props: toast_props, $$inline: true });
    	binding_callbacks.push(() => bind(toast, "show", toast_show_binding));

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(quickentry.$$.fragment);
    			t1 = space();
    			create_component(toast.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(quickentry, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(toast, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*mounted*/ ctx[11]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*mounted*/ 2048) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$o(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const quickentry_changes = {};
    			if (dirty[0] & /*collection*/ 8) quickentry_changes.stubPlaceholder = "Add " + /*collection*/ ctx[3].singularize().titleize();
    			quickentry.$set(quickentry_changes);
    			const toast_changes = {};
    			if (dirty[0] & /*message*/ 1024) toast_changes.message = /*message*/ ctx[10];

    			if (!updating_show && dirty[0] & /*showToast*/ 8192) {
    				updating_show = true;
    				toast_changes.show = /*showToast*/ ctx[13];
    				add_flush_callback(() => updating_show = false);
    			}

    			toast.$set(toast_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(quickentry.$$.fragment, local);
    			transition_in(toast.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(quickentry.$$.fragment, local);
    			transition_out(toast.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(quickentry, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(toast, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(203:0) <Section name={collection.titleize()} {open}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				name: /*collection*/ ctx[3].titleize(),
    				open,
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const section_changes = {};
    			if (dirty[0] & /*collection*/ 8) section_changes.name = /*collection*/ ctx[3].titleize();

    			if (dirty[0] & /*message, showToast, collection, add, list, listId, sameListOnly, dropEvent, updateAttribute, destroy, item, showComments, showChecklist, style, updateName, goToItem, showProgress, mounted*/ 262143 | dirty[1] & /*$$scope*/ 32768) {
    				section_changes.$$scope = { dirty, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	var add,
    		destroy,
    		dispatch,
    		dropEvent,
    		goToItem,
    		hasAssignments,
    		message,
    		mounted,
    		showComments,
    		showToast,
    		sort,
    		style,
    		subDocument,
    		update,
    		updateAttribute,
    		updateName;

    	dispatch = createEventDispatcher();
    	var { assignments = [] } = $$props;
    	var { showProgress = true } = $$props;
    	var { showAssignment = true } = $$props;
    	var { showChecklist = false } = $$props;
    	var { collection = "tasks" } = $$props;
    	var { item = void 0 } = $$props;
    	subDocument = void 0;
    	showToast = false;
    	message = "";
    	mounted = false;

    	onMount(function () {
    		switch (collection) {
    			case "tasks":
    				subDocument = new task();
    				break;
    			case "documents":
    				subDocument = new document$1();
    				break;
    			case "assignments":
    				subDocument = new assignment();
    		}

    		// }
    		item[collection].forEach(function (subitem) {
    			return subitem = subDocument.upgradeModel(subitem);
    		});

    		return $$invalidate(11, mounted = true);
    	});

    	showComments = function (item) {
    		if (item.comments != null) {
    			return item.comments.length > 0;
    		} else {
    			return false;
    		}
    	};

    	goToItem = function (childItem) {
    		return location.href = `#/projects/${item.id}/${collection}/${childItem.id}`;
    	};

    	style = ":hover {font-weight: bold}";

    	updateName = function (e) {
    		var change;
    		console.log(e.detail);
    		change = { id: item.id, name: e.detail };
    		return dispatch("update", change);
    	};

    	updateAttribute = function (e) {
    		var change, changedTask;
    		console.log("ListItme.svelte updateAttribute");
    		console.log(e.detail);
    		change = e.detail;

    		// change["id"] = item.id
    		changedTask = item[collection].find({ id: change.id });

    		Object.merge(changedTask, change);
    		$$invalidate(0, item);
    		console.log(change);
    		return dispatch("update", change);
    	};

    	add = function (event) {
    		var newRecord;
    		console.log("SubDocumentList.add");
    		newRecord = subDocument.stub(event.detail);
    		newRecord.ordinal = (item[collection] || []).length;
    		console.log(newRecord);
    		$$invalidate(0, item[collection] = item[collection].add(newRecord), item);
    		return dispatch("update");
    	};

    	destroy = function (e) {
    		var showDeleteConfirmation;
    		item[collection].remove({ id: e.detail.id });
    		$$invalidate(0, item);
    		dispatch("update");
    		return showDeleteConfirmation = false;
    	};

    	hasAssignments = function () {
    		var output;
    		output = false;

    		if (item.assignments != null) {
    			output = item.assignments.length > 0;
    		}

    		return output;
    	};

    	update = function () {
    		return dispatch("update");
    	};

    	sort = function (list) {
    		if (item[collection] != null) {
    			return item[collection].sortBy("ordinal");
    		} else {
    			return [];
    		}
    	};

    	var { listId = uuid() } = $$props;
    	var { sameListOnly = true } = $$props;

    	// drag and drop
    	dropEvent = function (e) {
    		var invalidDrop, refresh, tree;
    		refresh = false;
    		tree = new hierarchical_list(item[collection]);
    		invalidDrop = tree.isInvalidDrop(e.detail);

    		if (invalidDrop != null) {
    			$$invalidate(10, message = invalidDrop);
    			$$invalidate(13, showToast = true);
    		} else {
    			refresh = tree.dropEvent(e.detail);
    		}

    		if (refresh) {
    			$$invalidate(0, item[collection] = tree.list, item);
    			return dispatch("update");
    		}
    	};

    	const writable_props = [
    		"assignments",
    		"showProgress",
    		"showAssignment",
    		"showChecklist",
    		"collection",
    		"item",
    		"listId",
    		"sameListOnly"
    	];

    	Object_1$8.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$m.warn(`<SubDocumentList> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SubDocumentList", $$slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function progresspopover_value_binding(value, listItem) {
    		listItem.progress = value;
    		((($$invalidate(17, list), $$invalidate(22, sort)), $$invalidate(0, item)), $$invalidate(3, collection));
    	}

    	function open_handler(event) {
    		bubble($$self, event);
    	}

    	function close_handler(event) {
    		bubble($$self, event);
    	}

    	function inlineinput_value_binding(value, listItem) {
    		listItem.name = value;
    		((($$invalidate(17, list), $$invalidate(22, sort)), $$invalidate(0, item)), $$invalidate(3, collection));
    	}

    	function open_handler_1(event) {
    		bubble($$self, event);
    	}

    	function close_handler_1(event) {
    		bubble($$self, event);
    	}

    	function open_handler_2(event) {
    		bubble($$self, event);
    	}

    	function close_handler_2(event) {
    		bubble($$self, event);
    	}

    	function open_handler_3(event) {
    		bubble($$self, event);
    	}

    	function close_handler_3(event) {
    		bubble($$self, event);
    	}

    	function open_handler_4(event) {
    		bubble($$self, event);
    	}

    	function close_handler_4(event) {
    		bubble($$self, event);
    	}

    	function assignmentpopover_item_binding(value, listItem, each_value, index) {
    		each_value[index] = value;
    		((($$invalidate(17, list), $$invalidate(22, sort)), $$invalidate(0, item)), $$invalidate(3, collection));
    	}

    	function open_handler_5(event) {
    		bubble($$self, event);
    	}

    	function close_handler_5(event) {
    		bubble($$self, event);
    	}

    	function toast_show_binding(value) {
    		showToast = value;
    		$$invalidate(13, showToast);
    	}

    	$$self.$set = $$props => {
    		if ("assignments" in $$props) $$invalidate(19, assignments = $$props.assignments);
    		if ("showProgress" in $$props) $$invalidate(1, showProgress = $$props.showProgress);
    		if ("showAssignment" in $$props) $$invalidate(18, showAssignment = $$props.showAssignment);
    		if ("showChecklist" in $$props) $$invalidate(2, showChecklist = $$props.showChecklist);
    		if ("collection" in $$props) $$invalidate(3, collection = $$props.collection);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(4, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(5, sameListOnly = $$props.sameListOnly);
    	};

    	$$self.$capture_state = () => ({
    		add,
    		destroy,
    		dispatch,
    		dropEvent,
    		goToItem,
    		hasAssignments,
    		message,
    		mounted,
    		showComments,
    		showToast,
    		sort,
    		style,
    		subDocument,
    		update,
    		updateAttribute,
    		updateName,
    		onMount,
    		createEventDispatcher,
    		Indent,
    		DraggableItem: DraggableIndentableItem,
    		DroppableDivider,
    		QuickEntry: GenericItem,
    		InlineInput,
    		Toast,
    		Menu: SubDocument,
    		ProgressPopover: Progress,
    		DueDatePopover: DueDate,
    		AssignmentPopover: Assignment$1,
    		TimePopover: Time,
    		ChecklistPopover: Checklist$1,
    		CommentPopover: Comment,
    		Section,
    		assignments,
    		showProgress,
    		showAssignment,
    		showChecklist,
    		collection,
    		Task: task,
    		Assignment: assignment,
    		Document: document$1,
    		HierarchicalList: hierarchical_list,
    		item,
    		listId,
    		sameListOnly,
    		list
    	});

    	$$self.$inject_state = $$props => {
    		if ("add" in $$props) $$invalidate(6, add = $$props.add);
    		if ("destroy" in $$props) $$invalidate(7, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("dropEvent" in $$props) $$invalidate(8, dropEvent = $$props.dropEvent);
    		if ("goToItem" in $$props) $$invalidate(9, goToItem = $$props.goToItem);
    		if ("hasAssignments" in $$props) $$invalidate(21, hasAssignments = $$props.hasAssignments);
    		if ("message" in $$props) $$invalidate(10, message = $$props.message);
    		if ("mounted" in $$props) $$invalidate(11, mounted = $$props.mounted);
    		if ("showComments" in $$props) $$invalidate(12, showComments = $$props.showComments);
    		if ("showToast" in $$props) $$invalidate(13, showToast = $$props.showToast);
    		if ("sort" in $$props) $$invalidate(22, sort = $$props.sort);
    		if ("style" in $$props) $$invalidate(14, style = $$props.style);
    		if ("subDocument" in $$props) subDocument = $$props.subDocument;
    		if ("update" in $$props) update = $$props.update;
    		if ("updateAttribute" in $$props) $$invalidate(15, updateAttribute = $$props.updateAttribute);
    		if ("updateName" in $$props) $$invalidate(16, updateName = $$props.updateName);
    		if ("assignments" in $$props) $$invalidate(19, assignments = $$props.assignments);
    		if ("showProgress" in $$props) $$invalidate(1, showProgress = $$props.showProgress);
    		if ("showAssignment" in $$props) $$invalidate(18, showAssignment = $$props.showAssignment);
    		if ("showChecklist" in $$props) $$invalidate(2, showChecklist = $$props.showChecklist);
    		if ("collection" in $$props) $$invalidate(3, collection = $$props.collection);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(4, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(5, sameListOnly = $$props.sameListOnly);
    		if ("list" in $$props) $$invalidate(17, list = $$props.list);
    	};

    	let list;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*hasAssignments, item*/ 2097153) {
    			 $$invalidate(18, showAssignment = hasAssignments(item));
    		}

    		if ($$self.$$.dirty[0] & /*sort, item, collection*/ 4194313) {
    			 $$invalidate(17, list = sort(item[collection]));
    		}
    	};

    	return [
    		item,
    		showProgress,
    		showChecklist,
    		collection,
    		listId,
    		sameListOnly,
    		add,
    		destroy,
    		dropEvent,
    		goToItem,
    		message,
    		mounted,
    		showComments,
    		showToast,
    		style,
    		updateAttribute,
    		updateName,
    		list,
    		showAssignment,
    		assignments,
    		dispatch,
    		hasAssignments,
    		sort,
    		subDocument,
    		update,
    		click_handler,
    		progresspopover_value_binding,
    		open_handler,
    		close_handler,
    		inlineinput_value_binding,
    		open_handler_1,
    		close_handler_1,
    		open_handler_2,
    		close_handler_2,
    		open_handler_3,
    		close_handler_3,
    		open_handler_4,
    		close_handler_4,
    		assignmentpopover_item_binding,
    		open_handler_5,
    		close_handler_5,
    		toast_show_binding
    	];
    }

    class SubDocumentList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$R,
    			create_fragment$R,
    			safe_not_equal,
    			{
    				assignments: 19,
    				showProgress: 1,
    				showAssignment: 18,
    				showChecklist: 2,
    				collection: 3,
    				item: 0,
    				listId: 4,
    				sameListOnly: 5
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SubDocumentList",
    			options,
    			id: create_fragment$R.name
    		});
    	}

    	get assignments() {
    		throw new Error("<SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set assignments(value) {
    		throw new Error("<SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showProgress() {
    		throw new Error("<SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showProgress(value) {
    		throw new Error("<SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showAssignment() {
    		throw new Error("<SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showAssignment(value) {
    		throw new Error("<SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showChecklist() {
    		throw new Error("<SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showChecklist(value) {
    		throw new Error("<SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collection() {
    		throw new Error("<SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collection(value) {
    		throw new Error("<SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listId() {
    		throw new Error("<SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listId(value) {
    		throw new Error("<SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sameListOnly() {
    		throw new Error("<SubDocumentList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sameListOnly(value) {
    		throw new Error("<SubDocumentList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Clip, SubDocument$5;

    SubDocument$5 = sub_document;

    Clip = (function() {
      class Clip extends SubDocument$5 {
        model() {
          return {
            // if sourceversion < latest version, then some upgrades may be required
            // if null then return latest
            id: null,
            type: this.type,
            name: null,
            is_favorite: false,
            ordinal: null,
            indent: 0,
            clip_count: 0,
            click_count: 0,
            content: "",
            content_indexable: "",
            is_visible: true,
            assigned_to: null,
            created_at: null,
            updated_at: null,
            metadata: {}
          };
        }

      }
      Clip.prototype.name = "Clip";

      Clip.prototype.type = "clip";

      return Clip;

    }).call(commonjsGlobal);

    var clip = Clip;

    /* src\svelte\pages\_Common\QuickEntry\Clip.svelte generated by Svelte v3.22.2 */

    const { console: console_1$n } = globals;
    const file$M = "src\\svelte\\pages\\_Common\\QuickEntry\\Clip.svelte";

    // (55:0) {:else}
    function create_else_block$c(ctx) {
    	let div3;
    	let div0;
    	let field0;
    	let input0;
    	let t0;
    	let field1;
    	let input1;
    	let t1;
    	let div1;
    	let button0;
    	let svg0;
    	let title;
    	let t2;
    	let line0;
    	let line1;
    	let button0_disabled_value;
    	let t3;
    	let div2;
    	let button1;
    	let svg1;
    	let path0;
    	let path1;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			field0 = element("field");
    			input0 = element("input");
    			t0 = space();
    			field1 = element("field");
    			input1 = element("input");
    			t1 = space();
    			div1 = element("div");
    			button0 = element("button");
    			svg0 = svg_element("svg");
    			title = svg_element("title");
    			t2 = text("ionicons-v5-a");
    			line0 = svg_element("line");
    			line1 = svg_element("line");
    			t3 = space();
    			div2 = element("div");
    			button1 = element("button");
    			svg1 = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Enter a Name Here");
    			input0.autofocus = true;
    			add_location(input0, file$M, 58, 8, 928);
    			add_location(field0, file$M, 57, 6, 912);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "Enter a Clip Here");
    			add_location(input1, file$M, 61, 8, 1068);
    			add_location(field1, file$M, 60, 6, 1052);
    			attr_dev(div0, "flex", "");
    			add_location(div0, file$M, 56, 4, 895);
    			add_location(title, file$M, 66, 93, 1390);
    			attr_dev(line0, "x1", "256");
    			attr_dev(line0, "y1", "112");
    			attr_dev(line0, "x2", "256");
    			attr_dev(line0, "y2", "400");
    			set_style(line0, "fill", "none");
    			set_style(line0, "stroke", "#000");
    			set_style(line0, "stroke-linecap", "round");
    			set_style(line0, "stroke-linejoin", "round");
    			set_style(line0, "stroke-width", "32px");
    			add_location(line0, file$M, 66, 121, 1418);
    			attr_dev(line1, "x1", "400");
    			attr_dev(line1, "y1", "256");
    			attr_dev(line1, "x2", "112");
    			attr_dev(line1, "y2", "256");
    			set_style(line1, "fill", "none");
    			set_style(line1, "stroke", "#000");
    			set_style(line1, "stroke-linecap", "round");
    			set_style(line1, "stroke-linejoin", "round");
    			set_style(line1, "stroke-width", "32px");
    			add_location(line1, file$M, 66, 255, 1552);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 512 512");
    			add_location(svg0, file$M, 66, 8, 1305);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "icon", "");
    			button0.disabled = button0_disabled_value = /*stub*/ ctx[6].name.length == 0;
    			add_location(button0, file$M, 65, 6, 1221);
    			attr_dev(div1, "flex", "initial");
    			add_location(div1, file$M, 64, 4, 1194);
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$M, 71, 91, 1888);
    			attr_dev(path1, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z");
    			add_location(path1, file$M, 71, 130, 1927);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			add_location(svg1, file$M, 71, 8, 1805);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "icon", "");
    			add_location(button1, file$M, 70, 6, 1751);
    			attr_dev(div2, "flex", "initial");
    			add_location(div2, file$M, 69, 4, 1724);
    			attr_dev(div3, "layout", "row");
    			add_location(div3, file$M, 55, 2, 872);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, field0);
    			append_dev(field0, input0);
    			set_input_value(input0, /*stub*/ ctx[6].name);
    			append_dev(div0, t0);
    			append_dev(div0, field1);
    			append_dev(field1, input1);
    			set_input_value(input1, /*stub*/ ctx[6].content);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, button0);
    			append_dev(button0, svg0);
    			append_dev(svg0, title);
    			append_dev(title, t2);
    			append_dev(svg0, line0);
    			append_dev(svg0, line1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, button1);
    			append_dev(button1, svg1);
    			append_dev(svg1, path0);
    			append_dev(svg1, path1);
    			input0.focus();
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(input0, "input", /*input0_input_handler*/ ctx[9]),
    				listen_dev(
    					input0,
    					"keyup",
    					function () {
    						if (is_function(/*keyup*/ ctx[5])) /*keyup*/ ctx[5].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(input1, "input", /*input1_input_handler*/ ctx[10]),
    				listen_dev(
    					input1,
    					"keyup",
    					function () {
    						if (is_function(/*keyup*/ ctx[5])) /*keyup*/ ctx[5].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button0,
    					"click",
    					function () {
    						if (is_function(/*add*/ ctx[2])) /*add*/ ctx[2].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button1,
    					"click",
    					function () {
    						if (is_function(/*cancel*/ ctx[3])) /*cancel*/ ctx[3].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*stub*/ 64 && input0.value !== /*stub*/ ctx[6].name) {
    				set_input_value(input0, /*stub*/ ctx[6].name);
    			}

    			if (dirty & /*stub*/ 64 && input1.value !== /*stub*/ ctx[6].content) {
    				set_input_value(input1, /*stub*/ ctx[6].content);
    			}

    			if (dirty & /*stub*/ 64 && button0_disabled_value !== (button0_disabled_value = /*stub*/ ctx[6].name.length == 0)) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(55:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (53:0) {#if !showForm}
    function create_if_block$p(ctx) {
    	let current;

    	const addstub = new AddStub({
    			props: {
    				stubPlaceholder: /*stubPlaceholder*/ ctx[1]
    			},
    			$$inline: true
    		});

    	addstub.$on("edit", function () {
    		if (is_function(/*edit*/ ctx[4])) /*edit*/ ctx[4].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(addstub.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(addstub, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const addstub_changes = {};
    			if (dirty & /*stubPlaceholder*/ 2) addstub_changes.stubPlaceholder = /*stubPlaceholder*/ ctx[1];
    			addstub.$set(addstub_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(addstub.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(addstub.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(addstub, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(53:0) {#if !showForm}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$p, create_else_block$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*showForm*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	var add, cancel, dispatch, edit, keyup, resetStub, stub;
    	dispatch = createEventDispatcher();
    	var { showForm = false } = $$props;
    	var { stubPlaceholder = "Add Clip" } = $$props;
    	stub = { name: "", content: "" };

    	resetStub = function () {
    		$$invalidate(6, stub.name = "", stub);
    		return $$invalidate(6, stub.content = "", stub);
    	};

    	edit = function () {
    		return $$invalidate(0, showForm = true);
    	};

    	cancel = function () {
    		return $$invalidate(0, showForm = false);
    	};

    	add = function () {
    		console.log("add click");

    		if (stub.name.length > 0) {
    			dispatch("add", stub);
    			return resetStub();
    		}
    	};

    	keyup = function (e) {
    		if (e.key === "Return" || e.key === "Enter") {
    			add();
    		}

    		if (e.key === "Escape") {
    			return cancel();
    		}
    	};

    	const writable_props = ["showForm", "stubPlaceholder"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$n.warn(`<Clip> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Clip", $$slots, []);

    	function input0_input_handler() {
    		stub.name = this.value;
    		$$invalidate(6, stub);
    	}

    	function input1_input_handler() {
    		stub.content = this.value;
    		$$invalidate(6, stub);
    	}

    	$$self.$set = $$props => {
    		if ("showForm" in $$props) $$invalidate(0, showForm = $$props.showForm);
    		if ("stubPlaceholder" in $$props) $$invalidate(1, stubPlaceholder = $$props.stubPlaceholder);
    	};

    	$$self.$capture_state = () => ({
    		add,
    		cancel,
    		dispatch,
    		edit,
    		keyup,
    		resetStub,
    		stub,
    		AddStub,
    		createEventDispatcher,
    		showForm,
    		stubPlaceholder
    	});

    	$$self.$inject_state = $$props => {
    		if ("add" in $$props) $$invalidate(2, add = $$props.add);
    		if ("cancel" in $$props) $$invalidate(3, cancel = $$props.cancel);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("edit" in $$props) $$invalidate(4, edit = $$props.edit);
    		if ("keyup" in $$props) $$invalidate(5, keyup = $$props.keyup);
    		if ("resetStub" in $$props) resetStub = $$props.resetStub;
    		if ("stub" in $$props) $$invalidate(6, stub = $$props.stub);
    		if ("showForm" in $$props) $$invalidate(0, showForm = $$props.showForm);
    		if ("stubPlaceholder" in $$props) $$invalidate(1, stubPlaceholder = $$props.stubPlaceholder);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showForm,
    		stubPlaceholder,
    		add,
    		cancel,
    		edit,
    		keyup,
    		stub,
    		dispatch,
    		resetStub,
    		input0_input_handler,
    		input1_input_handler
    	];
    }

    class Clip$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, { showForm: 0, stubPlaceholder: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Clip",
    			options,
    			id: create_fragment$S.name
    		});
    	}

    	get showForm() {
    		throw new Error("<Clip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showForm(value) {
    		throw new Error("<Clip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stubPlaceholder() {
    		throw new Error("<Clip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stubPlaceholder(value) {
    		throw new Error("<Clip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Menus\Clip.svelte generated by Svelte v3.22.2 */

    const { console: console_1$o } = globals;
    const file$N = "src\\svelte\\pages\\_Common\\Menus\\Clip.svelte";

    // (111:4) {:else}
    function create_else_block$d(ctx) {
    	let li;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			button.textContent = "Unhide Clip Value";
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "svelte-11eiecq");
    			add_location(button, file$N, 112, 6, 2812);
    			attr_dev(li, "class", "svelte-11eiecq");
    			add_location(li, file$N, 111, 4, 2801);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*show*/ ctx[7])) /*show*/ ctx[7].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(111:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (107:4) {#if item.is_visible}
    function create_if_block_1$b(ctx) {
    	let li;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			button.textContent = "Hide Clip Value";
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "svelte-11eiecq");
    			add_location(button, file$N, 108, 6, 2712);
    			attr_dev(li, "class", "svelte-11eiecq");
    			add_location(li, file$N, 107, 4, 2701);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*hide*/ ctx[4])) /*hide*/ ctx[4].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(107:4) {#if item.is_visible}",
    		ctx
    	});

    	return block;
    }

    // (105:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align="right" {width}>
    function create_default_slot$n(ctx) {
    	let ul;
    	let t0;
    	let hr;
    	let t1;
    	let li;
    	let button;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*item*/ ctx[0].is_visible) return create_if_block_1$b;
    		return create_else_block$d;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if_block.c();
    			t0 = space();
    			hr = element("hr");
    			t1 = space();
    			li = element("li");
    			button = element("button");
    			button.textContent = "Delete Item";
    			attr_dev(hr, "class", "svelte-11eiecq");
    			add_location(hr, file$N, 115, 4, 2901);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "svelte-11eiecq");
    			add_location(button, file$N, 117, 6, 2922);
    			attr_dev(li, "class", "svelte-11eiecq");
    			add_location(li, file$N, 116, 4, 2911);
    			attr_dev(ul, "class", "svelte-11eiecq");
    			add_location(ul, file$N, 105, 2, 2666);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, ul, anchor);
    			if_block.m(ul, null);
    			append_dev(ul, t0);
    			append_dev(ul, hr);
    			append_dev(ul, t1);
    			append_dev(ul, li);
    			append_dev(li, button);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*deleteConfirmation*/ ctx[1])) /*deleteConfirmation*/ ctx[1].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(ul, t0);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if_block.d();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(105:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align=\\\"right\\\" {width}>",
    		ctx
    	});

    	return block;
    }

    // (122:0) {#if showDeleteConfirmation}
    function create_if_block$q(ctx) {
    	let current;
    	const deleteconfirmation = new DeleteConfirmation({ $$inline: true });

    	deleteconfirmation.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[3])) /*destroy*/ ctx[3].apply(this, arguments);
    	});

    	deleteconfirmation.$on("cancel", function () {
    		if (is_function(/*deleteConfirmationCancel*/ ctx[2])) /*deleteConfirmationCancel*/ ctx[2].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(deleteconfirmation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deleteconfirmation, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteconfirmation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteconfirmation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deleteconfirmation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(122:0) {#if showDeleteConfirmation}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$T(ctx) {
    	let button;
    	let svg;
    	let path;
    	let t0;
    	let updating_showMenu;
    	let t1;
    	let if_block_anchor;
    	let current;
    	let dispose;

    	function menu_showMenu_binding(value) {
    		/*menu_showMenu_binding*/ ctx[15].call(null, value);
    	}

    	let menu_props = {
    		trigger: /*menuButtonRef*/ ctx[5],
    		align: "right",
    		width: /*width*/ ctx[10],
    		$$slots: { default: [create_default_slot$n] },
    		$$scope: { ctx }
    	};

    	if (/*showMenu*/ ctx[9] !== void 0) {
    		menu_props.showMenu = /*showMenu*/ ctx[9];
    	}

    	const menu = new ComposedMenu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "showMenu", menu_showMenu_binding));
    	let if_block = /*showDeleteConfirmation*/ ctx[8] && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t0 = space();
    			create_component(menu.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(path, "d", "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z");
    			add_location(path, file$N, 102, 112, 2351);
    			attr_dev(svg, "class", "menu");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$N, 102, 2, 2241);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$N, 101, 0, 2165);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			/*button_binding*/ ctx[14](button);
    			insert_dev(target, t0, anchor);
    			mount_component(menu, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*openMenu*/ ctx[6])) /*openMenu*/ ctx[6].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const menu_changes = {};
    			if (dirty & /*menuButtonRef*/ 32) menu_changes.trigger = /*menuButtonRef*/ ctx[5];
    			if (dirty & /*width*/ 1024) menu_changes.width = /*width*/ ctx[10];

    			if (dirty & /*$$scope, deleteConfirmation, hide, item, show*/ 65683) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_showMenu && dirty & /*showMenu*/ 512) {
    				updating_showMenu = true;
    				menu_changes.showMenu = /*showMenu*/ ctx[9];
    				add_flush_callback(() => updating_showMenu = false);
    			}

    			menu.$set(menu_changes);

    			if (/*showDeleteConfirmation*/ ctx[8]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showDeleteConfirmation*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			/*button_binding*/ ctx[14](null);
    			if (detaching) detach_dev(t0);
    			destroy_component(menu, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	var closeMenu,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		hide,
    		indent,
    		menuButtonRef,
    		openMenu,
    		show,
    		showDeleteConfirmation,
    		showMenu,
    		width;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	menuButtonRef = void 0;
    	showMenu = false;

    	openMenu = function () {
    		return $$invalidate(9, showMenu = true);
    	};

    	closeMenu = function () {
    		return $$invalidate(9, showMenu = false);
    	};

    	width = "189px";

    	destroy = function () {
    		dispatch("destroy", item);
    		return closeMenu();
    	};

    	hide = function () {
    		dispatch("update", { id: item.id, is_visible: false });
    		return closeMenu();
    	};

    	show = function () {
    		dispatch("update", { id: item.id, is_visible: true });
    		return closeMenu();
    	};

    	indent = function (indentLevel) {
    		console.log(`set indentlevel ${indentLevel}`);
    		dispatch("update", { id: item.id, indent: indentLevel });
    		return closeMenu();
    	};

    	showDeleteConfirmation = false;

    	deleteConfirmation = function () {
    		closeMenu();
    		return $$invalidate(8, showDeleteConfirmation = true);
    	};

    	deleteConfirmationCancel = function () {
    		return $$invalidate(8, showDeleteConfirmation = false);
    	};

    	destroy = function () {
    		dispatch("destroy", item);
    		return $$invalidate(8, showDeleteConfirmation = false);
    	};

    	const writable_props = ["item"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$o.warn(`<Clip> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Clip", $$slots, []);

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(5, menuButtonRef = $$value);
    		});
    	}

    	function menu_showMenu_binding(value) {
    		showMenu = value;
    		$$invalidate(9, showMenu);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({
    		closeMenu,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		hide,
    		indent,
    		menuButtonRef,
    		openMenu,
    		show,
    		showDeleteConfirmation,
    		showMenu,
    		width,
    		createEventDispatcher,
    		Menu: ComposedMenu,
    		DeleteConfirmation,
    		item
    	});

    	$$self.$inject_state = $$props => {
    		if ("closeMenu" in $$props) closeMenu = $$props.closeMenu;
    		if ("deleteConfirmation" in $$props) $$invalidate(1, deleteConfirmation = $$props.deleteConfirmation);
    		if ("deleteConfirmationCancel" in $$props) $$invalidate(2, deleteConfirmationCancel = $$props.deleteConfirmationCancel);
    		if ("destroy" in $$props) $$invalidate(3, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("hide" in $$props) $$invalidate(4, hide = $$props.hide);
    		if ("indent" in $$props) indent = $$props.indent;
    		if ("menuButtonRef" in $$props) $$invalidate(5, menuButtonRef = $$props.menuButtonRef);
    		if ("openMenu" in $$props) $$invalidate(6, openMenu = $$props.openMenu);
    		if ("show" in $$props) $$invalidate(7, show = $$props.show);
    		if ("showDeleteConfirmation" in $$props) $$invalidate(8, showDeleteConfirmation = $$props.showDeleteConfirmation);
    		if ("showMenu" in $$props) $$invalidate(9, showMenu = $$props.showMenu);
    		if ("width" in $$props) $$invalidate(10, width = $$props.width);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		item,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		hide,
    		menuButtonRef,
    		openMenu,
    		show,
    		showDeleteConfirmation,
    		showMenu,
    		width,
    		closeMenu,
    		dispatch,
    		indent,
    		button_binding,
    		menu_showMenu_binding
    	];
    }

    class Clip$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, { item: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Clip",
    			options,
    			id: create_fragment$T.name
    		});
    	}

    	get item() {
    		throw new Error("<Clip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Clip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Sections\ClipList.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$9, console: console_1$p } = globals;
    const file$O = "src\\svelte\\pages\\_Common\\Sections\\ClipList.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	child_ctx[30] = list;
    	child_ctx[31] = i;
    	return child_ctx;
    }

    // (192:2) {#if list && list.length}
    function create_if_block$r(ctx) {
    	let div;
    	let t;
    	let current;

    	const droppabledivider = new DroppableDivider({
    			props: {
    				index: -1,
    				listId: /*listId*/ ctx[1],
    				sameListOnly: /*sameListOnly*/ ctx[2]
    			},
    			$$inline: true
    		});

    	droppabledivider.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[6])) /*dropEvent*/ ctx[6].apply(this, arguments);
    	});

    	let each_value = /*list*/ ctx[13];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(droppabledivider.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$O, 192, 4, 4349);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(droppabledivider, div, null);
    			append_dev(div, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const droppabledivider_changes = {};
    			if (dirty[0] & /*listId*/ 2) droppabledivider_changes.listId = /*listId*/ ctx[1];
    			if (dirty[0] & /*sameListOnly*/ 4) droppabledivider_changes.sameListOnly = /*sameListOnly*/ ctx[2];
    			droppabledivider.$set(droppabledivider_changes);

    			if (dirty[0] & /*list, listId, sameListOnly, dropEvent, updateAttribute, destroy, rowEl, style, updateName, copy*/ 15734 | dirty[1] & /*label*/ 2) {
    				each_value = /*list*/ ctx[13];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(droppabledivider.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(droppabledivider.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(droppabledivider);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(192:2) {#if list && list.length}",
    		ctx
    	});

    	return block;
    }

    // (206:14) <InlineInput bind:value={clipItem.name} on:update={updateName} {style} let:label>
    function create_default_slot_3$3(ctx) {
    	let label;
    	let t_value = (/*label*/ ctx[32] || "No name") + "";
    	let t;

    	const block = {
    		c: function create() {
    			label = element("label");
    			t = text(t_value);
    			add_location(label, file$O, 206, 16, 5356);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*label*/ 2 && t_value !== (t_value = (/*label*/ ctx[32] || "No name") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(206:14) <InlineInput bind:value={clipItem.name} on:update={updateName} {style} let:label>",
    		ctx
    	});

    	return block;
    }

    // (215:18) {:else}
    function create_else_block$e(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Value is Hidden";
    			attr_dev(span, "type", "hidden");
    			add_location(span, file$O, 215, 20, 5670);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(215:18) {:else}",
    		ctx
    	});

    	return block;
    }

    // (213:18) {#if clipItem.is_visible}
    function create_if_block_1$c(ctx) {
    	let t_value = (/*label*/ ctx[32] || "No content") + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[1] & /*label*/ 2 && t_value !== (t_value = (/*label*/ ctx[32] || "No content") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(213:18) {#if clipItem.is_visible}",
    		ctx
    	});

    	return block;
    }

    // (212:16) <InlineInput bind:value={clipItem.content} on:update={updateName} {style} let:label>
    function create_default_slot_2$6(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*clipItem*/ ctx[29].is_visible) return create_if_block_1$c;
    		return create_else_block$e;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(212:16) <InlineInput bind:value={clipItem.content} on:update={updateName} {style} let:label>",
    		ctx
    	});

    	return block;
    }

    // (227:10) <div slot="menu">
    function create_menu_slot$2(ctx) {
    	let div;
    	let current;

    	const menu = new Clip$2({
    			props: { item: /*clipItem*/ ctx[29] },
    			$$inline: true
    		});

    	menu.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[11])) /*updateAttribute*/ ctx[11].apply(this, arguments);
    	});

    	menu.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[5])) /*destroy*/ ctx[5].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(menu.$$.fragment);
    			attr_dev(div, "slot", "menu");
    			add_location(div, file$O, 226, 10, 5831);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(menu, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const menu_changes = {};
    			if (dirty[0] & /*list*/ 8192) menu_changes.item = /*clipItem*/ ctx[29];
    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(menu);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_menu_slot$2.name,
    		type: "slot",
    		source: "(227:10) <div slot=\\\"menu\\\">",
    		ctx
    	});

    	return block;
    }

    // (196:8) <DraggableItem item={clipItem} index={index} {listId} {sameListOnly} on:drop={dropEvent} on:update={updateAttribute}>
    function create_default_slot_1$8(ctx) {
    	let div2;
    	let t0;
    	let div0;
    	let button;
    	let svg;
    	let path;
    	let t1;
    	let div1;
    	let updating_value;
    	let t2;
    	let updating_value_1;
    	let t3;
    	let current;
    	let dispose;

    	const indent = new Indent({
    			props: {
    				level: /*clipItem*/ ctx[29].indent.clamp(0, 5)
    			},
    			$$inline: true
    		});

    	function inlineinput0_value_binding(value) {
    		/*inlineinput0_value_binding*/ ctx[25].call(null, value, /*clipItem*/ ctx[29]);
    	}

    	let inlineinput0_props = {
    		style: /*style*/ ctx[10],
    		$$slots: {
    			default: [
    				create_default_slot_3$3,
    				({ label }) => ({ 32: label }),
    				({ label }) => [0, label ? 2 : 0]
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*clipItem*/ ctx[29].name !== void 0) {
    		inlineinput0_props.value = /*clipItem*/ ctx[29].name;
    	}

    	const inlineinput0 = new InlineInput({
    			props: inlineinput0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(inlineinput0, "value", inlineinput0_value_binding));

    	inlineinput0.$on("update", function () {
    		if (is_function(/*updateName*/ ctx[12])) /*updateName*/ ctx[12].apply(this, arguments);
    	});

    	function inlineinput1_value_binding(value) {
    		/*inlineinput1_value_binding*/ ctx[26].call(null, value, /*clipItem*/ ctx[29]);
    	}

    	let inlineinput1_props = {
    		style: /*style*/ ctx[10],
    		$$slots: {
    			default: [
    				create_default_slot_2$6,
    				({ label }) => ({ 32: label }),
    				({ label }) => [0, label ? 2 : 0]
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*clipItem*/ ctx[29].content !== void 0) {
    		inlineinput1_props.value = /*clipItem*/ ctx[29].content;
    	}

    	const inlineinput1 = new InlineInput({
    			props: inlineinput1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(inlineinput1, "value", inlineinput1_value_binding));

    	inlineinput1.$on("update", function () {
    		if (is_function(/*updateName*/ ctx[12])) /*updateName*/ ctx[12].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			create_component(indent.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t1 = space();
    			div1 = element("div");
    			create_component(inlineinput0.$$.fragment);
    			t2 = space();
    			create_component(inlineinput1.$$.fragment);
    			t3 = space();
    			attr_dev(path, "d", "M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z");
    			attr_dev(path, "class", "fill svelte-8qodui");
    			add_location(path, file$O, 201, 113, 5005);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$O, 201, 16, 4908);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$O, 200, 14, 4806);
    			attr_dev(div0, "flex", "initial");
    			set_style(div0, "padding-right", "8px");
    			add_location(div0, file$O, 199, 12, 4742);
    			attr_dev(div1, "flex", "");
    			attr_dev(div1, "ellipsis", "");
    			attr_dev(div1, "main", "");
    			add_location(div1, file$O, 204, 12, 5217);
    			attr_dev(div2, "layout", "row");
    			attr_dev(div2, "type", "list-item");
    			attr_dev(div2, "class", "svelte-8qodui");
    			add_location(div2, file$O, 197, 10, 4617);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div2, anchor);
    			mount_component(indent, div2, null);
    			append_dev(div2, t0);
    			append_dev(div2, div0);
    			append_dev(div0, button);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(inlineinput0, div1, null);
    			append_dev(div1, t2);
    			mount_component(inlineinput1, div1, null);
    			/*div2_binding*/ ctx[27](div2);
    			insert_dev(target, t3, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				stop_propagation(prevent_default(function () {
    					if (is_function(/*copy*/ ctx[4](/*clipItem*/ ctx[29]))) /*copy*/ ctx[4](/*clipItem*/ ctx[29]).apply(this, arguments);
    				})),
    				false,
    				true,
    				true
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const indent_changes = {};
    			if (dirty[0] & /*list*/ 8192) indent_changes.level = /*clipItem*/ ctx[29].indent.clamp(0, 5);
    			indent.$set(indent_changes);
    			const inlineinput0_changes = {};
    			if (dirty[0] & /*style*/ 1024) inlineinput0_changes.style = /*style*/ ctx[10];

    			if (dirty[1] & /*$$scope, label*/ 6) {
    				inlineinput0_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty[0] & /*list*/ 8192) {
    				updating_value = true;
    				inlineinput0_changes.value = /*clipItem*/ ctx[29].name;
    				add_flush_callback(() => updating_value = false);
    			}

    			inlineinput0.$set(inlineinput0_changes);
    			const inlineinput1_changes = {};
    			if (dirty[0] & /*style*/ 1024) inlineinput1_changes.style = /*style*/ ctx[10];

    			if (dirty[0] & /*list*/ 8192 | dirty[1] & /*$$scope, label*/ 6) {
    				inlineinput1_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value_1 && dirty[0] & /*list*/ 8192) {
    				updating_value_1 = true;
    				inlineinput1_changes.value = /*clipItem*/ ctx[29].content;
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			inlineinput1.$set(inlineinput1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indent.$$.fragment, local);
    			transition_in(inlineinput0.$$.fragment, local);
    			transition_in(inlineinput1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indent.$$.fragment, local);
    			transition_out(inlineinput0.$$.fragment, local);
    			transition_out(inlineinput1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(indent);
    			destroy_component(inlineinput0);
    			destroy_component(inlineinput1);
    			/*div2_binding*/ ctx[27](null);
    			if (detaching) detach_dev(t3);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(196:8) <DraggableItem item={clipItem} index={index} {listId} {sameListOnly} on:drop={dropEvent} on:update={updateAttribute}>",
    		ctx
    	});

    	return block;
    }

    // (195:6) {#each list as clipItem, index}
    function create_each_block$a(ctx) {
    	let t;
    	let current;

    	const draggableitem = new DraggableIndentableItem({
    			props: {
    				item: /*clipItem*/ ctx[29],
    				index: /*index*/ ctx[31],
    				listId: /*listId*/ ctx[1],
    				sameListOnly: /*sameListOnly*/ ctx[2],
    				$$slots: {
    					default: [create_default_slot_1$8],
    					menu: [create_menu_slot$2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	draggableitem.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[6])) /*dropEvent*/ ctx[6].apply(this, arguments);
    	});

    	draggableitem.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[11])) /*updateAttribute*/ ctx[11].apply(this, arguments);
    	});

    	const droppabledivider = new DroppableDivider({
    			props: {
    				item: /*clipItem*/ ctx[29],
    				index: /*index*/ ctx[31],
    				listId: /*listId*/ ctx[1],
    				sameListOnly: /*sameListOnly*/ ctx[2]
    			},
    			$$inline: true
    		});

    	droppabledivider.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[6])) /*dropEvent*/ ctx[6].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(draggableitem.$$.fragment);
    			t = space();
    			create_component(droppabledivider.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(draggableitem, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(droppabledivider, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const draggableitem_changes = {};
    			if (dirty[0] & /*list*/ 8192) draggableitem_changes.item = /*clipItem*/ ctx[29];
    			if (dirty[0] & /*listId*/ 2) draggableitem_changes.listId = /*listId*/ ctx[1];
    			if (dirty[0] & /*sameListOnly*/ 4) draggableitem_changes.sameListOnly = /*sameListOnly*/ ctx[2];

    			if (dirty[0] & /*list, updateAttribute, destroy, rowEl, style, updateName, copy*/ 15664 | dirty[1] & /*$$scope*/ 4) {
    				draggableitem_changes.$$scope = { dirty, ctx };
    			}

    			draggableitem.$set(draggableitem_changes);
    			const droppabledivider_changes = {};
    			if (dirty[0] & /*list*/ 8192) droppabledivider_changes.item = /*clipItem*/ ctx[29];
    			if (dirty[0] & /*listId*/ 2) droppabledivider_changes.listId = /*listId*/ ctx[1];
    			if (dirty[0] & /*sameListOnly*/ 4) droppabledivider_changes.sameListOnly = /*sameListOnly*/ ctx[2];
    			droppabledivider.$set(droppabledivider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(draggableitem.$$.fragment, local);
    			transition_in(droppabledivider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(draggableitem.$$.fragment, local);
    			transition_out(droppabledivider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(draggableitem, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(droppabledivider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(195:6) {#each list as clipItem, index}",
    		ctx
    	});

    	return block;
    }

    // (190:0) <Section name={collection.titleize()} {open}>
    function create_default_slot$o(ctx) {
    	let t0;
    	let t1;
    	let updating_show;
    	let current;
    	let if_block = /*list*/ ctx[13] && /*list*/ ctx[13].length && create_if_block$r(ctx);
    	const quickentry = new Clip$1({ $$inline: true });

    	quickentry.$on("add", function () {
    		if (is_function(/*add*/ ctx[3])) /*add*/ ctx[3].apply(this, arguments);
    	});

    	function toast_show_binding(value) {
    		/*toast_show_binding*/ ctx[28].call(null, value);
    	}

    	let toast_props = { message: /*message*/ ctx[7] };

    	if (/*showToast*/ ctx[9] !== void 0) {
    		toast_props.show = /*showToast*/ ctx[9];
    	}

    	const toast = new Toast({ props: toast_props, $$inline: true });
    	binding_callbacks.push(() => bind(toast, "show", toast_show_binding));

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(quickentry.$$.fragment);
    			t1 = space();
    			create_component(toast.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(quickentry, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(toast, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*list*/ ctx[13] && /*list*/ ctx[13].length) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*list*/ 8192) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$r(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const toast_changes = {};
    			if (dirty[0] & /*message*/ 128) toast_changes.message = /*message*/ ctx[7];

    			if (!updating_show && dirty[0] & /*showToast*/ 512) {
    				updating_show = true;
    				toast_changes.show = /*showToast*/ ctx[9];
    				add_flush_callback(() => updating_show = false);
    			}

    			toast.$set(toast_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(quickentry.$$.fragment, local);
    			transition_in(toast.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(quickentry.$$.fragment, local);
    			transition_out(toast.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(quickentry, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(toast, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(190:0) <Section name={collection.titleize()} {open}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$U(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				name: /*collection*/ ctx[0].titleize(),
    				open,
    				$$slots: { default: [create_default_slot$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const section_changes = {};
    			if (dirty[0] & /*collection*/ 1) section_changes.name = /*collection*/ ctx[0].titleize();

    			if (dirty[0] & /*message, showToast, add, list, listId, sameListOnly, dropEvent, updateAttribute, destroy, rowEl, style, updateName, copy*/ 16382 | dirty[1] & /*$$scope*/ 4) {
    				section_changes.$$scope = { dirty, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	var add,
    		copy,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		dropEvent,
    		getWidth,
    		message,
    		rowEl,
    		showDeleteConfirmation,
    		showDeleteModal,
    		showToast,
    		sort,
    		style,
    		subDocument,
    		toggleVisibility,
    		update,
    		updateAttribute,
    		updateName;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	var { collection = "clips" } = $$props;
    	var { listId = uuid() } = $$props;
    	var { sameListOnly = true } = $$props;
    	subDocument = new clip();
    	dispatch = createEventDispatcher();
    	message = "";
    	showToast = false;
    	style = ":hover {font-weight: bold}";

    	copy = function (e) {
    		return console.log("COPY CLICK");
    	};

    	copy = function (val) {
    		var dummy;
    		console.log("copy clicked");
    		dummy = document.createElement("input");
    		document.body.appendChild(dummy);
    		dummy.setAttribute("id", `clip-${val.id}`);
    		document.getElementById(`clip-${val.id}`).value = val.content;
    		dummy.select();
    		document.execCommand("copy");
    		document.body.removeChild(dummy);

    		// toast it!
    		$$invalidate(7, message = `Copied value for item named <b>${val.name.truncateOnWord(255)}</b> to clipboard`);

    		return $$invalidate(9, showToast = true);
    	};

    	toggleVisibility = function (val) {
    		var thisItem;
    		console.log(val);
    		thisItem = item.clips.find({ id: val.id });
    		thisItem.is_visible = !thisItem.is_visible;
    		$$invalidate(14, item);
    		return dispatch("update");
    	};

    	showDeleteConfirmation = false;

    	showDeleteModal = function () {
    		return showDeleteConfirmation = true;
    	};

    	deleteConfirmationCancel = function () {
    		return showDeleteConfirmation = false;
    	};

    	destroy = function (e) {
    		console.log("ClipList.destroy");
    		console.log(e.detail);
    		item[collection].remove({ id: e.detail.id });
    		$$invalidate(14, item);
    		dispatch("update");
    		return showDeleteConfirmation = false;
    	};

    	updateName = function (e) {
    		var change;
    		console.log(e.detail);
    		change = { id: item.id, name: e.detail };
    		return dispatch("update", change);
    	};

    	updateAttribute = function (e) {
    		var change, changedTask;
    		change = e.detail;
    		changedTask = item[collection].find({ id: change.id });

    		if (changedTask != null) {
    			Object.merge(changedTask, change);
    			$$invalidate(14, item);
    			return dispatch("update", change);
    		} else {
    			return console.log("unchanged");
    		}
    	};

    	update = function () {
    		return dispatch("update");
    	};

    	add = function (event) {
    		var newRecord;
    		console.log("add");
    		console.log(event.detail);
    		newRecord = subDocument.stub(event.detail);
    		newRecord.ordinal = (item[collection] || []).length;
    		$$invalidate(14, item[collection] = item[collection].add(newRecord), item);
    		return dispatch("update");
    	};

    	// drag and drop
    	dropEvent = function (e) {
    		var invalidDrop, refresh, tree;
    		refresh = false;
    		tree = new hierarchical_list(item[collection]);
    		invalidDrop = tree.isInvalidDrop(e.detail);

    		if (invalidDrop != null) {
    			$$invalidate(7, message = invalidDrop);
    			$$invalidate(9, showToast = true);
    		} else {
    			refresh = tree.dropEvent(e.detail);
    		}

    		if (refresh) {
    			$$invalidate(14, item[collection] = tree.list, item);
    			return dispatch("update");
    		}
    	};

    	rowEl = void 0;

    	sort = function (list) {
    		if (item[collection] != null) {
    			return item[collection].sortBy("ordinal");
    		} else {
    			return [];
    		}
    	};

    	getWidth = function (el) {
    		if (el != null) {
    			return el.clientWidth;
    		} else {
    			return 0;
    		}
    	};

    	const writable_props = ["item", "collection", "listId", "sameListOnly"];

    	Object_1$9.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$p.warn(`<ClipList> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ClipList", $$slots, []);

    	function inlineinput0_value_binding(value, clipItem) {
    		clipItem.name = value;
    		((($$invalidate(13, list), $$invalidate(20, sort)), $$invalidate(14, item)), $$invalidate(0, collection));
    	}

    	function inlineinput1_value_binding(value, clipItem) {
    		clipItem.content = value;
    		((($$invalidate(13, list), $$invalidate(20, sort)), $$invalidate(14, item)), $$invalidate(0, collection));
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(8, rowEl = $$value);
    		});
    	}

    	function toast_show_binding(value) {
    		showToast = value;
    		$$invalidate(9, showToast);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(14, item = $$props.item);
    		if ("collection" in $$props) $$invalidate(0, collection = $$props.collection);
    		if ("listId" in $$props) $$invalidate(1, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(2, sameListOnly = $$props.sameListOnly);
    	};

    	$$self.$capture_state = () => ({
    		add,
    		copy,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		dropEvent,
    		getWidth,
    		message,
    		rowEl,
    		showDeleteConfirmation,
    		showDeleteModal,
    		showToast,
    		sort,
    		style,
    		subDocument,
    		toggleVisibility,
    		update,
    		updateAttribute,
    		updateName,
    		createEventDispatcher,
    		Clip: clip,
    		Toast,
    		Indent,
    		DraggableItem: DraggableIndentableItem,
    		DroppableDivider,
    		QuickEntry: Clip$1,
    		InlineInput,
    		HierarchicalList: hierarchical_list,
    		Section,
    		Menu: Clip$2,
    		item,
    		collection,
    		listId,
    		sameListOnly,
    		list,
    		show
    	});

    	$$self.$inject_state = $$props => {
    		if ("add" in $$props) $$invalidate(3, add = $$props.add);
    		if ("copy" in $$props) $$invalidate(4, copy = $$props.copy);
    		if ("deleteConfirmationCancel" in $$props) deleteConfirmationCancel = $$props.deleteConfirmationCancel;
    		if ("destroy" in $$props) $$invalidate(5, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("dropEvent" in $$props) $$invalidate(6, dropEvent = $$props.dropEvent);
    		if ("getWidth" in $$props) getWidth = $$props.getWidth;
    		if ("message" in $$props) $$invalidate(7, message = $$props.message);
    		if ("rowEl" in $$props) $$invalidate(8, rowEl = $$props.rowEl);
    		if ("showDeleteConfirmation" in $$props) showDeleteConfirmation = $$props.showDeleteConfirmation;
    		if ("showDeleteModal" in $$props) showDeleteModal = $$props.showDeleteModal;
    		if ("showToast" in $$props) $$invalidate(9, showToast = $$props.showToast);
    		if ("sort" in $$props) $$invalidate(20, sort = $$props.sort);
    		if ("style" in $$props) $$invalidate(10, style = $$props.style);
    		if ("subDocument" in $$props) subDocument = $$props.subDocument;
    		if ("toggleVisibility" in $$props) toggleVisibility = $$props.toggleVisibility;
    		if ("update" in $$props) update = $$props.update;
    		if ("updateAttribute" in $$props) $$invalidate(11, updateAttribute = $$props.updateAttribute);
    		if ("updateName" in $$props) $$invalidate(12, updateName = $$props.updateName);
    		if ("item" in $$props) $$invalidate(14, item = $$props.item);
    		if ("collection" in $$props) $$invalidate(0, collection = $$props.collection);
    		if ("listId" in $$props) $$invalidate(1, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(2, sameListOnly = $$props.sameListOnly);
    		if ("list" in $$props) $$invalidate(13, list = $$props.list);
    		if ("show" in $$props) show = $$props.show;
    	};

    	let list;
    	let show;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*sort, item, collection*/ 1064961) {
    			 $$invalidate(13, list = sort(item[collection]));
    		}

    		if ($$self.$$.dirty[0] & /*showToast*/ 512) {
    			 show = showToast;
    		}
    	};

    	return [
    		collection,
    		listId,
    		sameListOnly,
    		add,
    		copy,
    		destroy,
    		dropEvent,
    		message,
    		rowEl,
    		showToast,
    		style,
    		updateAttribute,
    		updateName,
    		list,
    		item,
    		deleteConfirmationCancel,
    		dispatch,
    		getWidth,
    		showDeleteConfirmation,
    		showDeleteModal,
    		sort,
    		subDocument,
    		toggleVisibility,
    		update,
    		show,
    		inlineinput0_value_binding,
    		inlineinput1_value_binding,
    		div2_binding,
    		toast_show_binding
    	];
    }

    class ClipList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$U,
    			create_fragment$U,
    			safe_not_equal,
    			{
    				item: 14,
    				collection: 0,
    				listId: 1,
    				sameListOnly: 2
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClipList",
    			options,
    			id: create_fragment$U.name
    		});
    	}

    	get item() {
    		throw new Error("<ClipList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<ClipList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collection() {
    		throw new Error("<ClipList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collection(value) {
    		throw new Error("<ClipList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listId() {
    		throw new Error("<ClipList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listId(value) {
    		throw new Error("<ClipList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sameListOnly() {
    		throw new Error("<ClipList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sameListOnly(value) {
    		throw new Error("<ClipList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Form\SearchInput\SearchInput.svelte generated by Svelte v3.22.2 */
    const file$P = "src\\svelte\\components\\Form\\SearchInput\\SearchInput.svelte";

    function create_fragment$V(ctx) {
    	let div1;
    	let div0;
    	let svg0;
    	let path0;
    	let path1;
    	let t0;
    	let input;
    	let t1;
    	let button;
    	let svg1;
    	let path2;
    	let path3;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t0 = space();
    			input = element("input");
    			t1 = space();
    			button = element("button");
    			svg1 = svg_element("svg");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			attr_dev(path0, "fill", "none");
    			add_location(path0, file$P, 34, 87, 744);
    			attr_dev(path1, "d", "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z");
    			add_location(path1, file$P, 34, 126, 783);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			attr_dev(svg0, "width", "24");
    			add_location(svg0, file$P, 34, 4, 661);
    			attr_dev(div0, "type", "button");
    			attr_dev(div0, "icon", "");
    			attr_dev(div0, "input-left", "");
    			add_location(div0, file$P, 33, 2, 621);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "role", "searchbox");
    			input.value = /*value*/ ctx[0];
    			input.autofocus = /*autofocus*/ ctx[1];
    			attr_dev(input, "id", /*id*/ ctx[3]);
    			attr_dev(input, "placeholder", /*placeholder*/ ctx[4]);
    			attr_dev(input, "class", "svelte-bzmrcv");
    			add_location(input, file$P, 36, 2, 1047);
    			attr_dev(path2, "fill", "none");
    			attr_dev(path2, "d", "M0 0h24v24H0V0z");
    			add_location(path2, file$P, 51, 87, 1480);
    			attr_dev(path3, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z");
    			add_location(path3, file$P, 51, 126, 1519);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			add_location(svg1, file$P, 51, 4, 1397);
    			attr_dev(button, "icon", "");
    			attr_dev(button, "type", "button");
    			attr_dev(button, "input-right", "");
    			attr_dev(button, "aria-label", /*closeButtonLabelText*/ ctx[2]);
    			attr_dev(button, "show", /*showClear*/ ctx[7]);
    			add_location(button, file$P, 50, 2, 1283);
    			attr_dev(div1, "class", "svelte-bzmrcv");
    			add_location(div1, file$P, 32, 0, 613);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, svg0);
    			append_dev(svg0, path0);
    			append_dev(svg0, path1);
    			append_dev(div1, t0);
    			append_dev(div1, input);
    			/*input_binding*/ ctx[12](input);
    			append_dev(div1, t1);
    			append_dev(div1, button);
    			append_dev(button, svg1);
    			append_dev(svg1, path2);
    			append_dev(svg1, path3);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(input, "change", /*change_handler*/ ctx[10], false, false, false),
    				listen_dev(input, "keyup", /*keyup_handler*/ ctx[11], false, false, false),
    				listen_dev(input, "input", /*input_handler*/ ctx[9], false, false, false),
    				listen_dev(input, "input", /*input_handler_1*/ ctx[13], false, false, false),
    				listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*clear*/ ctx[5])) /*clear*/ ctx[5].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				prop_dev(input, "value", /*value*/ ctx[0]);
    			}

    			if (dirty & /*autofocus*/ 2) {
    				prop_dev(input, "autofocus", /*autofocus*/ ctx[1]);
    			}

    			if (dirty & /*id*/ 8) {
    				attr_dev(input, "id", /*id*/ ctx[3]);
    			}

    			if (dirty & /*placeholder*/ 16) {
    				attr_dev(input, "placeholder", /*placeholder*/ ctx[4]);
    			}

    			if (dirty & /*closeButtonLabelText*/ 4) {
    				attr_dev(button, "aria-label", /*closeButtonLabelText*/ ctx[2]);
    			}

    			if (dirty & /*showClear*/ 128) {
    				attr_dev(button, "show", /*showClear*/ ctx[7]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*input_binding*/ ctx[12](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	var clear, dispatch, inputRef;
    	dispatch = createEventDispatcher();
    	var { autofocus = false } = $$props;
    	var { closeButtonLabelText = "Clear search input" } = $$props;
    	var { id = uuid() } = $$props;
    	var { placeholder = "Search..." } = $$props;
    	var { value = "" } = $$props;
    	inputRef = void 0;

    	clear = function () {
    		$$invalidate(0, value = "");
    		return inputRef.focus();
    	};

    	const writable_props = ["autofocus", "closeButtonLabelText", "id", "placeholder", "value"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SearchInput> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SearchInput", $$slots, []);

    	function input_handler(event) {
    		bubble($$self, event);
    	}

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(6, inputRef = $$value);
    		});
    	}

    	const input_handler_1 = ({ target }) => {
    		$$invalidate(0, value = target.value);
    	};

    	$$self.$set = $$props => {
    		if ("autofocus" in $$props) $$invalidate(1, autofocus = $$props.autofocus);
    		if ("closeButtonLabelText" in $$props) $$invalidate(2, closeButtonLabelText = $$props.closeButtonLabelText);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("placeholder" in $$props) $$invalidate(4, placeholder = $$props.placeholder);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		clear,
    		dispatch,
    		inputRef,
    		createEventDispatcher,
    		autofocus,
    		closeButtonLabelText,
    		id,
    		placeholder,
    		value,
    		showClear
    	});

    	$$self.$inject_state = $$props => {
    		if ("clear" in $$props) $$invalidate(5, clear = $$props.clear);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("inputRef" in $$props) $$invalidate(6, inputRef = $$props.inputRef);
    		if ("autofocus" in $$props) $$invalidate(1, autofocus = $$props.autofocus);
    		if ("closeButtonLabelText" in $$props) $$invalidate(2, closeButtonLabelText = $$props.closeButtonLabelText);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("placeholder" in $$props) $$invalidate(4, placeholder = $$props.placeholder);
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("showClear" in $$props) $$invalidate(7, showClear = $$props.showClear);
    	};

    	let showClear;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 1) {
    			 $$invalidate(7, showClear = value != "");
    		}
    	};

    	return [
    		value,
    		autofocus,
    		closeButtonLabelText,
    		id,
    		placeholder,
    		clear,
    		inputRef,
    		showClear,
    		dispatch,
    		input_handler,
    		change_handler,
    		keyup_handler,
    		input_binding,
    		input_handler_1
    	];
    }

    class SearchInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$V, create_fragment$V, safe_not_equal, {
    			autofocus: 1,
    			closeButtonLabelText: 2,
    			id: 3,
    			placeholder: 4,
    			value: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SearchInput",
    			options,
    			id: create_fragment$V.name
    		});
    	}

    	get autofocus() {
    		throw new Error("<SearchInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autofocus(value) {
    		throw new Error("<SearchInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeButtonLabelText() {
    		throw new Error("<SearchInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set closeButtonLabelText(value) {
    		throw new Error("<SearchInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<SearchInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<SearchInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<SearchInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<SearchInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<SearchInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<SearchInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Overlay\Menu\SortMenu.svelte generated by Svelte v3.22.2 */

    const { console: console_1$q } = globals;
    const file$Q = "src\\svelte\\components\\Overlay\\Menu\\SortMenu.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[25] = list[i];
    	child_ctx[27] = i;
    	return child_ctx;
    }

    // (144:0) {#if showMenu}
    function create_if_block$s(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let div_transition;
    	let current;
    	let each_value = /*items*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*item*/ ctx[25].id || /*i*/ ctx[27];
    	validate_each_keys(ctx, each_value, get_each_context$b, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$b(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$b(key, child_ctx));
    	}

    	let if_block = /*items*/ ctx[1].length == 0 && create_if_block_1$d(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "menu", "");
    			attr_dev(div, "id", /*menuId*/ ctx[8]);
    			attr_dev(div, "style", /*style*/ ctx[12]);
    			attr_dev(div, "align", /*align*/ ctx[6]);
    			attr_dev(div, "class", "svelte-1etyah2");
    			add_location(div, file$Q, 144, 2, 3114);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			/*div_binding*/ ctx[24](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items, idKey, selectedIndex, highlightedIndex, menuItemClick, labelKey*/ 694) {
    				const each_value = /*items*/ ctx[1];
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$b, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, destroy_block, create_each_block$b, t, get_each_context$b);
    			}

    			if (/*items*/ ctx[1].length == 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$d(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty & /*menuId*/ 256) {
    				attr_dev(div, "id", /*menuId*/ ctx[8]);
    			}

    			if (!current || dirty & /*style*/ 4096) {
    				attr_dev(div, "style", /*style*/ ctx[12]);
    			}

    			if (!current || dirty & /*align*/ 64) {
    				attr_dev(div, "align", /*align*/ ctx[6]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 75 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 75 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (if_block) if_block.d();
    			/*div_binding*/ ctx[24](null);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(144:0) {#if showMenu}",
    		ctx
    	});

    	return block;
    }

    // (156:12) {:else}
    function create_else_block_1$4(ctx) {
    	let svg;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$Q, 156, 14, 4053);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(156:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (150:12) {#if item.selected}
    function create_if_block_2$5(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*item*/ ctx[25].ascending) return create_if_block_3$4;
    		return create_else_block$f;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(150:12) {#if item.selected}",
    		ctx
    	});

    	return block;
    }

    // (153:14) {:else}
    function create_else_block$f(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$Q, 153, 99, 3879);
    			attr_dev(path1, "d", "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z");
    			add_location(path1, file$Q, 153, 138, 3918);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$Q, 153, 16, 3796);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(153:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (151:14) {#if item.ascending}
    function create_if_block_3$4(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$Q, 151, 99, 3641);
    			attr_dev(path1, "d", "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z");
    			add_location(path1, file$Q, 151, 138, 3680);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$Q, 151, 16, 3558);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(151:14) {#if item.ascending}",
    		ctx
    	});

    	return block;
    }

    // (146:4) {#each items as item, i (item.id || i)}
    function create_each_block$b(key_1, ctx) {
    	let button;
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let t1_value = /*item*/ ctx[25][/*labelKey*/ ctx[4]] + "";
    	let t1;
    	let button_id_value;
    	let button_active_value;
    	let button_highlighted_value;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*item*/ ctx[25].selected) return create_if_block_2$5;
    		return create_else_block_1$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			button = element("button");
    			div2 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t0 = space();
    			div1 = element("div");
    			t1 = text(t1_value);
    			attr_dev(div0, "flex", "initial");
    			add_location(div0, file$Q, 148, 10, 3454);
    			attr_dev(div1, "flex", "");
    			add_location(div1, file$Q, 159, 10, 4188);
    			attr_dev(div2, "layout", "row");
    			add_location(div2, file$Q, 147, 8, 3425);
    			attr_dev(button, "menu-item", "");
    			attr_dev(button, "id", button_id_value = /*item*/ ctx[25][/*idKey*/ ctx[5]]);
    			attr_dev(button, "active", button_active_value = /*selectedIndex*/ ctx[2] === /*i*/ ctx[27]);
    			attr_dev(button, "highlighted", button_highlighted_value = /*highlightedIndex*/ ctx[7] === /*i*/ ctx[27] || /*selectedIndex*/ ctx[2] === /*i*/ ctx[27]);
    			attr_dev(button, "class", "svelte-1etyah2");
    			add_location(button, file$Q, 146, 6, 3259);
    			this.first = button;
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			append_dev(button, div2);
    			append_dev(div2, div0);
    			if_block.m(div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, t1);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*menuItemClick*/ ctx[9](/*item*/ ctx[25], /*i*/ ctx[27]))) /*menuItemClick*/ ctx[9](/*item*/ ctx[25], /*i*/ ctx[27]).apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}

    			if (dirty & /*items, labelKey*/ 18 && t1_value !== (t1_value = /*item*/ ctx[25][/*labelKey*/ ctx[4]] + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*items, idKey*/ 34 && button_id_value !== (button_id_value = /*item*/ ctx[25][/*idKey*/ ctx[5]])) {
    				attr_dev(button, "id", button_id_value);
    			}

    			if (dirty & /*selectedIndex, items*/ 6 && button_active_value !== (button_active_value = /*selectedIndex*/ ctx[2] === /*i*/ ctx[27])) {
    				attr_dev(button, "active", button_active_value);
    			}

    			if (dirty & /*highlightedIndex, items, selectedIndex*/ 134 && button_highlighted_value !== (button_highlighted_value = /*highlightedIndex*/ ctx[7] === /*i*/ ctx[27] || /*selectedIndex*/ ctx[2] === /*i*/ ctx[27])) {
    				attr_dev(button, "highlighted", button_highlighted_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if_block.d();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(146:4) {#each items as item, i (item.id || i)}",
    		ctx
    	});

    	return block;
    }

    // (164:4) {#if items.length == 0}
    function create_if_block_1$d(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			attr_dev(button, "menu-item", "");
    			attr_dev(button, "class", "svelte-1etyah2");
    			add_location(button, file$Q, 164, 6, 4298);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			button.innerHTML = /*blankSlate*/ ctx[3];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*blankSlate*/ 8) button.innerHTML = /*blankSlate*/ ctx[3];		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(164:4) {#if items.length == 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let div;
    	let t;
    	let if_block_anchor;
    	let current;
    	let dispose;
    	let if_block = /*showMenu*/ ctx[0] && create_if_block$s(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(div, "type", "overlay");
    			attr_dev(div, "clear", "");
    			attr_dev(div, "open", /*showMenu*/ ctx[0]);
    			add_location(div, file$Q, 142, 0, 3029);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div,
    				"click",
    				function () {
    					if (is_function(/*overlayClick*/ ctx[11])) /*overlayClick*/ ctx[11].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (!current || dirty & /*showMenu*/ 1) {
    				attr_dev(div, "open", /*showMenu*/ ctx[0]);
    			}

    			if (/*showMenu*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showMenu*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$s(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	var changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		highlightedIndex,
    		menuId,
    		menuItemClick,
    		menuRef,
    		overlayClick,
    		style;

    	dispatch = createEventDispatcher();
    	var { disabled = false } = $$props;
    	var { id = uuid() } = $$props;
    	var { items = [] } = $$props;
    	var { width = "200px" } = $$props;
    	var { selectedIndex = -1 } = $$props;
    	var { size = void 0 } = $$props;
    	var { value = "" } = $$props;
    	var { blankSlate = "" } = $$props;
    	var { labelKey = "label" } = $$props;
    	var { idKey = "id" } = $$props;
    	var { showMenu = false } = $$props;
    	var { align = "left" } = $$props;
    	var { trigger = void 0 } = $$props;
    	var { matchTrigger = false } = $$props;
    	style = void 0;
    	menuRef = void 0;
    	hasfocus = false;
    	highlightedIndex = -1;

    	changeIndex = function (direction) {
    		var index;
    		index = highlightedIndex + direction;

    		if (index < 0) {
    			index = items.length - 1;
    		} else if (index >= items.length) {
    			index = 0;
    		}

    		return $$invalidate(7, highlightedIndex = index);
    	};

    	menuId = uuid();

    	onMount(function () {
    		return console.log("parent, mounted");
    	});

    	checkTrigger = function (i) {
    		var right, triggerContainerWidth, triggerCoords;

    		if (i != null) {
    			if (matchTrigger) {
    				$$invalidate(12, style = `width: ${width};top: ${i.clientHeight + 4}px; width: ${i.clientWidth + 2}px`);
    			} else {
    				if (align === "left") {
    					$$invalidate(12, style = `width: ${width};top: ${i.offsetParent.clientHeight + 4}px;`);
    				} else {
    					triggerContainerWidth = i.offsetParent.clientWidth;
    					triggerCoords = i.getBoundingClientRect();
    					right = triggerContainerWidth - triggerCoords.width;
    					$$invalidate(12, style = `width: ${width};top: ${i.offsetParent.clientHeight + 4}px; right: ${right}px`);
    				}
    			}
    		}

    		console.log("trigger");
    		console.log(i);
    		console.log("style");
    		return console.log(style);
    	};

    	menuItemClick = function (item, index) {
    		var changedItem;
    		changedItem = null;

    		items.forEach(function (i) {
    			if (i.id === item.id) {
    				if (i.selected) {
    					i.ascending = !i.ascending;
    				} else {
    					i.selected = true;
    				}

    				return changedItem = i;
    			} else {
    				return i.selected = false;
    			}
    		});

    		$$invalidate(0, showMenu = false);
    		return dispatch("click", { item: changedItem, items });
    	};

    	overlayClick = function () {
    		return $$invalidate(0, showMenu = false);
    	};

    	const writable_props = [
    		"disabled",
    		"id",
    		"items",
    		"width",
    		"selectedIndex",
    		"size",
    		"value",
    		"blankSlate",
    		"labelKey",
    		"idKey",
    		"showMenu",
    		"align",
    		"trigger",
    		"matchTrigger"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$q.warn(`<SortMenu> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SortMenu", $$slots, []);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(10, menuRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("disabled" in $$props) $$invalidate(13, disabled = $$props.disabled);
    		if ("id" in $$props) $$invalidate(14, id = $$props.id);
    		if ("items" in $$props) $$invalidate(1, items = $$props.items);
    		if ("width" in $$props) $$invalidate(15, width = $$props.width);
    		if ("selectedIndex" in $$props) $$invalidate(2, selectedIndex = $$props.selectedIndex);
    		if ("size" in $$props) $$invalidate(16, size = $$props.size);
    		if ("value" in $$props) $$invalidate(17, value = $$props.value);
    		if ("blankSlate" in $$props) $$invalidate(3, blankSlate = $$props.blankSlate);
    		if ("labelKey" in $$props) $$invalidate(4, labelKey = $$props.labelKey);
    		if ("idKey" in $$props) $$invalidate(5, idKey = $$props.idKey);
    		if ("showMenu" in $$props) $$invalidate(0, showMenu = $$props.showMenu);
    		if ("align" in $$props) $$invalidate(6, align = $$props.align);
    		if ("trigger" in $$props) $$invalidate(18, trigger = $$props.trigger);
    		if ("matchTrigger" in $$props) $$invalidate(19, matchTrigger = $$props.matchTrigger);
    	};

    	$$self.$capture_state = () => ({
    		changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		highlightedIndex,
    		menuId,
    		menuItemClick,
    		menuRef,
    		overlayClick,
    		style,
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		slide,
    		disabled,
    		id,
    		items,
    		width,
    		selectedIndex,
    		size,
    		value,
    		blankSlate,
    		labelKey,
    		idKey,
    		showMenu,
    		align,
    		trigger,
    		matchTrigger
    	});

    	$$self.$inject_state = $$props => {
    		if ("changeIndex" in $$props) changeIndex = $$props.changeIndex;
    		if ("checkTrigger" in $$props) $$invalidate(21, checkTrigger = $$props.checkTrigger);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("hasfocus" in $$props) hasfocus = $$props.hasfocus;
    		if ("highlightedIndex" in $$props) $$invalidate(7, highlightedIndex = $$props.highlightedIndex);
    		if ("menuId" in $$props) $$invalidate(8, menuId = $$props.menuId);
    		if ("menuItemClick" in $$props) $$invalidate(9, menuItemClick = $$props.menuItemClick);
    		if ("menuRef" in $$props) $$invalidate(10, menuRef = $$props.menuRef);
    		if ("overlayClick" in $$props) $$invalidate(11, overlayClick = $$props.overlayClick);
    		if ("style" in $$props) $$invalidate(12, style = $$props.style);
    		if ("disabled" in $$props) $$invalidate(13, disabled = $$props.disabled);
    		if ("id" in $$props) $$invalidate(14, id = $$props.id);
    		if ("items" in $$props) $$invalidate(1, items = $$props.items);
    		if ("width" in $$props) $$invalidate(15, width = $$props.width);
    		if ("selectedIndex" in $$props) $$invalidate(2, selectedIndex = $$props.selectedIndex);
    		if ("size" in $$props) $$invalidate(16, size = $$props.size);
    		if ("value" in $$props) $$invalidate(17, value = $$props.value);
    		if ("blankSlate" in $$props) $$invalidate(3, blankSlate = $$props.blankSlate);
    		if ("labelKey" in $$props) $$invalidate(4, labelKey = $$props.labelKey);
    		if ("idKey" in $$props) $$invalidate(5, idKey = $$props.idKey);
    		if ("showMenu" in $$props) $$invalidate(0, showMenu = $$props.showMenu);
    		if ("align" in $$props) $$invalidate(6, align = $$props.align);
    		if ("trigger" in $$props) $$invalidate(18, trigger = $$props.trigger);
    		if ("matchTrigger" in $$props) $$invalidate(19, matchTrigger = $$props.matchTrigger);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*checkTrigger, trigger*/ 2359296) {
    			 checkTrigger(trigger);
    		}
    	};

    	return [
    		showMenu,
    		items,
    		selectedIndex,
    		blankSlate,
    		labelKey,
    		idKey,
    		align,
    		highlightedIndex,
    		menuId,
    		menuItemClick,
    		menuRef,
    		overlayClick,
    		style,
    		disabled,
    		id,
    		width,
    		size,
    		value,
    		trigger,
    		matchTrigger,
    		changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		div_binding
    	];
    }

    class SortMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$W, create_fragment$W, safe_not_equal, {
    			disabled: 13,
    			id: 14,
    			items: 1,
    			width: 15,
    			selectedIndex: 2,
    			size: 16,
    			value: 17,
    			blankSlate: 3,
    			labelKey: 4,
    			idKey: 5,
    			showMenu: 0,
    			align: 6,
    			trigger: 18,
    			matchTrigger: 19
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SortMenu",
    			options,
    			id: create_fragment$W.name
    		});
    	}

    	get disabled() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedIndex() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedIndex(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blankSlate() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blankSlate(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelKey() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelKey(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get idKey() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set idKey(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showMenu() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showMenu(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trigger() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trigger(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get matchTrigger() {
    		throw new Error("<SortMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set matchTrigger(value) {
    		throw new Error("<SortMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Form\Checkbox\Checkbox.svelte generated by Svelte v3.22.2 */
    const file$R = "src\\svelte\\components\\Form\\Checkbox\\Checkbox.svelte";

    // (64:8) {:else}
    function create_else_block$g(ctx) {
    	let path0;
    	let path0_transition;
    	let path1;
    	let path1_transition;
    	let current;

    	const block = {
    		c: function create() {
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$R, 64, 8, 1320);
    			attr_dev(path1, "d", "M19 5v14H5V5h14m2-2H3v18h18V3z");
    			add_location(path1, file$R, 64, 88, 1400);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path0, anchor);
    			insert_dev(target, path1, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!path0_transition) path0_transition = create_bidirectional_transition(path0, fade, { duration: /*duration*/ ctx[3] }, true);
    				path0_transition.run(1);
    			});

    			add_render_callback(() => {
    				if (!path1_transition) path1_transition = create_bidirectional_transition(path1, fade, { duration: /*duration*/ ctx[3] }, true);
    				path1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!path0_transition) path0_transition = create_bidirectional_transition(path0, fade, { duration: /*duration*/ ctx[3] }, false);
    			path0_transition.run(0);
    			if (!path1_transition) path1_transition = create_bidirectional_transition(path1, fade, { duration: /*duration*/ ctx[3] }, false);
    			path1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path0);
    			if (detaching && path0_transition) path0_transition.end();
    			if (detaching) detach_dev(path1);
    			if (detaching && path1_transition) path1_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(64:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (62:8) {#if checked}
    function create_if_block_1$e(ctx) {
    	let path0;
    	let path0_transition;
    	let path1;
    	let path1_transition;
    	let current;

    	const block = {
    		c: function create() {
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$R, 62, 8, 1093);
    			attr_dev(path1, "d", "M21 3H3v18h18V3zM10 17l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z");
    			add_location(path1, file$R, 62, 88, 1173);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path0, anchor);
    			insert_dev(target, path1, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!path0_transition) path0_transition = create_bidirectional_transition(path0, fade, { duration: /*duration*/ ctx[3] }, true);
    				path0_transition.run(1);
    			});

    			add_render_callback(() => {
    				if (!path1_transition) path1_transition = create_bidirectional_transition(path1, fade, { duration: /*duration*/ ctx[3] }, true);
    				path1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!path0_transition) path0_transition = create_bidirectional_transition(path0, fade, { duration: /*duration*/ ctx[3] }, false);
    			path0_transition.run(0);
    			if (!path1_transition) path1_transition = create_bidirectional_transition(path1, fade, { duration: /*duration*/ ctx[3] }, false);
    			path1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path0);
    			if (detaching && path0_transition) path0_transition.end();
    			if (detaching) detach_dev(path1);
    			if (detaching && path1_transition) path1_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(62:8) {#if checked}",
    		ctx
    	});

    	return block;
    }

    // (69:2) {#if label.length > 0}
    function create_if_block$t(ctx) {
    	let label_1;
    	let t;
    	let dispose;

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			t = text(/*label*/ ctx[2]);
    			attr_dev(label_1, "class", "svelte-1fu4eya");
    			add_location(label_1, file$R, 69, 2, 1555);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, t);
    			if (remount) dispose();

    			dispose = listen_dev(
    				label_1,
    				"click",
    				function () {
    					if (is_function(/*toggle*/ ctx[4])) /*toggle*/ ctx[4].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*label*/ 4) set_data_dev(t, /*label*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(69:2) {#if label.length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$X(ctx) {
    	let div;
    	let button;
    	let svg;
    	let current_block_type_index;
    	let if_block0;
    	let t;
    	let current;
    	let dispose;
    	const if_block_creators = [create_if_block_1$e, create_else_block$g];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*checked*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*label*/ ctx[2].length > 0 && create_if_block$t(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "class", "svelte-1fu4eya");
    			add_location(svg, file$R, 60, 6, 976);
    			attr_dev(button, "icon", "");
    			attr_dev(button, "type", "button");
    			attr_dev(button, "checked", /*checked*/ ctx[0]);
    			attr_dev(button, "class", "svelte-1fu4eya");
    			add_location(button, file$R, 59, 2, 913);
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			attr_dev(div, "class", "svelte-1fu4eya");
    			add_location(div, file$R, 58, 0, 896);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, svg);
    			if_blocks[current_block_type_index].m(svg, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*toggle*/ ctx[4])) /*toggle*/ ctx[4].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(svg, null);
    			}

    			if (!current || dirty & /*checked*/ 1) {
    				attr_dev(button, "checked", /*checked*/ ctx[0]);
    			}

    			if (/*label*/ ctx[2].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$t(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	var dispatch, duration, toggle;
    	var { style = void 0 } = $$props;
    	var { checked = false } = $$props;
    	var { label = void 0 } = $$props;
    	var { key = void 0 } = $$props;
    	dispatch = createEventDispatcher();
    	duration = 250;

    	toggle = function (e) {
    		$$invalidate(0, checked = !checked);
    		return dispatch("change", { label, key, checked });
    	};

    	const writable_props = ["style", "checked", "label", "key"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Checkbox> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Checkbox", $$slots, []);

    	$$self.$set = $$props => {
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("checked" in $$props) $$invalidate(0, checked = $$props.checked);
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    		if ("key" in $$props) $$invalidate(5, key = $$props.key);
    	};

    	$$self.$capture_state = () => ({
    		dispatch,
    		duration,
    		toggle,
    		fade,
    		fly,
    		slide,
    		scale,
    		draw,
    		createEventDispatcher,
    		onMount,
    		sineInOut,
    		style,
    		checked,
    		label,
    		key
    	});

    	$$self.$inject_state = $$props => {
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("duration" in $$props) $$invalidate(3, duration = $$props.duration);
    		if ("toggle" in $$props) $$invalidate(4, toggle = $$props.toggle);
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    		if ("checked" in $$props) $$invalidate(0, checked = $$props.checked);
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    		if ("key" in $$props) $$invalidate(5, key = $$props.key);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [checked, style, label, duration, toggle, key];
    }

    class Checkbox extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, { style: 1, checked: 0, label: 2, key: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checkbox",
    			options,
    			id: create_fragment$X.name
    		});
    	}

    	get style() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get checked() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set checked(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Overlay\Menu\FilterMenu.svelte generated by Svelte v3.22.2 */

    const { console: console_1$r } = globals;
    const file$S = "src\\svelte\\components\\Overlay\\Menu\\FilterMenu.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	child_ctx[27] = list;
    	child_ctx[28] = i;
    	return child_ctx;
    }

    // (128:0) {#if showMenu}
    function create_if_block$u(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let div_transition;
    	let current;
    	let each_value = /*items*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*item*/ ctx[26].id || /*i*/ ctx[28];
    	validate_each_keys(ctx, each_value, get_each_context$c, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$c(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$c(key, child_ctx));
    	}

    	let if_block = /*items*/ ctx[0].length == 0 && create_if_block_1$f(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "menu", "");
    			attr_dev(div, "id", /*menuId*/ ctx[6]);
    			attr_dev(div, "style", /*style*/ ctx[9]);
    			attr_dev(div, "align", /*align*/ ctx[4]);
    			attr_dev(div, "class", "svelte-ul37dc");
    			add_location(div, file$S, 128, 2, 2811);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			/*div_binding*/ ctx[25](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*items, labelKey, changeFilter*/ 41) {
    				const each_value = /*items*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$c, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$c, t, get_each_context$c);
    				check_outros();
    			}

    			if (/*items*/ ctx[0].length == 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$f(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty & /*menuId*/ 64) {
    				attr_dev(div, "id", /*menuId*/ ctx[6]);
    			}

    			if (!current || dirty & /*style*/ 512) {
    				attr_dev(div, "style", /*style*/ ctx[9]);
    			}

    			if (!current || dirty & /*align*/ 16) {
    				attr_dev(div, "align", /*align*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 75 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 75 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (if_block) if_block.d();
    			/*div_binding*/ ctx[25](null);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(128:0) {#if showMenu}",
    		ctx
    	});

    	return block;
    }

    // (130:4) {#each items as item, i (item.id || i)}
    function create_each_block$c(key_1, ctx) {
    	let first;
    	let updating_checked;
    	let current;

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[24].call(null, value, /*item*/ ctx[26]);
    	}

    	let checkbox_props = {
    		label: /*item*/ ctx[26][/*labelKey*/ ctx[3]]
    	};

    	if (/*item*/ ctx[26].selected !== void 0) {
    		checkbox_props.checked = /*item*/ ctx[26].selected;
    	}

    	const checkbox = new Checkbox({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

    	checkbox.$on("change", function () {
    		if (is_function(/*changeFilter*/ ctx[5])) /*changeFilter*/ ctx[5].apply(this, arguments);
    	});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(checkbox.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const checkbox_changes = {};
    			if (dirty & /*items, labelKey*/ 9) checkbox_changes.label = /*item*/ ctx[26][/*labelKey*/ ctx[3]];

    			if (!updating_checked && dirty & /*items*/ 1) {
    				updating_checked = true;
    				checkbox_changes.checked = /*item*/ ctx[26].selected;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(checkbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(130:4) {#each items as item, i (item.id || i)}",
    		ctx
    	});

    	return block;
    }

    // (133:4) {#if items.length == 0}
    function create_if_block_1$f(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			attr_dev(button, "menu-item", "");
    			attr_dev(button, "class", "svelte-ul37dc");
    			add_location(button, file$S, 133, 6, 3091);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			button.innerHTML = /*blankSlate*/ ctx[2];
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*blankSlate*/ 4) button.innerHTML = /*blankSlate*/ ctx[2];		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(133:4) {#if items.length == 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Y(ctx) {
    	let div;
    	let t;
    	let if_block_anchor;
    	let current;
    	let dispose;
    	let if_block = /*showMenu*/ ctx[1] && create_if_block$u(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(div, "type", "overlay");
    			attr_dev(div, "clear", "");
    			attr_dev(div, "open", /*showMenu*/ ctx[1]);
    			add_location(div, file$S, 126, 0, 2726);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div,
    				"click",
    				function () {
    					if (is_function(/*overlayClick*/ ctx[8])) /*overlayClick*/ ctx[8].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (!current || dirty & /*showMenu*/ 2) {
    				attr_dev(div, "open", /*showMenu*/ ctx[1]);
    			}

    			if (/*showMenu*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showMenu*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$u(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	var changeFilter,
    		changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		highlightedIndex,
    		menuId,
    		menuRef,
    		overlayClick,
    		style;

    	dispatch = createEventDispatcher();
    	var { disabled = false } = $$props;
    	var { id = uuid() } = $$props;
    	var { items = [] } = $$props;
    	var { width = "200px" } = $$props;
    	var { selectedIndex = -1 } = $$props;
    	var { size = void 0 } = $$props;
    	var { value = "" } = $$props;
    	var { blankSlate = "" } = $$props;
    	var { labelKey = "label" } = $$props;
    	var { idKey = "id" } = $$props;
    	var { showMenu = false } = $$props;
    	var { align = "left" } = $$props;
    	var { trigger = void 0 } = $$props;
    	var { matchTrigger = false } = $$props;
    	style = void 0;
    	menuRef = void 0;
    	hasfocus = false;
    	highlightedIndex = -1;

    	changeIndex = function (direction) {
    		var index;
    		index = highlightedIndex + direction;

    		if (index < 0) {
    			index = items.length - 1;
    		} else if (index >= items.length) {
    			index = 0;
    		}

    		return highlightedIndex = index;
    	};

    	menuId = uuid();

    	onMount(function () {
    		return console.log("parent, mounted");
    	});

    	checkTrigger = function (i) {
    		var right, triggerContainerWidth, triggerCoords;

    		if (i != null) {
    			if (matchTrigger) {
    				$$invalidate(9, style = `width: ${width};top: ${i.clientHeight + 4}px; width: ${i.clientWidth + 2}px`);
    			} else {
    				if (align === "left") {
    					$$invalidate(9, style = `width: ${width};top: ${i.offsetParent.clientHeight + 4}px;`);
    				} else {
    					triggerContainerWidth = i.offsetParent.clientWidth;
    					triggerCoords = i.getBoundingClientRect();
    					right = triggerContainerWidth - triggerCoords.width;
    					$$invalidate(9, style = `width: ${width};top: ${i.offsetParent.clientHeight + 4}px; right: ${right}px`);
    				}
    			}
    		}

    		console.log("trigger");
    		console.log(i);
    		console.log("style");
    		return console.log(style);
    	};

    	changeFilter = function (item) {
    		return dispatch("click", items);
    	};

    	overlayClick = function () {
    		return $$invalidate(1, showMenu = false);
    	};

    	const writable_props = [
    		"disabled",
    		"id",
    		"items",
    		"width",
    		"selectedIndex",
    		"size",
    		"value",
    		"blankSlate",
    		"labelKey",
    		"idKey",
    		"showMenu",
    		"align",
    		"trigger",
    		"matchTrigger"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$r.warn(`<FilterMenu> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FilterMenu", $$slots, []);

    	function checkbox_checked_binding(value, item) {
    		item.selected = value;
    		$$invalidate(0, items);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(7, menuRef = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("disabled" in $$props) $$invalidate(10, disabled = $$props.disabled);
    		if ("id" in $$props) $$invalidate(11, id = $$props.id);
    		if ("items" in $$props) $$invalidate(0, items = $$props.items);
    		if ("width" in $$props) $$invalidate(12, width = $$props.width);
    		if ("selectedIndex" in $$props) $$invalidate(13, selectedIndex = $$props.selectedIndex);
    		if ("size" in $$props) $$invalidate(14, size = $$props.size);
    		if ("value" in $$props) $$invalidate(15, value = $$props.value);
    		if ("blankSlate" in $$props) $$invalidate(2, blankSlate = $$props.blankSlate);
    		if ("labelKey" in $$props) $$invalidate(3, labelKey = $$props.labelKey);
    		if ("idKey" in $$props) $$invalidate(16, idKey = $$props.idKey);
    		if ("showMenu" in $$props) $$invalidate(1, showMenu = $$props.showMenu);
    		if ("align" in $$props) $$invalidate(4, align = $$props.align);
    		if ("trigger" in $$props) $$invalidate(17, trigger = $$props.trigger);
    		if ("matchTrigger" in $$props) $$invalidate(18, matchTrigger = $$props.matchTrigger);
    	};

    	$$self.$capture_state = () => ({
    		changeFilter,
    		changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		highlightedIndex,
    		menuId,
    		menuRef,
    		overlayClick,
    		style,
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		slide,
    		Checkbox,
    		disabled,
    		id,
    		items,
    		width,
    		selectedIndex,
    		size,
    		value,
    		blankSlate,
    		labelKey,
    		idKey,
    		showMenu,
    		align,
    		trigger,
    		matchTrigger
    	});

    	$$self.$inject_state = $$props => {
    		if ("changeFilter" in $$props) $$invalidate(5, changeFilter = $$props.changeFilter);
    		if ("changeIndex" in $$props) changeIndex = $$props.changeIndex;
    		if ("checkTrigger" in $$props) $$invalidate(20, checkTrigger = $$props.checkTrigger);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("hasfocus" in $$props) hasfocus = $$props.hasfocus;
    		if ("highlightedIndex" in $$props) highlightedIndex = $$props.highlightedIndex;
    		if ("menuId" in $$props) $$invalidate(6, menuId = $$props.menuId);
    		if ("menuRef" in $$props) $$invalidate(7, menuRef = $$props.menuRef);
    		if ("overlayClick" in $$props) $$invalidate(8, overlayClick = $$props.overlayClick);
    		if ("style" in $$props) $$invalidate(9, style = $$props.style);
    		if ("disabled" in $$props) $$invalidate(10, disabled = $$props.disabled);
    		if ("id" in $$props) $$invalidate(11, id = $$props.id);
    		if ("items" in $$props) $$invalidate(0, items = $$props.items);
    		if ("width" in $$props) $$invalidate(12, width = $$props.width);
    		if ("selectedIndex" in $$props) $$invalidate(13, selectedIndex = $$props.selectedIndex);
    		if ("size" in $$props) $$invalidate(14, size = $$props.size);
    		if ("value" in $$props) $$invalidate(15, value = $$props.value);
    		if ("blankSlate" in $$props) $$invalidate(2, blankSlate = $$props.blankSlate);
    		if ("labelKey" in $$props) $$invalidate(3, labelKey = $$props.labelKey);
    		if ("idKey" in $$props) $$invalidate(16, idKey = $$props.idKey);
    		if ("showMenu" in $$props) $$invalidate(1, showMenu = $$props.showMenu);
    		if ("align" in $$props) $$invalidate(4, align = $$props.align);
    		if ("trigger" in $$props) $$invalidate(17, trigger = $$props.trigger);
    		if ("matchTrigger" in $$props) $$invalidate(18, matchTrigger = $$props.matchTrigger);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*checkTrigger, trigger*/ 1179648) {
    			 checkTrigger(trigger);
    		}
    	};

    	return [
    		items,
    		showMenu,
    		blankSlate,
    		labelKey,
    		align,
    		changeFilter,
    		menuId,
    		menuRef,
    		overlayClick,
    		style,
    		disabled,
    		id,
    		width,
    		selectedIndex,
    		size,
    		value,
    		idKey,
    		trigger,
    		matchTrigger,
    		changeIndex,
    		checkTrigger,
    		dispatch,
    		hasfocus,
    		highlightedIndex,
    		checkbox_checked_binding,
    		div_binding
    	];
    }

    class FilterMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {
    			disabled: 10,
    			id: 11,
    			items: 0,
    			width: 12,
    			selectedIndex: 13,
    			size: 14,
    			value: 15,
    			blankSlate: 2,
    			labelKey: 3,
    			idKey: 16,
    			showMenu: 1,
    			align: 4,
    			trigger: 17,
    			matchTrigger: 18
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FilterMenu",
    			options,
    			id: create_fragment$Y.name
    		});
    	}

    	get disabled() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedIndex() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedIndex(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blankSlate() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blankSlate(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelKey() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelKey(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get idKey() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set idKey(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showMenu() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showMenu(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trigger() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trigger(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get matchTrigger() {
    		throw new Error("<FilterMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set matchTrigger(value) {
    		throw new Error("<FilterMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Layout\TopSplit.svelte generated by Svelte v3.22.2 */

    const file$T = "src\\svelte\\components\\Layout\\TopSplit.svelte";
    const get_footer_slot_changes$1 = dirty => ({});
    const get_footer_slot_context$1 = ctx => ({});
    const get_header_slot_changes$2 = dirty => ({});
    const get_header_slot_context$2 = ctx => ({});

    // (28:2) {#if header}
    function create_if_block_1$g(ctx) {
    	let header_1;
    	let current;
    	const header_slot_template = /*$$slots*/ ctx[7].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[6], get_header_slot_context$2);

    	const block = {
    		c: function create() {
    			header_1 = element("header");
    			if (header_slot) header_slot.c();
    			set_style(header_1, "height", /*headerSize*/ ctx[0]);
    			attr_dev(header_1, "flex", "initial");
    			attr_dev(header_1, "class", "svelte-1pcd80f");
    			add_location(header_1, file$T, 28, 2, 541);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header_1, anchor);

    			if (header_slot) {
    				header_slot.m(header_1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (header_slot) {
    				if (header_slot.p && dirty & /*$$scope*/ 64) {
    					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[6], get_header_slot_context$2), get_slot_changes(header_slot_template, /*$$scope*/ ctx[6], dirty, get_header_slot_changes$2));
    				}
    			}

    			if (!current || dirty & /*headerSize*/ 1) {
    				set_style(header_1, "height", /*headerSize*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header_1);
    			if (header_slot) header_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(28:2) {#if header}",
    		ctx
    	});

    	return block;
    }

    // (32:2) {#if footer}
    function create_if_block$v(ctx) {
    	let footer_1;
    	let current;
    	const footer_slot_template = /*$$slots*/ ctx[7].footer;
    	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[6], get_footer_slot_context$1);

    	const block = {
    		c: function create() {
    			footer_1 = element("footer");
    			if (footer_slot) footer_slot.c();
    			set_style(footer_1, "height", /*footerSize*/ ctx[1]);
    			attr_dev(footer_1, "flex", "initial");
    			attr_dev(footer_1, "class", "svelte-1pcd80f");
    			add_location(footer_1, file$T, 32, 2, 708);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer_1, anchor);

    			if (footer_slot) {
    				footer_slot.m(footer_1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (footer_slot) {
    				if (footer_slot.p && dirty & /*$$scope*/ 64) {
    					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[6], get_footer_slot_context$1), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[6], dirty, get_footer_slot_changes$1));
    				}
    			}

    			if (!current || dirty & /*footerSize*/ 2) {
    				set_style(footer_1, "height", /*footerSize*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer_1);
    			if (footer_slot) footer_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(32:2) {#if footer}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Z(ctx) {
    	let main;
    	let t0;
    	let section;
    	let t1;
    	let current;
    	let if_block0 = /*header*/ ctx[2] && create_if_block_1$g(ctx);
    	const default_slot_template = /*$$slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
    	let if_block1 = /*footer*/ ctx[3] && create_if_block$v(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			section = element("section");
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(section, "flex", "");
    			attr_dev(section, "style", /*contentStyle*/ ctx[4]);
    			attr_dev(section, "class", "svelte-1pcd80f");
    			add_location(section, file$T, 30, 2, 636);
    			attr_dev(main, "layout", "column");
    			attr_dev(main, "class", "svelte-1pcd80f");
    			add_location(main, file$T, 26, 0, 499);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			if (if_block0) if_block0.m(main, null);
    			append_dev(main, t0);
    			append_dev(main, section);

    			if (default_slot) {
    				default_slot.m(section, null);
    			}

    			append_dev(main, t1);
    			if (if_block1) if_block1.m(main, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*header*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*header*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$g(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(main, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 64) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[6], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null));
    				}
    			}

    			if (!current || dirty & /*contentStyle*/ 16) {
    				attr_dev(section, "style", /*contentStyle*/ ctx[4]);
    			}

    			if (/*footer*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*footer*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$v(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(main, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(default_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(default_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (if_block0) if_block0.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	var { headerSize = "100px" } = $$props;
    	var { footerSize = "100px" } = $$props;
    	var { contentScrollable = true } = $$props;
    	var { header = true } = $$props;
    	var { footer = true } = $$props;
    	const writable_props = ["headerSize", "footerSize", "contentScrollable", "header", "footer"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TopSplit> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TopSplit", $$slots, ['header','default','footer']);

    	$$self.$set = $$props => {
    		if ("headerSize" in $$props) $$invalidate(0, headerSize = $$props.headerSize);
    		if ("footerSize" in $$props) $$invalidate(1, footerSize = $$props.footerSize);
    		if ("contentScrollable" in $$props) $$invalidate(5, contentScrollable = $$props.contentScrollable);
    		if ("header" in $$props) $$invalidate(2, header = $$props.header);
    		if ("footer" in $$props) $$invalidate(3, footer = $$props.footer);
    		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		headerSize,
    		footerSize,
    		contentScrollable,
    		header,
    		footer,
    		contentStyle
    	});

    	$$self.$inject_state = $$props => {
    		if ("headerSize" in $$props) $$invalidate(0, headerSize = $$props.headerSize);
    		if ("footerSize" in $$props) $$invalidate(1, footerSize = $$props.footerSize);
    		if ("contentScrollable" in $$props) $$invalidate(5, contentScrollable = $$props.contentScrollable);
    		if ("header" in $$props) $$invalidate(2, header = $$props.header);
    		if ("footer" in $$props) $$invalidate(3, footer = $$props.footer);
    		if ("contentStyle" in $$props) $$invalidate(4, contentStyle = $$props.contentStyle);
    	};

    	let contentStyle;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*contentScrollable*/ 32) {
    			 $$invalidate(4, contentStyle = contentScrollable
    			? "overflow-y: scroll"
    			: "overflow-y: hidden");
    		}
    	};

    	return [
    		headerSize,
    		footerSize,
    		header,
    		footer,
    		contentStyle,
    		contentScrollable,
    		$$scope,
    		$$slots
    	];
    }

    class TopSplit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {
    			headerSize: 0,
    			footerSize: 1,
    			contentScrollable: 5,
    			header: 2,
    			footer: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TopSplit",
    			options,
    			id: create_fragment$Z.name
    		});
    	}

    	get headerSize() {
    		throw new Error("<TopSplit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set headerSize(value) {
    		throw new Error("<TopSplit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get footerSize() {
    		throw new Error("<TopSplit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set footerSize(value) {
    		throw new Error("<TopSplit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contentScrollable() {
    		throw new Error("<TopSplit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contentScrollable(value) {
    		throw new Error("<TopSplit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get header() {
    		throw new Error("<TopSplit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set header(value) {
    		throw new Error("<TopSplit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get footer() {
    		throw new Error("<TopSplit>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set footer(value) {
    		throw new Error("<TopSplit>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Lists\FilteredList.svelte generated by Svelte v3.22.2 */

    const { console: console_1$s } = globals;
    const file$U = "src\\svelte\\components\\Lists\\FilteredList.svelte";
    const get_blank_slate_slot_changes = dirty => ({ item: dirty[0] & /*filteredList*/ 65536 });

    const get_blank_slate_slot_context = ctx => ({
    	item: /*item*/ ctx[35],
    	index: /*index*/ ctx[37]
    });

    const get_bottom_content_slot_changes = dirty => ({ item: dirty[0] & /*filteredList*/ 65536 });

    const get_bottom_content_slot_context = ctx => ({
    	item: /*item*/ ctx[35],
    	index: /*index*/ ctx[37]
    });

    const get_default_slot_changes$3 = dirty => ({ item: dirty[0] & /*filteredList*/ 65536 });

    const get_default_slot_context$3 = ctx => ({
    	item: /*item*/ ctx[35],
    	index: /*index*/ ctx[37]
    });

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i];
    	child_ctx[37] = i;
    	return child_ctx;
    }

    // (141:4) {#if sortable}
    function create_if_block_3$5(ctx) {
    	let div;
    	let button;
    	let t;
    	let updating_showMenu;
    	let updating_trigger;
    	let current;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*currently_ascending*/ ctx[14]) return create_if_block_4$2;
    		return create_else_block_1$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	function sortmenu_showMenu_binding(value) {
    		/*sortmenu_showMenu_binding*/ ctx[30].call(null, value);
    	}

    	function sortmenu_trigger_binding(value) {
    		/*sortmenu_trigger_binding*/ ctx[31].call(null, value);
    	}

    	let sortmenu_props = {
    		items: /*sortOptions*/ ctx[1],
    		align: "right"
    	};

    	if (/*showSortMenu*/ ctx[10] !== void 0) {
    		sortmenu_props.showMenu = /*showSortMenu*/ ctx[10];
    	}

    	if (/*sortMenuButtonRef*/ ctx[12] !== void 0) {
    		sortmenu_props.trigger = /*sortMenuButtonRef*/ ctx[12];
    	}

    	const sortmenu = new SortMenu({ props: sortmenu_props, $$inline: true });
    	binding_callbacks.push(() => bind(sortmenu, "showMenu", sortmenu_showMenu_binding));
    	binding_callbacks.push(() => bind(sortmenu, "trigger", sortmenu_trigger_binding));

    	sortmenu.$on("click", function () {
    		if (is_function(/*sortMenuClick*/ ctx[13])) /*sortMenuClick*/ ctx[13].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			if_block.c();
    			t = space();
    			create_component(sortmenu.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$U, 142, 6, 2706);
    			attr_dev(div, "flex", "initial");
    			add_location(div, file$U, 141, 4, 2679);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			if_block.m(button, null);
    			/*button_binding*/ ctx[29](button);
    			append_dev(div, t);
    			mount_component(sortmenu, div, null);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*sortMenu*/ ctx[11])) /*sortMenu*/ ctx[11].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(button, null);
    				}
    			}

    			const sortmenu_changes = {};
    			if (dirty[0] & /*sortOptions*/ 2) sortmenu_changes.items = /*sortOptions*/ ctx[1];

    			if (!updating_showMenu && dirty[0] & /*showSortMenu*/ 1024) {
    				updating_showMenu = true;
    				sortmenu_changes.showMenu = /*showSortMenu*/ ctx[10];
    				add_flush_callback(() => updating_showMenu = false);
    			}

    			if (!updating_trigger && dirty[0] & /*sortMenuButtonRef*/ 4096) {
    				updating_trigger = true;
    				sortmenu_changes.trigger = /*sortMenuButtonRef*/ ctx[12];
    				add_flush_callback(() => updating_trigger = false);
    			}

    			sortmenu.$set(sortmenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sortmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sortmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    			/*button_binding*/ ctx[29](null);
    			destroy_component(sortmenu);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(141:4) {#if sortable}",
    		ctx
    	});

    	return block;
    }

    // (146:8) {:else}
    function create_else_block_1$5(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$U, 146, 93, 3137);
    			attr_dev(path1, "d", "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z");
    			add_location(path1, file$U, 146, 132, 3176);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$U, 146, 10, 3054);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$5.name,
    		type: "else",
    		source: "(146:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (144:8) {#if currently_ascending}
    function create_if_block_4$2(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$U, 144, 93, 2911);
    			attr_dev(path1, "d", "M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z");
    			add_location(path1, file$U, 144, 132, 2950);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$U, 144, 10, 2828);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(144:8) {#if currently_ascending}",
    		ctx
    	});

    	return block;
    }

    // (153:4) {#if filterable}
    function create_if_block_1$h(ctx) {
    	let div;
    	let button;
    	let t;
    	let updating_showMenu;
    	let updating_trigger;
    	let current;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*currently_filtering*/ ctx[15]) return create_if_block_2$6;
    		return create_else_block$h;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	function filtermenu_showMenu_binding(value) {
    		/*filtermenu_showMenu_binding*/ ctx[33].call(null, value);
    	}

    	function filtermenu_trigger_binding(value) {
    		/*filtermenu_trigger_binding*/ ctx[34].call(null, value);
    	}

    	let filtermenu_props = {
    		items: /*filterOptions*/ ctx[2],
    		align: "right"
    	};

    	if (/*showFilterMenu*/ ctx[9] !== void 0) {
    		filtermenu_props.showMenu = /*showFilterMenu*/ ctx[9];
    	}

    	if (/*filterMenuButtonRef*/ ctx[7] !== void 0) {
    		filtermenu_props.trigger = /*filterMenuButtonRef*/ ctx[7];
    	}

    	const filtermenu = new FilterMenu({ props: filtermenu_props, $$inline: true });
    	binding_callbacks.push(() => bind(filtermenu, "showMenu", filtermenu_showMenu_binding));
    	binding_callbacks.push(() => bind(filtermenu, "trigger", filtermenu_trigger_binding));

    	filtermenu.$on("click", function () {
    		if (is_function(/*filterMenuClick*/ ctx[8])) /*filterMenuClick*/ ctx[8].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			if_block.c();
    			t = space();
    			create_component(filtermenu.$$.fragment);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$U, 154, 6, 3499);
    			attr_dev(div, "flex", "initial");
    			add_location(div, file$U, 153, 4, 3472);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			if_block.m(button, null);
    			/*button_binding_1*/ ctx[32](button);
    			append_dev(div, t);
    			mount_component(filtermenu, div, null);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*filterMenu*/ ctx[6])) /*filterMenu*/ ctx[6].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(button, null);
    				}
    			}

    			const filtermenu_changes = {};
    			if (dirty[0] & /*filterOptions*/ 4) filtermenu_changes.items = /*filterOptions*/ ctx[2];

    			if (!updating_showMenu && dirty[0] & /*showFilterMenu*/ 512) {
    				updating_showMenu = true;
    				filtermenu_changes.showMenu = /*showFilterMenu*/ ctx[9];
    				add_flush_callback(() => updating_showMenu = false);
    			}

    			if (!updating_trigger && dirty[0] & /*filterMenuButtonRef*/ 128) {
    				updating_trigger = true;
    				filtermenu_changes.trigger = /*filterMenuButtonRef*/ ctx[7];
    				add_flush_callback(() => updating_trigger = false);
    			}

    			filtermenu.$set(filtermenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(filtermenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(filtermenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    			/*button_binding_1*/ ctx[32](null);
    			destroy_component(filtermenu);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(153:4) {#if filterable}",
    		ctx
    	});

    	return block;
    }

    // (158:8) {:else}
    function create_else_block$h(ctx) {
    	let svg;
    	let title;
    	let t;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			title = svg_element("title");
    			t = text("ionicons-v5-n");
    			path = svg_element("path");
    			add_location(title, file$U, 158, 95, 3896);
    			attr_dev(path, "d", "M35.4,87.12,204.05,283.56A16.07,16.07,0,0,1,208,294V413.32a7.93,7.93,0,0,0,5.39,7.59l80.15,26.67A7.94,7.94,0,0,0,304,440V294A16.07,16.07,0,0,1,308,283.56L476.6,87.12A14,14,0,0,0,466,64H46.05A14,14,0,0,0,35.4,87.12Z");
    			set_style(path, "fill", "none");
    			set_style(path, "stroke", "#000");
    			set_style(path, "stroke-linecap", "round");
    			set_style(path, "stroke-linejoin", "round");
    			set_style(path, "stroke-width", "32px");
    			add_location(path, file$U, 158, 123, 3924);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 512 512");
    			add_location(svg, file$U, 158, 10, 3811);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, title);
    			append_dev(title, t);
    			append_dev(svg, path);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(158:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (156:8) {#if currently_filtering}
    function create_if_block_2$6(ctx) {
    	let svg;
    	let polygon;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			polygon = svg_element("polygon");
    			attr_dev(polygon, "points", "0 48 192 288 192 416 320 464 320 288 512 48 0 48");
    			add_location(polygon, file$U, 156, 95, 3710);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 512 512");
    			add_location(svg, file$U, 156, 10, 3625);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, polygon);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(156:8) {#if currently_filtering}",
    		ctx
    	});

    	return block;
    }

    // (167:4) {#each (filteredList) as item, index}
    function create_each_block$d(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[27].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[26], get_default_slot_context$3);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope, filteredList*/ 67174400) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[26], get_default_slot_context$3), get_slot_changes(default_slot_template, /*$$scope*/ ctx[26], dirty, get_default_slot_changes$3));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(167:4) {#each (filteredList) as item, index}",
    		ctx
    	});

    	return block;
    }

    // (171:4) {#if filteredList.length == 0}
    function create_if_block$w(ctx) {
    	let current;
    	const blank_slate_slot_template = /*$$slots*/ ctx[27]["blank-slate"];
    	const blank_slate_slot = create_slot(blank_slate_slot_template, ctx, /*$$scope*/ ctx[26], get_blank_slate_slot_context);

    	const block = {
    		c: function create() {
    			if (blank_slate_slot) blank_slate_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (blank_slate_slot) {
    				blank_slate_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (blank_slate_slot) {
    				if (blank_slate_slot.p && dirty[0] & /*$$scope, filteredList*/ 67174400) {
    					blank_slate_slot.p(get_slot_context(blank_slate_slot_template, ctx, /*$$scope*/ ctx[26], get_blank_slate_slot_context), get_slot_changes(blank_slate_slot_template, /*$$scope*/ ctx[26], dirty, get_blank_slate_slot_changes));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(blank_slate_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(blank_slate_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (blank_slate_slot) blank_slate_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(171:4) {#if filteredList.length == 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$_(ctx) {
    	let div1;
    	let div0;
    	let updating_value;
    	let t0;
    	let t1;
    	let t2;
    	let div2;
    	let t3;
    	let t4;
    	let div2_id_value;
    	let current;

    	function searchinput_value_binding(value) {
    		/*searchinput_value_binding*/ ctx[28].call(null, value);
    	}

    	let searchinput_props = {};

    	if (/*searchValue*/ ctx[0] !== void 0) {
    		searchinput_props.value = /*searchValue*/ ctx[0];
    	}

    	const searchinput = new SearchInput({ props: searchinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(searchinput, "value", searchinput_value_binding));
    	let if_block0 = /*sortable*/ ctx[4] && create_if_block_3$5(ctx);
    	let if_block1 = /*filterable*/ ctx[5] && create_if_block_1$h(ctx);
    	let each_value = /*filteredList*/ ctx[16];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const bottom_content_slot_template = /*$$slots*/ ctx[27]["bottom-content"];
    	const bottom_content_slot = create_slot(bottom_content_slot_template, ctx, /*$$scope*/ ctx[26], get_bottom_content_slot_context);
    	let if_block2 = /*filteredList*/ ctx[16].length == 0 && create_if_block$w(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(searchinput.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			if (bottom_content_slot) bottom_content_slot.c();
    			t4 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(div0, "flex", "");
    			add_location(div0, file$U, 139, 4, 2600);
    			attr_dev(div1, "layout", "row");
    			attr_dev(div1, "name", "header");
    			add_location(div1, file$U, 138, 2, 2563);
    			attr_dev(div2, "id", div2_id_value = "content-" + /*id*/ ctx[3]);
    			add_location(div2, file$U, 165, 2, 4459);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(searchinput, div0, null);
    			append_dev(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div2, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			append_dev(div2, t3);

    			if (bottom_content_slot) {
    				bottom_content_slot.m(div2, null);
    			}

    			append_dev(div2, t4);
    			if (if_block2) if_block2.m(div2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const searchinput_changes = {};

    			if (!updating_value && dirty[0] & /*searchValue*/ 1) {
    				updating_value = true;
    				searchinput_changes.value = /*searchValue*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			searchinput.$set(searchinput_changes);

    			if (/*sortable*/ ctx[4]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*sortable*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*filterable*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*filterable*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$h(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*$$scope, filteredList*/ 67174400) {
    				each_value = /*filteredList*/ ctx[16];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div2, t3);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (bottom_content_slot) {
    				if (bottom_content_slot.p && dirty[0] & /*$$scope, filteredList*/ 67174400) {
    					bottom_content_slot.p(get_slot_context(bottom_content_slot_template, ctx, /*$$scope*/ ctx[26], get_bottom_content_slot_context), get_slot_changes(bottom_content_slot_template, /*$$scope*/ ctx[26], dirty, get_bottom_content_slot_changes));
    				}
    			}

    			if (/*filteredList*/ ctx[16].length == 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*filteredList*/ 65536) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$w(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div2, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*id*/ 8 && div2_id_value !== (div2_id_value = "content-" + /*id*/ ctx[3])) {
    				attr_dev(div2, "id", div2_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(searchinput.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(bottom_content_slot, local);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(searchinput.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(bottom_content_slot, local);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(searchinput);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    			if (bottom_content_slot) bottom_content_slot.d(detaching);
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	var checkFilter,
    		checkSort,
    		dispatch,
    		filterMenu,
    		filterMenuButtonRef,
    		filterMenuClick,
    		showFilterMenu,
    		showSortMenu,
    		sortMenu,
    		sortMenuButtonRef,
    		sortMenuClick,
    		sortMenuRef;

    	dispatch = createEventDispatcher();
    	var { list = [] } = $$props;
    	var { id = uuid() } = $$props;
    	var { reverse = false } = $$props;
    	var { sortable = true } = $$props; // set this to false
    	var { filterable = true } = $$props;
    	var { searchValue = "" } = $$props;
    	var { sortKey = void 0 } = $$props;

    	var { filterFn = function (listToFilter, searchString) {
    		return listToFilter;
    	} } = $$props;

    	var { sortFn = function (a, b) {
    		return a > b;
    	} } = $$props;

    	var { sortOptions = [
    		{
    			ordinal: 1,
    			id: "name",
    			label: "Name",
    			ascending: true,
    			selected: true
    		},
    		{
    			ordinal: 2,
    			id: "description",
    			label: "Description",
    			ascending: true,
    			selected: false
    		},
    		{
    			ordinal: 3,
    			label: "Something Else",
    			ascending: true,
    			selected: false
    		}
    	] } = $$props;

    	var { filterOptions = [
    		{
    			ordinal: 1,
    			id: "name",
    			label: "type 1",
    			selected: false
    		},
    		{
    			ordinal: 2,
    			id: "description",
    			label: "type 2",
    			selected: true
    		},
    		{
    			ordinal: 3,
    			label: "type 3",
    			selected: false
    		}
    	] } = $$props;

    	sortMenuButtonRef = void 0;
    	sortMenuRef = void 0;
    	showSortMenu = false;
    	showFilterMenu = false;

    	sortMenu = function () {
    		return $$invalidate(10, showSortMenu = true);
    	};

    	filterMenuButtonRef = void 0;

    	filterMenu = function () {
    		return $$invalidate(9, showFilterMenu = true);
    	};

    	sortMenuClick = function (e) {
    		console.log("sort change");
    		console.log(e.detail.item);
    		$$invalidate(1, sortOptions = e.detail.items);
    		return dispatch("sort", e.detail.item);
    	};

    	filterMenuClick = function (e) {
    		console.log("filter change");
    		console.log(e.detail);
    		$$invalidate(2, filterOptions = e.detail);
    		return dispatch("filter", e.detail);
    	};

    	checkSort = function (list) {
    		var selectedItem;

    		selectedItem = list.find(function (i) {
    			return i.selected === true;
    		});

    		return selectedItem.ascending;
    	};

    	checkFilter = function (list) {
    		return !list.every({ selected: false });
    	};

    	const writable_props = [
    		"list",
    		"id",
    		"reverse",
    		"sortable",
    		"filterable",
    		"searchValue",
    		"sortKey",
    		"filterFn",
    		"sortFn",
    		"sortOptions",
    		"filterOptions"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$s.warn(`<FilteredList> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FilteredList", $$slots, ['default','bottom-content','blank-slate']);

    	function searchinput_value_binding(value) {
    		searchValue = value;
    		$$invalidate(0, searchValue);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(12, sortMenuButtonRef = $$value);
    		});
    	}

    	function sortmenu_showMenu_binding(value) {
    		showSortMenu = value;
    		$$invalidate(10, showSortMenu);
    	}

    	function sortmenu_trigger_binding(value) {
    		sortMenuButtonRef = value;
    		$$invalidate(12, sortMenuButtonRef);
    	}

    	function button_binding_1($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(7, filterMenuButtonRef = $$value);
    		});
    	}

    	function filtermenu_showMenu_binding(value) {
    		showFilterMenu = value;
    		$$invalidate(9, showFilterMenu);
    	}

    	function filtermenu_trigger_binding(value) {
    		filterMenuButtonRef = value;
    		$$invalidate(7, filterMenuButtonRef);
    	}

    	$$self.$set = $$props => {
    		if ("list" in $$props) $$invalidate(17, list = $$props.list);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("reverse" in $$props) $$invalidate(18, reverse = $$props.reverse);
    		if ("sortable" in $$props) $$invalidate(4, sortable = $$props.sortable);
    		if ("filterable" in $$props) $$invalidate(5, filterable = $$props.filterable);
    		if ("searchValue" in $$props) $$invalidate(0, searchValue = $$props.searchValue);
    		if ("sortKey" in $$props) $$invalidate(19, sortKey = $$props.sortKey);
    		if ("filterFn" in $$props) $$invalidate(20, filterFn = $$props.filterFn);
    		if ("sortFn" in $$props) $$invalidate(21, sortFn = $$props.sortFn);
    		if ("sortOptions" in $$props) $$invalidate(1, sortOptions = $$props.sortOptions);
    		if ("filterOptions" in $$props) $$invalidate(2, filterOptions = $$props.filterOptions);
    		if ("$$scope" in $$props) $$invalidate(26, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		checkFilter,
    		checkSort,
    		dispatch,
    		filterMenu,
    		filterMenuButtonRef,
    		filterMenuClick,
    		showFilterMenu,
    		showSortMenu,
    		sortMenu,
    		sortMenuButtonRef,
    		sortMenuClick,
    		sortMenuRef,
    		createEventDispatcher,
    		onMount,
    		afterUpdate,
    		SearchInput,
    		SortMenu,
    		FilterMenu,
    		TopSplit,
    		list,
    		id,
    		reverse,
    		sortable,
    		filterable,
    		searchValue,
    		sortKey,
    		filterFn,
    		sortFn,
    		sortOptions,
    		filterOptions,
    		currently_ascending,
    		currently_filtering,
    		filteredList
    	});

    	$$self.$inject_state = $$props => {
    		if ("checkFilter" in $$props) $$invalidate(22, checkFilter = $$props.checkFilter);
    		if ("checkSort" in $$props) $$invalidate(23, checkSort = $$props.checkSort);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("filterMenu" in $$props) $$invalidate(6, filterMenu = $$props.filterMenu);
    		if ("filterMenuButtonRef" in $$props) $$invalidate(7, filterMenuButtonRef = $$props.filterMenuButtonRef);
    		if ("filterMenuClick" in $$props) $$invalidate(8, filterMenuClick = $$props.filterMenuClick);
    		if ("showFilterMenu" in $$props) $$invalidate(9, showFilterMenu = $$props.showFilterMenu);
    		if ("showSortMenu" in $$props) $$invalidate(10, showSortMenu = $$props.showSortMenu);
    		if ("sortMenu" in $$props) $$invalidate(11, sortMenu = $$props.sortMenu);
    		if ("sortMenuButtonRef" in $$props) $$invalidate(12, sortMenuButtonRef = $$props.sortMenuButtonRef);
    		if ("sortMenuClick" in $$props) $$invalidate(13, sortMenuClick = $$props.sortMenuClick);
    		if ("sortMenuRef" in $$props) sortMenuRef = $$props.sortMenuRef;
    		if ("list" in $$props) $$invalidate(17, list = $$props.list);
    		if ("id" in $$props) $$invalidate(3, id = $$props.id);
    		if ("reverse" in $$props) $$invalidate(18, reverse = $$props.reverse);
    		if ("sortable" in $$props) $$invalidate(4, sortable = $$props.sortable);
    		if ("filterable" in $$props) $$invalidate(5, filterable = $$props.filterable);
    		if ("searchValue" in $$props) $$invalidate(0, searchValue = $$props.searchValue);
    		if ("sortKey" in $$props) $$invalidate(19, sortKey = $$props.sortKey);
    		if ("filterFn" in $$props) $$invalidate(20, filterFn = $$props.filterFn);
    		if ("sortFn" in $$props) $$invalidate(21, sortFn = $$props.sortFn);
    		if ("sortOptions" in $$props) $$invalidate(1, sortOptions = $$props.sortOptions);
    		if ("filterOptions" in $$props) $$invalidate(2, filterOptions = $$props.filterOptions);
    		if ("currently_ascending" in $$props) $$invalidate(14, currently_ascending = $$props.currently_ascending);
    		if ("currently_filtering" in $$props) $$invalidate(15, currently_filtering = $$props.currently_filtering);
    		if ("filteredList" in $$props) $$invalidate(16, filteredList = $$props.filteredList);
    	};

    	let currently_ascending;
    	let currently_filtering;
    	let filteredList;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*checkSort, sortOptions*/ 8388610) {
    			 $$invalidate(14, currently_ascending = checkSort(sortOptions));
    		}

    		if ($$self.$$.dirty[0] & /*checkFilter, filterOptions*/ 4194308) {
    			 $$invalidate(15, currently_filtering = checkFilter(filterOptions));
    		}

    		if ($$self.$$.dirty[0] & /*filterFn, list, searchValue*/ 1179649) {
    			 $$invalidate(16, filteredList = filterFn(list, searchValue));
    		}
    	};

    	return [
    		searchValue,
    		sortOptions,
    		filterOptions,
    		id,
    		sortable,
    		filterable,
    		filterMenu,
    		filterMenuButtonRef,
    		filterMenuClick,
    		showFilterMenu,
    		showSortMenu,
    		sortMenu,
    		sortMenuButtonRef,
    		sortMenuClick,
    		currently_ascending,
    		currently_filtering,
    		filteredList,
    		list,
    		reverse,
    		sortKey,
    		filterFn,
    		sortFn,
    		checkFilter,
    		checkSort,
    		dispatch,
    		sortMenuRef,
    		$$scope,
    		$$slots,
    		searchinput_value_binding,
    		button_binding,
    		sortmenu_showMenu_binding,
    		sortmenu_trigger_binding,
    		button_binding_1,
    		filtermenu_showMenu_binding,
    		filtermenu_trigger_binding
    	];
    }

    class FilteredList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$_,
    			create_fragment$_,
    			safe_not_equal,
    			{
    				list: 17,
    				id: 3,
    				reverse: 18,
    				sortable: 4,
    				filterable: 5,
    				searchValue: 0,
    				sortKey: 19,
    				filterFn: 20,
    				sortFn: 21,
    				sortOptions: 1,
    				filterOptions: 2
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FilteredList",
    			options,
    			id: create_fragment$_.name
    		});
    	}

    	get list() {
    		throw new Error("<FilteredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set list(value) {
    		throw new Error("<FilteredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<FilteredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<FilteredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get reverse() {
    		throw new Error("<FilteredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set reverse(value) {
    		throw new Error("<FilteredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortable() {
    		throw new Error("<FilteredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortable(value) {
    		throw new Error("<FilteredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterable() {
    		throw new Error("<FilteredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterable(value) {
    		throw new Error("<FilteredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get searchValue() {
    		throw new Error("<FilteredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searchValue(value) {
    		throw new Error("<FilteredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortKey() {
    		throw new Error("<FilteredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortKey(value) {
    		throw new Error("<FilteredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterFn() {
    		throw new Error("<FilteredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterFn(value) {
    		throw new Error("<FilteredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortFn() {
    		throw new Error("<FilteredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortFn(value) {
    		throw new Error("<FilteredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sortOptions() {
    		throw new Error("<FilteredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sortOptions(value) {
    		throw new Error("<FilteredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterOptions() {
    		throw new Error("<FilteredList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterOptions(value) {
    		throw new Error("<FilteredList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\Projects\Sections\Reports.svelte generated by Svelte v3.22.2 */

    // (29:0) <Section {list} {open} name="Reports">
    function create_default_slot$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("tbd");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(29:0) <Section {list} {open} name=\\\"Reports\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$$(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				list: /*list*/ ctx[1],
    				open: /*open*/ ctx[0],
    				name: "Reports",
    				$$slots: { default: [create_default_slot$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const section_changes = {};
    			if (dirty & /*list*/ 2) section_changes.list = /*list*/ ctx[1];
    			if (dirty & /*open*/ 1) section_changes.open = /*open*/ ctx[0];

    			if (dirty & /*$$scope*/ 16) {
    				section_changes.$$scope = { dirty, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	var filterFn, list;
    	var { project = void 0 } = $$props;
    	var { open = true } = $$props;

    	filterFn = function (listToFilter, searchString) {
    		if (searchString != null) {
    			searchString = searchString.toLowerCase();

    			return listToFilter.filter(function (item) {
    				return (item.name || "").toLowerCase().includes(searchString) || (item.description || "").toLowerCase().includes(searchString);
    			});
    		} else {
    			return listToFilter;
    		}
    	};

    	list = [];
    	const writable_props = ["project", "open"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Reports> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Reports", $$slots, []);

    	$$self.$set = $$props => {
    		if ("project" in $$props) $$invalidate(2, project = $$props.project);
    		if ("open" in $$props) $$invalidate(0, open = $$props.open);
    	};

    	$$self.$capture_state = () => ({
    		filterFn,
    		list,
    		Section,
    		FilteredList,
    		project,
    		open
    	});

    	$$self.$inject_state = $$props => {
    		if ("filterFn" in $$props) filterFn = $$props.filterFn;
    		if ("list" in $$props) $$invalidate(1, list = $$props.list);
    		if ("project" in $$props) $$invalidate(2, project = $$props.project);
    		if ("open" in $$props) $$invalidate(0, open = $$props.open);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*project*/ 4) {
    			 $$invalidate(1, list = project.work_units || []);
    		}
    	};

    	return [open, list, project];
    }

    class Reports extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, { project: 2, open: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Reports",
    			options,
    			id: create_fragment$$.name
    		});
    	}

    	get project() {
    		throw new Error("<Reports>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set project(value) {
    		throw new Error("<Reports>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		throw new Error("<Reports>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<Reports>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var FileSaver_min = createCommonjsModule(function (module, exports) {
    (function(a,b){b();})(commonjsGlobal,function(){function b(a,b){return "undefined"==typeof b?b={autoBom:!1}:"object"!=typeof b&&(console.warn("Deprecated: Expected third argument to be a object"),b={autoBom:!b}),b.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob(["\uFEFF",a],{type:a.type}):a}function c(b,c,d){var e=new XMLHttpRequest;e.open("GET",b),e.responseType="blob",e.onload=function(){a(e.response,c,d);},e.onerror=function(){console.error("could not download file");},e.send();}function d(a){var b=new XMLHttpRequest;b.open("HEAD",a,!1);try{b.send();}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent("click"));}catch(c){var b=document.createEvent("MouseEvents");b.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof commonjsGlobal&&commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,a=f.saveAs||("object"!=typeof window||window!==f?function(){}:"download"in HTMLAnchorElement.prototype?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement("a");g=g||b.name||"download",j.download=g,j.rel="noopener","string"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target="_blank")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:"msSaveOrOpenBlob"in navigator?function(f,g,h){if(g=g||f.name||"download","string"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else {var i=document.createElement("a");i.href=f,i.target="_blank",setTimeout(function(){e(i);});}}:function(a,b,d,e){if(e=e||open("","_blank"),e&&(e.document.title=e.document.body.innerText="downloading..."),"string"==typeof a)return c(a,b,d);var g="application/octet-stream"===a.type,h=/constructor/i.test(f.HTMLElement)||f.safari,i=/CriOS\/[\d]+/.test(navigator.userAgent);if((i||g&&h)&&"object"==typeof FileReader){var j=new FileReader;j.onloadend=function(){var a=j.result;a=i?a:a.replace(/^data:[^;]*;/,"data:attachment/file;"),e?e.location.href=a:location=a,e=null;},j.readAsDataURL(a);}else {var k=f.URL||f.webkitURL,l=k.createObjectURL(a);e?e.location=l:location.href=l,e=null,setTimeout(function(){k.revokeObjectURL(l);},4E4);}});f.saveAs=a.saveAs=a,(module.exports=a);});


    });

    /* src\svelte\pages\Projects\Sections\Settings.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$a, console: console_1$t } = globals;
    const file$V = "src\\svelte\\pages\\Projects\\Sections\\Settings.svelte";

    // (155:91) {:else}
    function create_else_block$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Archive");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$i.name,
    		type: "else",
    		source: "(155:91) {:else}",
    		ctx
    	});

    	return block;
    }

    // (155:60) {#if item.is_archived}
    function create_if_block_1$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Unarchive");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(155:60) {#if item.is_archived}",
    		ctx
    	});

    	return block;
    }

    // (118:0) <Section {open} name="Settings">
    function create_default_slot$q(ctx) {
    	let article;
    	let h20;
    	let t1;
    	let p0;
    	let t3;
    	let field0;
    	let t4;
    	let field1;
    	let t5;
    	let field2;
    	let t6;
    	let field3;
    	let t7;
    	let field4;
    	let t8;
    	let h21;
    	let t10;
    	let h30;
    	let t12;
    	let p1;
    	let t14;
    	let p2;
    	let button0;
    	let t16;
    	let h31;
    	let t18;
    	let p3;
    	let t20;
    	let button1;
    	let t22;
    	let h32;
    	let t24;
    	let p4;
    	let t26;
    	let p5;
    	let button2;
    	let t27;
    	let t28;
    	let h22;
    	let t30;
    	let p6;
    	let t31;
    	let b;
    	let t33;
    	let t34;
    	let div;
    	let button3;
    	let current;
    	let dispose;

    	const checkbox0 = new Checkbox({
    			props: {
    				checked: /*item*/ ctx[0].settings.sections.about.enabled,
    				key: "about",
    				label: "Enable About"
    			},
    			$$inline: true
    		});

    	checkbox0.$on("change", function () {
    		if (is_function(/*toggleSection*/ ctx[9])) /*toggleSection*/ ctx[9].apply(this, arguments);
    	});

    	const checkbox1 = new Checkbox({
    			props: {
    				checked: /*item*/ ctx[0].settings.sections.assignments.enabled,
    				key: "assignments",
    				label: "Enable Assignments"
    			},
    			$$inline: true
    		});

    	checkbox1.$on("change", function () {
    		if (is_function(/*toggleSection*/ ctx[9])) /*toggleSection*/ ctx[9].apply(this, arguments);
    	});

    	const checkbox2 = new Checkbox({
    			props: {
    				checked: /*item*/ ctx[0].settings.sections.tasks.enabled,
    				key: "tasks",
    				label: "Enable Tasks"
    			},
    			$$inline: true
    		});

    	checkbox2.$on("change", function () {
    		if (is_function(/*toggleSection*/ ctx[9])) /*toggleSection*/ ctx[9].apply(this, arguments);
    	});

    	const checkbox3 = new Checkbox({
    			props: {
    				checked: /*item*/ ctx[0].settings.sections.documents.enabled,
    				key: "documents",
    				label: "Enable Documents"
    			},
    			$$inline: true
    		});

    	checkbox3.$on("change", function () {
    		if (is_function(/*toggleSection*/ ctx[9])) /*toggleSection*/ ctx[9].apply(this, arguments);
    	});

    	const checkbox4 = new Checkbox({
    			props: {
    				checked: /*item*/ ctx[0].settings.sections.clips.enabled,
    				key: "clips",
    				label: "Enable Clips"
    			},
    			$$inline: true
    		});

    	checkbox4.$on("change", function () {
    		if (is_function(/*toggleSection*/ ctx[9])) /*toggleSection*/ ctx[9].apply(this, arguments);
    	});

    	function select_block_type(ctx, dirty) {
    		if (/*item*/ ctx[0].is_archived) return create_if_block_1$i;
    		return create_else_block$i;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			article = element("article");
    			h20 = element("h2");
    			h20.textContent = "Enable/Disable Sections";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "Enabling and disabling will not delete existing items, it will only prevent them from being visible.";
    			t3 = space();
    			field0 = element("field");
    			create_component(checkbox0.$$.fragment);
    			t4 = space();
    			field1 = element("field");
    			create_component(checkbox1.$$.fragment);
    			t5 = space();
    			field2 = element("field");
    			create_component(checkbox2.$$.fragment);
    			t6 = space();
    			field3 = element("field");
    			create_component(checkbox3.$$.fragment);
    			t7 = space();
    			field4 = element("field");
    			create_component(checkbox4.$$.fragment);
    			t8 = space();
    			h21 = element("h2");
    			h21.textContent = "Common Actions";
    			t10 = space();
    			h30 = element("h3");
    			h30.textContent = "Clone Collection";
    			t12 = space();
    			p1 = element("p");
    			p1.textContent = "This will make an exact copy of the collection.";
    			t14 = space();
    			p2 = element("p");
    			button0 = element("button");
    			button0.textContent = "Clone Collection";
    			t16 = space();
    			h31 = element("h3");
    			h31.textContent = "Export Collection";
    			t18 = space();
    			p3 = element("p");
    			p3.textContent = "This will save your collection as a JSON file into your downloads folder.";
    			t20 = space();
    			button1 = element("button");
    			button1.textContent = "Save to Disk";
    			t22 = space();
    			h32 = element("h3");
    			h32.textContent = "Archive Collection";
    			t24 = space();
    			p4 = element("p");
    			p4.textContent = "This will mark the item as archived and it will no longer appear in the current items list.";
    			t26 = space();
    			p5 = element("p");
    			button2 = element("button");
    			if_block.c();
    			t27 = text(" Collection");
    			t28 = space();
    			h22 = element("h2");
    			h22.textContent = "Danger Zone";
    			t30 = space();
    			p6 = element("p");
    			t31 = text("Deleting the item will ");
    			b = element("b");
    			b.textContent = "permanently";
    			t33 = text(" delete all assignments, tasks and other items related to this item.");
    			t34 = space();
    			div = element("div");
    			button3 = element("button");
    			button3.textContent = "Delete Collection";
    			add_location(h20, file$V, 120, 2, 3003);
    			add_location(p0, file$V, 122, 2, 3039);
    			add_location(field0, file$V, 125, 2, 3151);
    			add_location(field1, file$V, 128, 2, 3294);
    			add_location(field2, file$V, 131, 2, 3455);
    			add_location(field3, file$V, 134, 2, 3598);
    			add_location(field4, file$V, 137, 2, 3753);
    			add_location(h21, file$V, 140, 2, 3896);
    			add_location(h30, file$V, 142, 2, 3923);
    			add_location(p1, file$V, 143, 2, 3951);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "primary", "");
    			add_location(button0, file$V, 145, 5, 4012);
    			add_location(p2, file$V, 145, 2, 4009);
    			add_location(h31, file$V, 147, 2, 4092);
    			add_location(p3, file$V, 148, 2, 4121);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "primary", "");
    			add_location(button1, file$V, 149, 2, 4204);
    			add_location(h32, file$V, 152, 2, 4278);
    			add_location(p4, file$V, 153, 2, 4308);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "primary", "");
    			add_location(button2, file$V, 154, 5, 4412);
    			add_location(p5, file$V, 154, 2, 4409);
    			add_location(h22, file$V, 156, 2, 4545);
    			add_location(b, file$V, 157, 28, 4594);
    			add_location(p6, file$V, 157, 2, 4568);
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "critical", "");
    			add_location(button3, file$V, 159, 4, 4697);
    			add_location(div, file$V, 158, 2, 4687);
    			attr_dev(article, "type", "content");
    			add_location(article, file$V, 118, 0, 2975);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, article, anchor);
    			append_dev(article, h20);
    			append_dev(article, t1);
    			append_dev(article, p0);
    			append_dev(article, t3);
    			append_dev(article, field0);
    			mount_component(checkbox0, field0, null);
    			append_dev(article, t4);
    			append_dev(article, field1);
    			mount_component(checkbox1, field1, null);
    			append_dev(article, t5);
    			append_dev(article, field2);
    			mount_component(checkbox2, field2, null);
    			append_dev(article, t6);
    			append_dev(article, field3);
    			mount_component(checkbox3, field3, null);
    			append_dev(article, t7);
    			append_dev(article, field4);
    			mount_component(checkbox4, field4, null);
    			append_dev(article, t8);
    			append_dev(article, h21);
    			append_dev(article, t10);
    			append_dev(article, h30);
    			append_dev(article, t12);
    			append_dev(article, p1);
    			append_dev(article, t14);
    			append_dev(article, p2);
    			append_dev(p2, button0);
    			append_dev(article, t16);
    			append_dev(article, h31);
    			append_dev(article, t18);
    			append_dev(article, p3);
    			append_dev(article, t20);
    			append_dev(article, button1);
    			append_dev(article, t22);
    			append_dev(article, h32);
    			append_dev(article, t24);
    			append_dev(article, p4);
    			append_dev(article, t26);
    			append_dev(article, p5);
    			append_dev(p5, button2);
    			if_block.m(button2, null);
    			append_dev(button2, t27);
    			append_dev(article, t28);
    			append_dev(article, h22);
    			append_dev(article, t30);
    			append_dev(article, p6);
    			append_dev(p6, t31);
    			append_dev(p6, b);
    			append_dev(p6, t33);
    			append_dev(article, t34);
    			append_dev(article, div);
    			append_dev(div, button3);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					button0,
    					"click",
    					function () {
    						if (is_function(/*clone*/ ctx[3])) /*clone*/ ctx[3].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button1,
    					"click",
    					function () {
    						if (is_function(/*saveAs*/ ctx[7])) /*saveAs*/ ctx[7].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button2,
    					"click",
    					function () {
    						if (is_function(/*archiveToggle*/ ctx[2])) /*archiveToggle*/ ctx[2].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button3,
    					"click",
    					function () {
    						if (is_function(/*deleteConfirmation*/ ctx[4])) /*deleteConfirmation*/ ctx[4].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const checkbox0_changes = {};
    			if (dirty & /*item*/ 1) checkbox0_changes.checked = /*item*/ ctx[0].settings.sections.about.enabled;
    			checkbox0.$set(checkbox0_changes);
    			const checkbox1_changes = {};
    			if (dirty & /*item*/ 1) checkbox1_changes.checked = /*item*/ ctx[0].settings.sections.assignments.enabled;
    			checkbox1.$set(checkbox1_changes);
    			const checkbox2_changes = {};
    			if (dirty & /*item*/ 1) checkbox2_changes.checked = /*item*/ ctx[0].settings.sections.tasks.enabled;
    			checkbox2.$set(checkbox2_changes);
    			const checkbox3_changes = {};
    			if (dirty & /*item*/ 1) checkbox3_changes.checked = /*item*/ ctx[0].settings.sections.documents.enabled;
    			checkbox3.$set(checkbox3_changes);
    			const checkbox4_changes = {};
    			if (dirty & /*item*/ 1) checkbox4_changes.checked = /*item*/ ctx[0].settings.sections.clips.enabled;
    			checkbox4.$set(checkbox4_changes);

    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(button2, t27);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox0.$$.fragment, local);
    			transition_in(checkbox1.$$.fragment, local);
    			transition_in(checkbox2.$$.fragment, local);
    			transition_in(checkbox3.$$.fragment, local);
    			transition_in(checkbox4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox0.$$.fragment, local);
    			transition_out(checkbox1.$$.fragment, local);
    			transition_out(checkbox2.$$.fragment, local);
    			transition_out(checkbox3.$$.fragment, local);
    			transition_out(checkbox4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(article);
    			destroy_component(checkbox0);
    			destroy_component(checkbox1);
    			destroy_component(checkbox2);
    			destroy_component(checkbox3);
    			destroy_component(checkbox4);
    			if_block.d();
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(118:0) <Section {open} name=\\\"Settings\\\">",
    		ctx
    	});

    	return block;
    }

    // (164:0) {#if showDeleteConfirmation}
    function create_if_block$x(ctx) {
    	let current;
    	const deleteconfirmation = new DeleteConfirmation({ $$inline: true });

    	deleteconfirmation.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[6])) /*destroy*/ ctx[6].apply(this, arguments);
    	});

    	deleteconfirmation.$on("cancel", function () {
    		if (is_function(/*deleteConfirmationCancel*/ ctx[5])) /*deleteConfirmationCancel*/ ctx[5].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(deleteconfirmation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deleteconfirmation, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteconfirmation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteconfirmation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deleteconfirmation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(164:0) {#if showDeleteConfirmation}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let t;
    	let if_block_anchor;
    	let current;

    	const section = new Section({
    			props: {
    				open: /*open*/ ctx[1],
    				name: "Settings",
    				$$slots: { default: [create_default_slot$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*showDeleteConfirmation*/ ctx[8] && create_if_block$x(ctx);

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const section_changes = {};
    			if (dirty & /*open*/ 2) section_changes.open = /*open*/ ctx[1];

    			if (dirty & /*$$scope, deleteConfirmation, archiveToggle, item, saveAs, clone, toggleSection*/ 17053) {
    				section_changes.$$scope = { dirty, ctx };
    			}

    			section.$set(section_changes);

    			if (/*showDeleteConfirmation*/ ctx[8]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showDeleteConfirmation*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$x(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	var archiveToggle,
    		clone,
    		deferredUpdate,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		resource,
    		saveAs,
    		showDeleteConfirmation,
    		toggleSection,
    		update;

    	dispatch = createEventDispatcher();
    	resource = new project({});
    	var { item = void 0 } = $$props;
    	var { open = true } = $$props;
    	showDeleteConfirmation = false;

    	deleteConfirmation = function () {
    		return $$invalidate(8, showDeleteConfirmation = true);
    	};

    	deleteConfirmationCancel = function () {
    		return $$invalidate(8, showDeleteConfirmation = false);
    	};

    	destroy = function () {
    		var scb;

    		scb = function () {
    			console.log("deleted");
    			return push("/");
    		};

    		return resource.destroy(item.id, scb, null, null);
    	};

    	update = function (changes) {
    		var ecb, scb;

    		scb = function (updated) {
    			console.log("updated");
    			return console.log(scb);
    		};

    		ecb = function (err) {
    			console.log("udpate err");
    			console.log(err);
    			return console.log("should refresh the proejct");
    		};

    		return resource.update(item, scb, ecb, null);
    	};

    	deferredUpdate = update.debounce(500);

    	toggleSection = function (e) {
    		var details;
    		details = e.detail;
    		$$invalidate(0, item.settings.sections[details.key].enabled = details.checked, item);
    		return dispatch("update");
    	};

    	saveAs = function () {
    		var blob, jsonString;
    		jsonString = JSON.stringify(item, null, 2);
    		blob = new Blob([jsonString], { type: "text/plain;charset=utf-8" });

    		// note - the md5 works on the string loaded in the file, which is not the same as the file''s md5
    		// use a different handler for electron
    		return FileSaver_min.saveAs(blob, `project-${item.name.replace(/[^a-z0-9]/gi, "_").first(50).toLowerCase()}-${Date.create().toTimestampId()}--${md5(jsonString)}.json`);
    	};

    	clone = function () {
    		var newId, newProject, scb;
    		newProject = Object.clone(item, true);
    		console.log("newProject to be cloned");
    		console.log(newProject);
    		newId = uuid();
    		newProject.id = newId;
    		newProject._id = newId;
    		newProject.name = `${newProject.name} (clone)`;
    		delete newProject._rev;

    		scb = function (saved) {
    			return push(`/projects/${saved.id}`);
    		};

    		console.log(newProject);
    		return resource.insert(newProject, scb, null, null);
    	};

    	archiveToggle = function () {
    		$$invalidate(0, item.is_archived = !item.is_archived, item);

    		return update({
    			id: item.id,
    			is_archived: item.is_archived
    		});
    	};

    	const writable_props = ["item", "open"];

    	Object_1$a.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$t.warn(`<Settings> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Settings", $$slots, []);

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("open" in $$props) $$invalidate(1, open = $$props.open);
    	};

    	$$self.$capture_state = () => ({
    		archiveToggle,
    		clone,
    		deferredUpdate,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		resource,
    		saveAs,
    		showDeleteConfirmation,
    		toggleSection,
    		update,
    		push,
    		pop,
    		replace,
    		location: location$1,
    		createEventDispatcher,
    		FileSaver: FileSaver_min,
    		md5,
    		Resource: project,
    		Section,
    		FilteredList,
    		DeleteConfirmation,
    		Checkbox,
    		item,
    		open
    	});

    	$$self.$inject_state = $$props => {
    		if ("archiveToggle" in $$props) $$invalidate(2, archiveToggle = $$props.archiveToggle);
    		if ("clone" in $$props) $$invalidate(3, clone = $$props.clone);
    		if ("deferredUpdate" in $$props) deferredUpdate = $$props.deferredUpdate;
    		if ("deleteConfirmation" in $$props) $$invalidate(4, deleteConfirmation = $$props.deleteConfirmation);
    		if ("deleteConfirmationCancel" in $$props) $$invalidate(5, deleteConfirmationCancel = $$props.deleteConfirmationCancel);
    		if ("destroy" in $$props) $$invalidate(6, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("resource" in $$props) resource = $$props.resource;
    		if ("saveAs" in $$props) $$invalidate(7, saveAs = $$props.saveAs);
    		if ("showDeleteConfirmation" in $$props) $$invalidate(8, showDeleteConfirmation = $$props.showDeleteConfirmation);
    		if ("toggleSection" in $$props) $$invalidate(9, toggleSection = $$props.toggleSection);
    		if ("update" in $$props) update = $$props.update;
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("open" in $$props) $$invalidate(1, open = $$props.open);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		item,
    		open,
    		archiveToggle,
    		clone,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		saveAs,
    		showDeleteConfirmation,
    		toggleSection
    	];
    }

    class Settings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$10, safe_not_equal, { item: 0, open: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Settings",
    			options,
    			id: create_fragment$10.name
    		});
    	}

    	get item() {
    		throw new Error("<Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		throw new Error("<Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\Projects\Show.svelte generated by Svelte v3.22.2 */

    const { console: console_1$u, document: document_1 } = globals;
    const file$W = "src\\svelte\\pages\\Projects\\Show.svelte";

    // (130:0) {#if project}
    function create_if_block$y(ctx) {
    	let current;

    	const pagecontent = new PageContent({
    			props: {
    				$$slots: { default: [create_default_slot$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pagecontent.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagecontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const pagecontent_changes = {};

    			if (dirty[0] & /*project, deferredUpdate, updateProjectAttribute*/ 7 | dirty[1] & /*$$scope*/ 2) {
    				pagecontent_changes.$$scope = { dirty, ctx };
    			}

    			pagecontent.$set(pagecontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagecontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagecontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagecontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$y.name,
    		type: "if",
    		source: "(130:0) {#if project}",
    		ctx
    	});

    	return block;
    }

    // (136:6) <h6 slot="subtitle">
    function create_subtitle_slot(ctx) {
    	let h6;
    	let current;
    	const favoritesmenu = new Favorites({ $$inline: true });

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			create_component(favoritesmenu.$$.fragment);
    			attr_dev(h6, "slot", "subtitle");
    			attr_dev(h6, "class", "svelte-1misayf");
    			add_location(h6, file$W, 135, 6, 3478);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			mount_component(favoritesmenu, h6, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(favoritesmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(favoritesmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			destroy_component(favoritesmenu);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_subtitle_slot.name,
    		type: "slot",
    		source: "(136:6) <h6 slot=\\\"subtitle\\\">",
    		ctx
    	});

    	return block;
    }

    // (140:6) <div slot="icon">
    function create_icon_slot(ctx) {
    	let div;
    	let updating_value;
    	let current;

    	function progress_value_binding(value) {
    		/*progress_value_binding*/ ctx[14].call(null, value);
    	}

    	let progress_props = { item: /*project*/ ctx[1], size: 36 };

    	if (/*project*/ ctx[1].progress !== void 0) {
    		progress_props.value = /*project*/ ctx[1].progress;
    	}

    	const progress = new Progress({ props: progress_props, $$inline: true });
    	binding_callbacks.push(() => bind(progress, "value", progress_value_binding));

    	progress.$on("update", function () {
    		if (is_function(/*updateProjectAttribute*/ ctx[2])) /*updateProjectAttribute*/ ctx[2].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(progress.$$.fragment);
    			attr_dev(div, "slot", "icon");
    			add_location(div, file$W, 139, 6, 3547);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(progress, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const progress_changes = {};
    			if (dirty[0] & /*project*/ 2) progress_changes.item = /*project*/ ctx[1];

    			if (!updating_value && dirty[0] & /*project*/ 2) {
    				updating_value = true;
    				progress_changes.value = /*project*/ ctx[1].progress;
    				add_flush_callback(() => updating_value = false);
    			}

    			progress.$set(progress_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(progress.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(progress.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(progress);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot.name,
    		type: "slot",
    		source: "(140:6) <div slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (142:6) <div slot="secondary-info">
    function create_secondary_info_slot(ctx) {
    	let div0;
    	let div3;
    	let div1;
    	let div1_present_value;
    	let t;
    	let div2;
    	let div2_present_value;
    	let current;

    	const duedatepopover = new DueDate({
    			props: {
    				item: /*project*/ ctx[1],
    				value: /*project*/ ctx[1].due_date,
    				isListItem: false
    			},
    			$$inline: true
    		});

    	duedatepopover.$on("update", function () {
    		if (is_function(/*updateProjectAttribute*/ ctx[2])) /*updateProjectAttribute*/ ctx[2].apply(this, arguments);
    	});

    	duedatepopover.$on("open", /*open_handler*/ ctx[16]);
    	duedatepopover.$on("close", /*close_handler*/ ctx[17]);

    	const estimatepopover = new Time({
    			props: {
    				item: /*project*/ ctx[1],
    				isListItem: false
    			},
    			$$inline: true
    		});

    	estimatepopover.$on("update", function () {
    		if (is_function(/*updateProjectAttribute*/ ctx[2])) /*updateProjectAttribute*/ ctx[2].apply(this, arguments);
    	});

    	estimatepopover.$on("open", /*open_handler_1*/ ctx[18]);
    	estimatepopover.$on("close", /*close_handler_1*/ ctx[19]);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			create_component(duedatepopover.$$.fragment);
    			t = space();
    			div2 = element("div");
    			create_component(estimatepopover.$$.fragment);
    			attr_dev(div1, "flex", "initial");
    			attr_dev(div1, "present", div1_present_value = /*project*/ ctx[1].due_date != null);
    			add_location(div1, file$W, 147, 10, 3935);
    			attr_dev(div2, "flex", "initial");
    			attr_dev(div2, "present", div2_present_value = (/*project*/ ctx[1].estimate || 0) > 0);
    			set_style(div2, "padding-left", "8px");
    			add_location(div2, file$W, 150, 10, 4162);
    			attr_dev(div3, "layout", "row");
    			add_location(div3, file$W, 142, 8, 3865);
    			attr_dev(div0, "slot", "secondary-info");
    			add_location(div0, file$W, 141, 6, 3828);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, div3);
    			append_dev(div3, div1);
    			mount_component(duedatepopover, div1, null);
    			append_dev(div3, t);
    			append_dev(div3, div2);
    			mount_component(estimatepopover, div2, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const duedatepopover_changes = {};
    			if (dirty[0] & /*project*/ 2) duedatepopover_changes.item = /*project*/ ctx[1];
    			if (dirty[0] & /*project*/ 2) duedatepopover_changes.value = /*project*/ ctx[1].due_date;
    			duedatepopover.$set(duedatepopover_changes);

    			if (!current || dirty[0] & /*project*/ 2 && div1_present_value !== (div1_present_value = /*project*/ ctx[1].due_date != null)) {
    				attr_dev(div1, "present", div1_present_value);
    			}

    			const estimatepopover_changes = {};
    			if (dirty[0] & /*project*/ 2) estimatepopover_changes.item = /*project*/ ctx[1];
    			estimatepopover.$set(estimatepopover_changes);

    			if (!current || dirty[0] & /*project*/ 2 && div2_present_value !== (div2_present_value = (/*project*/ ctx[1].estimate || 0) > 0)) {
    				attr_dev(div2, "present", div2_present_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(duedatepopover.$$.fragment, local);
    			transition_in(estimatepopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(duedatepopover.$$.fragment, local);
    			transition_out(estimatepopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(duedatepopover);
    			destroy_component(estimatepopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_secondary_info_slot.name,
    		type: "slot",
    		source: "(142:6) <div slot=\\\"secondary-info\\\">",
    		ctx
    	});

    	return block;
    }

    // (135:4) <PageHeader>
    function create_default_slot_1$9(ctx) {
    	let t0;
    	let t1;
    	let updating_value;
    	let t2;
    	let current;

    	function inlineinput_value_binding(value) {
    		/*inlineinput_value_binding*/ ctx[15].call(null, value);
    	}

    	let inlineinput_props = {
    		style: "margin-left: -2px",
    		inputStyle: "margin-top: 2px; margin-left: -1px"
    	};

    	if (/*project*/ ctx[1].name !== void 0) {
    		inlineinput_props.value = /*project*/ ctx[1].name;
    	}

    	const inlineinput = new InlineInput({ props: inlineinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(inlineinput, "value", inlineinput_value_binding));

    	inlineinput.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[0])) /*deferredUpdate*/ ctx[0].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			create_component(inlineinput.$$.fragment);
    			t2 = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(inlineinput, target, anchor);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const inlineinput_changes = {};

    			if (!updating_value && dirty[0] & /*project*/ 2) {
    				updating_value = true;
    				inlineinput_changes.value = /*project*/ ctx[1].name;
    				add_flush_callback(() => updating_value = false);
    			}

    			inlineinput.$set(inlineinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inlineinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inlineinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			destroy_component(inlineinput, detaching);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(135:4) <PageHeader>",
    		ctx
    	});

    	return block;
    }

    // (132:2) <PageContent>
    function create_default_slot$r(ctx) {
    	let a0;
    	let t0;
    	let t1;
    	let a1;
    	let t2;
    	let updating_item;
    	let updating_open;
    	let t3;
    	let a2;
    	let t4;
    	let updating_item_1;
    	let updating_open_1;
    	let t5;
    	let a3;
    	let t6;
    	let updating_item_2;
    	let updating_open_2;
    	let t7;
    	let a4;
    	let t8;
    	let updating_item_3;
    	let updating_open_3;
    	let t9;
    	let a5;
    	let t10;
    	let updating_item_4;
    	let updating_open_4;
    	let t11;
    	let a6;
    	let t12;
    	let updating_item_5;
    	let updating_open_5;
    	let current;

    	const pageheader = new PageHeader({
    			props: {
    				$$slots: {
    					default: [create_default_slot_1$9],
    					"secondary-info": [create_secondary_info_slot],
    					icon: [create_icon_slot],
    					subtitle: [create_subtitle_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function description_item_binding(value) {
    		/*description_item_binding*/ ctx[20].call(null, value);
    	}

    	function description_open_binding(value) {
    		/*description_open_binding*/ ctx[21].call(null, value);
    	}

    	let description_props = {};

    	if (/*project*/ ctx[1] !== void 0) {
    		description_props.item = /*project*/ ctx[1];
    	}

    	if (/*project*/ ctx[1].settings.sections.about.expanded !== void 0) {
    		description_props.open = /*project*/ ctx[1].settings.sections.about.expanded;
    	}

    	const description = new Description({ props: description_props, $$inline: true });
    	binding_callbacks.push(() => bind(description, "item", description_item_binding));
    	binding_callbacks.push(() => bind(description, "open", description_open_binding));

    	description.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[0])) /*deferredUpdate*/ ctx[0].apply(this, arguments);
    	});

    	function subdocumentlist0_item_binding(value) {
    		/*subdocumentlist0_item_binding*/ ctx[22].call(null, value);
    	}

    	function subdocumentlist0_open_binding(value) {
    		/*subdocumentlist0_open_binding*/ ctx[23].call(null, value);
    	}

    	let subdocumentlist0_props = { collection: "assignments" };

    	if (/*project*/ ctx[1] !== void 0) {
    		subdocumentlist0_props.item = /*project*/ ctx[1];
    	}

    	if (/*project*/ ctx[1].settings.sections.assignments.expanded !== void 0) {
    		subdocumentlist0_props.open = /*project*/ ctx[1].settings.sections.assignments.expanded;
    	}

    	const subdocumentlist0 = new SubDocumentList({
    			props: subdocumentlist0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(subdocumentlist0, "item", subdocumentlist0_item_binding));
    	binding_callbacks.push(() => bind(subdocumentlist0, "open", subdocumentlist0_open_binding));

    	subdocumentlist0.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[0])) /*deferredUpdate*/ ctx[0].apply(this, arguments);
    	});

    	function subdocumentlist1_item_binding(value) {
    		/*subdocumentlist1_item_binding*/ ctx[24].call(null, value);
    	}

    	function subdocumentlist1_open_binding(value) {
    		/*subdocumentlist1_open_binding*/ ctx[25].call(null, value);
    	}

    	let subdocumentlist1_props = { collection: "tasks" };

    	if (/*project*/ ctx[1] !== void 0) {
    		subdocumentlist1_props.item = /*project*/ ctx[1];
    	}

    	if (/*project*/ ctx[1].settings.sections.tasks.expanded !== void 0) {
    		subdocumentlist1_props.open = /*project*/ ctx[1].settings.sections.tasks.expanded;
    	}

    	const subdocumentlist1 = new SubDocumentList({
    			props: subdocumentlist1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(subdocumentlist1, "item", subdocumentlist1_item_binding));
    	binding_callbacks.push(() => bind(subdocumentlist1, "open", subdocumentlist1_open_binding));

    	subdocumentlist1.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[0])) /*deferredUpdate*/ ctx[0].apply(this, arguments);
    	});

    	function subdocumentlist2_item_binding(value) {
    		/*subdocumentlist2_item_binding*/ ctx[26].call(null, value);
    	}

    	function subdocumentlist2_open_binding(value) {
    		/*subdocumentlist2_open_binding*/ ctx[27].call(null, value);
    	}

    	let subdocumentlist2_props = { collection: "documents" };

    	if (/*project*/ ctx[1] !== void 0) {
    		subdocumentlist2_props.item = /*project*/ ctx[1];
    	}

    	if (/*project*/ ctx[1].settings.sections.documents.expanded !== void 0) {
    		subdocumentlist2_props.open = /*project*/ ctx[1].settings.sections.documents.expanded;
    	}

    	const subdocumentlist2 = new SubDocumentList({
    			props: subdocumentlist2_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(subdocumentlist2, "item", subdocumentlist2_item_binding));
    	binding_callbacks.push(() => bind(subdocumentlist2, "open", subdocumentlist2_open_binding));

    	subdocumentlist2.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[0])) /*deferredUpdate*/ ctx[0].apply(this, arguments);
    	});

    	function cliplist_item_binding(value) {
    		/*cliplist_item_binding*/ ctx[28].call(null, value);
    	}

    	function cliplist_open_binding(value) {
    		/*cliplist_open_binding*/ ctx[29].call(null, value);
    	}

    	let cliplist_props = { collection: "clips" };

    	if (/*project*/ ctx[1] !== void 0) {
    		cliplist_props.item = /*project*/ ctx[1];
    	}

    	if (/*project*/ ctx[1].settings.sections.clips.expanded !== void 0) {
    		cliplist_props.open = /*project*/ ctx[1].settings.sections.clips.expanded;
    	}

    	const cliplist = new ClipList({ props: cliplist_props, $$inline: true });
    	binding_callbacks.push(() => bind(cliplist, "item", cliplist_item_binding));
    	binding_callbacks.push(() => bind(cliplist, "open", cliplist_open_binding));

    	cliplist.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[0])) /*deferredUpdate*/ ctx[0].apply(this, arguments);
    	});

    	function settings_item_binding(value) {
    		/*settings_item_binding*/ ctx[30].call(null, value);
    	}

    	function settings_open_binding(value) {
    		/*settings_open_binding*/ ctx[31].call(null, value);
    	}

    	let settings_props = {};

    	if (/*project*/ ctx[1] !== void 0) {
    		settings_props.item = /*project*/ ctx[1];
    	}

    	if (/*project*/ ctx[1].settings.sections.settings.expanded !== void 0) {
    		settings_props.open = /*project*/ ctx[1].settings.sections.settings.expanded;
    	}

    	const settings = new Settings({ props: settings_props, $$inline: true });
    	binding_callbacks.push(() => bind(settings, "item", settings_item_binding));
    	binding_callbacks.push(() => bind(settings, "open", settings_open_binding));

    	settings.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[0])) /*deferredUpdate*/ ctx[0].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			t0 = space();
    			create_component(pageheader.$$.fragment);
    			t1 = space();
    			a1 = element("a");
    			t2 = space();
    			create_component(description.$$.fragment);
    			t3 = space();
    			a2 = element("a");
    			t4 = space();
    			create_component(subdocumentlist0.$$.fragment);
    			t5 = space();
    			a3 = element("a");
    			t6 = space();
    			create_component(subdocumentlist1.$$.fragment);
    			t7 = space();
    			a4 = element("a");
    			t8 = space();
    			create_component(subdocumentlist2.$$.fragment);
    			t9 = space();
    			a5 = element("a");
    			t10 = space();
    			create_component(cliplist.$$.fragment);
    			t11 = space();
    			a6 = element("a");
    			t12 = space();
    			create_component(settings.$$.fragment);
    			attr_dev(a0, "name", "top");
    			add_location(a0, file$W, 133, 4, 3434);
    			attr_dev(a1, "name", "about");
    			add_location(a1, file$W, 162, 4, 4450);
    			attr_dev(a2, "name", "assignments");
    			add_location(a2, file$W, 165, 4, 4598);
    			attr_dev(a3, "name", "tasks");
    			add_location(a3, file$W, 168, 4, 4787);
    			attr_dev(a4, "name", "documents");
    			add_location(a4, file$W, 171, 4, 4958);
    			attr_dev(a5, "name", "clips");
    			add_location(a5, file$W, 174, 4, 5141);
    			attr_dev(a6, "name", "settings");
    			add_location(a6, file$W, 181, 4, 5442);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(pageheader, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a1, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(description, target, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, a2, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(subdocumentlist0, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, a3, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(subdocumentlist1, target, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, a4, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(subdocumentlist2, target, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, a5, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(cliplist, target, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, a6, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(settings, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const pageheader_changes = {};

    			if (dirty[0] & /*project, updateProjectAttribute, deferredUpdate*/ 7 | dirty[1] & /*$$scope*/ 2) {
    				pageheader_changes.$$scope = { dirty, ctx };
    			}

    			pageheader.$set(pageheader_changes);
    			const description_changes = {};

    			if (!updating_item && dirty[0] & /*project*/ 2) {
    				updating_item = true;
    				description_changes.item = /*project*/ ctx[1];
    				add_flush_callback(() => updating_item = false);
    			}

    			if (!updating_open && dirty[0] & /*project*/ 2) {
    				updating_open = true;
    				description_changes.open = /*project*/ ctx[1].settings.sections.about.expanded;
    				add_flush_callback(() => updating_open = false);
    			}

    			description.$set(description_changes);
    			const subdocumentlist0_changes = {};

    			if (!updating_item_1 && dirty[0] & /*project*/ 2) {
    				updating_item_1 = true;
    				subdocumentlist0_changes.item = /*project*/ ctx[1];
    				add_flush_callback(() => updating_item_1 = false);
    			}

    			if (!updating_open_1 && dirty[0] & /*project*/ 2) {
    				updating_open_1 = true;
    				subdocumentlist0_changes.open = /*project*/ ctx[1].settings.sections.assignments.expanded;
    				add_flush_callback(() => updating_open_1 = false);
    			}

    			subdocumentlist0.$set(subdocumentlist0_changes);
    			const subdocumentlist1_changes = {};

    			if (!updating_item_2 && dirty[0] & /*project*/ 2) {
    				updating_item_2 = true;
    				subdocumentlist1_changes.item = /*project*/ ctx[1];
    				add_flush_callback(() => updating_item_2 = false);
    			}

    			if (!updating_open_2 && dirty[0] & /*project*/ 2) {
    				updating_open_2 = true;
    				subdocumentlist1_changes.open = /*project*/ ctx[1].settings.sections.tasks.expanded;
    				add_flush_callback(() => updating_open_2 = false);
    			}

    			subdocumentlist1.$set(subdocumentlist1_changes);
    			const subdocumentlist2_changes = {};

    			if (!updating_item_3 && dirty[0] & /*project*/ 2) {
    				updating_item_3 = true;
    				subdocumentlist2_changes.item = /*project*/ ctx[1];
    				add_flush_callback(() => updating_item_3 = false);
    			}

    			if (!updating_open_3 && dirty[0] & /*project*/ 2) {
    				updating_open_3 = true;
    				subdocumentlist2_changes.open = /*project*/ ctx[1].settings.sections.documents.expanded;
    				add_flush_callback(() => updating_open_3 = false);
    			}

    			subdocumentlist2.$set(subdocumentlist2_changes);
    			const cliplist_changes = {};

    			if (!updating_item_4 && dirty[0] & /*project*/ 2) {
    				updating_item_4 = true;
    				cliplist_changes.item = /*project*/ ctx[1];
    				add_flush_callback(() => updating_item_4 = false);
    			}

    			if (!updating_open_4 && dirty[0] & /*project*/ 2) {
    				updating_open_4 = true;
    				cliplist_changes.open = /*project*/ ctx[1].settings.sections.clips.expanded;
    				add_flush_callback(() => updating_open_4 = false);
    			}

    			cliplist.$set(cliplist_changes);
    			const settings_changes = {};

    			if (!updating_item_5 && dirty[0] & /*project*/ 2) {
    				updating_item_5 = true;
    				settings_changes.item = /*project*/ ctx[1];
    				add_flush_callback(() => updating_item_5 = false);
    			}

    			if (!updating_open_5 && dirty[0] & /*project*/ 2) {
    				updating_open_5 = true;
    				settings_changes.open = /*project*/ ctx[1].settings.sections.settings.expanded;
    				add_flush_callback(() => updating_open_5 = false);
    			}

    			settings.$set(settings_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pageheader.$$.fragment, local);
    			transition_in(description.$$.fragment, local);
    			transition_in(subdocumentlist0.$$.fragment, local);
    			transition_in(subdocumentlist1.$$.fragment, local);
    			transition_in(subdocumentlist2.$$.fragment, local);
    			transition_in(cliplist.$$.fragment, local);
    			transition_in(settings.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pageheader.$$.fragment, local);
    			transition_out(description.$$.fragment, local);
    			transition_out(subdocumentlist0.$$.fragment, local);
    			transition_out(subdocumentlist1.$$.fragment, local);
    			transition_out(subdocumentlist2.$$.fragment, local);
    			transition_out(cliplist.$$.fragment, local);
    			transition_out(settings.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			if (detaching) detach_dev(t0);
    			destroy_component(pageheader, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a1);
    			if (detaching) detach_dev(t2);
    			destroy_component(description, detaching);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(a2);
    			if (detaching) detach_dev(t4);
    			destroy_component(subdocumentlist0, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(a3);
    			if (detaching) detach_dev(t6);
    			destroy_component(subdocumentlist1, detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(a4);
    			if (detaching) detach_dev(t8);
    			destroy_component(subdocumentlist2, detaching);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(a5);
    			if (detaching) detach_dev(t10);
    			destroy_component(cliplist, detaching);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(a6);
    			if (detaching) detach_dev(t12);
    			destroy_component(settings, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$r.name,
    		type: "slot",
    		source: "(132:2) <PageContent>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$11(ctx) {
    	let title_value;
    	let t;
    	let if_block_anchor;
    	let current;
    	document_1.title = title_value = /*title*/ ctx[3];
    	let if_block = /*project*/ ctx[1] && create_if_block$y(ctx);

    	const block = {
    		c: function create() {
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 8) && title_value !== (title_value = /*title*/ ctx[3])) {
    				document_1.title = title_value;
    			}

    			if (/*project*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*project*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$y(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	var copyThisUrl,
    		deferredAttributeUpdate,
    		deferredUpdate,
    		expandState,
    		getProject,
    		jump,
    		list,
    		project$1,
    		refresh,
    		resource,
    		updateProject,
    		updateProjectAttribute;

    	var { params = {} } = $$props;
    	resource = new project();
    	project$1 = void 0;
    	list = [];

    	getProject = function () {
    		var scb;

    		scb = function (doc) {
    			$$invalidate(1, project$1 = doc);
    			console.log("-0-project");
    			return console.log(project$1);
    		};

    		return resource.selectOne(params.id, scb, null, null);
    	};

    	updateProject = function () {
    		var ecb, scb;

    		scb = function (updated) {
    			return console.log("updated");
    		};

    		ecb = function (err) {
    			console.log("udpate err");
    			console.log(err);
    			console.log("should refresh the proejct");
    			return getProject();
    		};

    		return resource.update(project$1, scb, ecb, null);
    	};

    	deferredUpdate = updateProject.debounce(500);

    	updateProjectAttribute = function (e) {
    		var ecb, scb;

    		scb = function (updated) {
    			console.log("updated attributes");
    			return getProject();
    		};

    		ecb = function (err) {
    			console.log("udpate err");
    			console.log(err);
    			console.log("should refresh the proejct");
    			return getProject();
    		};

    		return resource.updateAttributes(e.detail, scb, ecb, null);
    	};

    	deferredAttributeUpdate = updateProjectAttribute.debounce(500);

    	jump = function (anchorName) {
    		var elem, scrollContainer;
    		elem = u(`[name=${anchorName}]`);
    		scrollContainer = u("body > main > section").first();
    		return scrollContainer.scrollTop = elem.first().offsetTop - 40;
    	};

    	refresh = function (e) {
    		console.log("should refresh project");
    		return resource.selectOne(params.id, scb, null, null);
    	};

    	expandState = function (expanded) {
    		return ["description", "assignments", "tasks", "documents", "clips", "settings"].forEach(function (key) {
    			return $$invalidate(1, project$1.settings.sections[key].expanded = expanded, project$1);
    		});
    	};

    	copyThisUrl = function (e) {
    		var dummy, tempId, url;
    		dummy = document.createElement("input");

    		// dummy.style.display = 'none'
    		url = window.location.href;

    		document.body.appendChild(dummy);
    		tempId = uuid();
    		dummy.setAttribute("id", `clip-${tempId}`);
    		document.getElementById(`clip-${tempId}`).value = url;
    		dummy.select();
    		document.execCommand("copy");
    		document.body.removeChild(dummy);
    		return console.log(`copied ${window.location.href}`);
    	};

    	
    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$u.warn(`<Show> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Show", $$slots, []);

    	function progress_value_binding(value) {
    		project$1.progress = value;
    		$$invalidate(1, project$1);
    	}

    	function inlineinput_value_binding(value) {
    		project$1.name = value;
    		$$invalidate(1, project$1);
    	}

    	function open_handler(event) {
    		bubble($$self, event);
    	}

    	function close_handler(event) {
    		bubble($$self, event);
    	}

    	function open_handler_1(event) {
    		bubble($$self, event);
    	}

    	function close_handler_1(event) {
    		bubble($$self, event);
    	}

    	function description_item_binding(value) {
    		project$1 = value;
    		$$invalidate(1, project$1);
    	}

    	function description_open_binding(value) {
    		project$1.settings.sections.about.expanded = value;
    		$$invalidate(1, project$1);
    	}

    	function subdocumentlist0_item_binding(value) {
    		project$1 = value;
    		$$invalidate(1, project$1);
    	}

    	function subdocumentlist0_open_binding(value) {
    		project$1.settings.sections.assignments.expanded = value;
    		$$invalidate(1, project$1);
    	}

    	function subdocumentlist1_item_binding(value) {
    		project$1 = value;
    		$$invalidate(1, project$1);
    	}

    	function subdocumentlist1_open_binding(value) {
    		project$1.settings.sections.tasks.expanded = value;
    		$$invalidate(1, project$1);
    	}

    	function subdocumentlist2_item_binding(value) {
    		project$1 = value;
    		$$invalidate(1, project$1);
    	}

    	function subdocumentlist2_open_binding(value) {
    		project$1.settings.sections.documents.expanded = value;
    		$$invalidate(1, project$1);
    	}

    	function cliplist_item_binding(value) {
    		project$1 = value;
    		$$invalidate(1, project$1);
    	}

    	function cliplist_open_binding(value) {
    		project$1.settings.sections.clips.expanded = value;
    		$$invalidate(1, project$1);
    	}

    	function settings_item_binding(value) {
    		project$1 = value;
    		$$invalidate(1, project$1);
    	}

    	function settings_open_binding(value) {
    		project$1.settings.sections.settings.expanded = value;
    		$$invalidate(1, project$1);
    	}

    	$$self.$set = $$props => {
    		if ("params" in $$props) $$invalidate(4, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		copyThisUrl,
    		deferredAttributeUpdate,
    		deferredUpdate,
    		expandState,
    		getProject,
    		jump,
    		list,
    		project: project$1,
    		refresh,
    		resource,
    		updateProject,
    		updateProjectAttribute,
    		push,
    		pop,
    		replace,
    		location: location$1,
    		Resource: project,
    		params,
    		InlineInput,
    		FavoritesMenu: Favorites,
    		Progress,
    		DueDatePopover: DueDate,
    		EstimatePopover: Time,
    		PageContent,
    		PageHeader,
    		Description,
    		SubDocumentList,
    		ClipList,
    		Reports,
    		Settings,
    		title
    	});

    	$$self.$inject_state = $$props => {
    		if ("copyThisUrl" in $$props) copyThisUrl = $$props.copyThisUrl;
    		if ("deferredAttributeUpdate" in $$props) deferredAttributeUpdate = $$props.deferredAttributeUpdate;
    		if ("deferredUpdate" in $$props) $$invalidate(0, deferredUpdate = $$props.deferredUpdate);
    		if ("expandState" in $$props) expandState = $$props.expandState;
    		if ("getProject" in $$props) $$invalidate(8, getProject = $$props.getProject);
    		if ("jump" in $$props) jump = $$props.jump;
    		if ("list" in $$props) list = $$props.list;
    		if ("project" in $$props) $$invalidate(1, project$1 = $$props.project);
    		if ("refresh" in $$props) refresh = $$props.refresh;
    		if ("resource" in $$props) resource = $$props.resource;
    		if ("updateProject" in $$props) updateProject = $$props.updateProject;
    		if ("updateProjectAttribute" in $$props) $$invalidate(2, updateProjectAttribute = $$props.updateProjectAttribute);
    		if ("params" in $$props) $$invalidate(4, params = $$props.params);
    		if ("title" in $$props) $$invalidate(3, title = $$props.title);
    	};

    	let title;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*project*/ 2) {
    			 $$invalidate(3, title = project$1 ? project$1.name : "Unnamed project");
    		}

    		if ($$self.$$.dirty[0] & /*params, getProject*/ 272) {
    			// handle a reroute
    			 if (params.id) {
    				getProject();
    			}
    		}
    	};

    	return [
    		deferredUpdate,
    		project$1,
    		updateProjectAttribute,
    		title,
    		params,
    		copyThisUrl,
    		deferredAttributeUpdate,
    		expandState,
    		getProject,
    		jump,
    		list,
    		refresh,
    		resource,
    		updateProject,
    		progress_value_binding,
    		inlineinput_value_binding,
    		open_handler,
    		close_handler,
    		open_handler_1,
    		close_handler_1,
    		description_item_binding,
    		description_open_binding,
    		subdocumentlist0_item_binding,
    		subdocumentlist0_open_binding,
    		subdocumentlist1_item_binding,
    		subdocumentlist1_open_binding,
    		subdocumentlist2_item_binding,
    		subdocumentlist2_open_binding,
    		cliplist_item_binding,
    		cliplist_open_binding,
    		settings_item_binding,
    		settings_open_binding
    	];
    }

    class Show extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$11, safe_not_equal, { params: 4 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Show",
    			options,
    			id: create_fragment$11.name
    		});
    	}

    	get params() {
    		throw new Error("<Show>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Show>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var ChecklistItem, SubDocument$6;

    SubDocument$6 = sub_document;

    ChecklistItem = (function() {
      class ChecklistItem extends SubDocument$6 {
        model() {
          return {
            // if sourceversion < latest version, then some upgrades may be required
            // if null then return latest
            id: null,
            type: this.type,
            ordinal: null,
            indent: 0,
            content: "",
            content_indexable: "",
            is_completed: false,
            assigned_to: [],
            created_at: null,
            updated_at: null,
            metadata: {}
          };
        }

      }
      ChecklistItem.prototype.name = "Checklist Item";

      ChecklistItem.prototype.type = "checklist";

      return ChecklistItem;

    }).call(commonjsGlobal);

    var checklist_item = ChecklistItem;

    /* src\svelte\pages\_Common\Sections\Checklist.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$b, console: console_1$v } = globals;
    const file$X = "src\\svelte\\pages\\_Common\\Sections\\Checklist.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[25] = list[i];
    	child_ctx[26] = list;
    	child_ctx[27] = i;
    	return child_ctx;
    }

    // (143:2) {#if list && list.length}
    function create_if_block$z(ctx) {
    	let div;
    	let t;
    	let current;

    	const droppabledivider = new DroppableDivider({
    			props: {
    				index: -1,
    				listId: /*listId*/ ctx[2],
    				sameListOnly: /*sameListOnly*/ ctx[3]
    			},
    			$$inline: true
    		});

    	droppabledivider.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[7])) /*dropEvent*/ ctx[7].apply(this, arguments);
    	});

    	let each_value = /*list*/ ctx[12];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(droppabledivider.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$X, 144, 4, 3292);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(droppabledivider, div, null);
    			append_dev(div, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const droppabledivider_changes = {};
    			if (dirty & /*listId*/ 4) droppabledivider_changes.listId = /*listId*/ ctx[2];
    			if (dirty & /*sameListOnly*/ 8) droppabledivider_changes.sameListOnly = /*sameListOnly*/ ctx[3];
    			droppabledivider.$set(droppabledivider_changes);

    			if (dirty & /*item, listId, sameListOnly, dropEvent, list, updateAttribute, destroy, project, style, saveName, label, toggleCompleted*/ 268443599) {
    				each_value = /*list*/ ctx[12];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(droppabledivider.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(droppabledivider.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(droppabledivider);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$z.name,
    		type: "if",
    		source: "(143:2) {#if list && list.length}",
    		ctx
    	});

    	return block;
    }

    // (156:16) {:else}
    function create_else_block$j(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M19 5v14H5V5h14m2-2H3v18h18V3z");
    			add_location(path, file$X, 156, 18, 4136);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$j.name,
    		type: "else",
    		source: "(156:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (154:16) {#if checklistItem.is_completed}
    function create_if_block_2$7(ctx) {
    	let path;

    	const block = {
    		c: function create() {
    			path = svg_element("path");
    			attr_dev(path, "d", "M21 3H3v18h18V3zM10 17l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z");
    			add_location(path, file$X, 154, 18, 4012);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, path, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(path);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(154:16) {#if checklistItem.is_completed}",
    		ctx
    	});

    	return block;
    }

    // (163:12) <InlineInput bind:value={checklistItem.content} on:update={saveName} {style} let:label>
    function create_default_slot_2$7(ctx) {
    	let span;
    	let a;
    	let em;
    	let t_value = /*label*/ ctx[28] + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			a = element("a");
    			em = element("em");
    			t = text(t_value);
    			add_location(em, file$X, 163, 32, 4432);
    			add_location(a, file$X, 163, 29, 4429);
    			attr_dev(span, "ellipsis", "");
    			add_location(span, file$X, 163, 14, 4414);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, a);
    			append_dev(a, em);
    			append_dev(em, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 268435456 && t_value !== (t_value = /*label*/ ctx[28] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(163:12) <InlineInput bind:value={checklistItem.content} on:update={saveName} {style} let:label>",
    		ctx
    	});

    	return block;
    }

    // (172:14) {#if (project.assignments.length > 0)}
    function create_if_block_1$j(ctx) {
    	let div;
    	let updating_item;
    	let div_present_value;
    	let current;

    	function assignmentpopover_item_binding(value) {
    		/*assignmentpopover_item_binding*/ ctx[22].call(null, value, /*checklistItem*/ ctx[25], /*each_value*/ ctx[26], /*index*/ ctx[27]);
    	}

    	let assignmentpopover_props = { project: /*project*/ ctx[1] };

    	if (/*checklistItem*/ ctx[25] !== void 0) {
    		assignmentpopover_props.item = /*checklistItem*/ ctx[25];
    	}

    	const assignmentpopover = new Assignment$1({
    			props: assignmentpopover_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(assignmentpopover, "item", assignmentpopover_item_binding));

    	assignmentpopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[11])) /*updateAttribute*/ ctx[11].apply(this, arguments);
    	});

    	assignmentpopover.$on("open", /*open_handler_1*/ ctx[23]);
    	assignmentpopover.$on("close", /*close_handler_1*/ ctx[24]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(assignmentpopover.$$.fragment);
    			attr_dev(div, "flex", "initial");
    			attr_dev(div, "present", div_present_value = (/*checklistItem*/ ctx[25].assigned_to || []).length > 0);
    			attr_dev(div, "class", "svelte-7bkolf");
    			add_location(div, file$X, 172, 16, 4831);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(assignmentpopover, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const assignmentpopover_changes = {};
    			if (dirty & /*project*/ 2) assignmentpopover_changes.project = /*project*/ ctx[1];

    			if (!updating_item && dirty & /*list*/ 4096) {
    				updating_item = true;
    				assignmentpopover_changes.item = /*checklistItem*/ ctx[25];
    				add_flush_callback(() => updating_item = false);
    			}

    			assignmentpopover.$set(assignmentpopover_changes);

    			if (!current || dirty & /*list*/ 4096 && div_present_value !== (div_present_value = (/*checklistItem*/ ctx[25].assigned_to || []).length > 0)) {
    				attr_dev(div, "present", div_present_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(assignmentpopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(assignmentpopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(assignmentpopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$j.name,
    		type: "if",
    		source: "(172:14) {#if (project.assignments.length > 0)}",
    		ctx
    	});

    	return block;
    }

    // (182:10) <div slot="menu">
    function create_menu_slot$3(ctx) {
    	let div;
    	let current;

    	const menu = new Checklist({
    			props: { item: /*checklistItem*/ ctx[25] },
    			$$inline: true
    		});

    	menu.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[11])) /*updateAttribute*/ ctx[11].apply(this, arguments);
    	});

    	menu.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[6])) /*destroy*/ ctx[6].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(menu.$$.fragment);
    			attr_dev(div, "slot", "menu");
    			add_location(div, file$X, 181, 10, 5142);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(menu, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const menu_changes = {};
    			if (dirty & /*list*/ 4096) menu_changes.item = /*checklistItem*/ ctx[25];
    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(menu);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_menu_slot$3.name,
    		type: "slot",
    		source: "(182:10) <div slot=\\\"menu\\\">",
    		ctx
    	});

    	return block;
    }

    // (148:8) <DraggableItem item={checklistItem} index={index} {listId} {sameListOnly} on:drop={dropEvent} on:update={updateAttribute}>
    function create_default_slot_1$a(ctx) {
    	let div5;
    	let t0;
    	let div0;
    	let button;
    	let svg;
    	let path;
    	let t1;
    	let div1;
    	let updating_value;
    	let t2;
    	let div4;
    	let div3;
    	let div2;
    	let t3;
    	let t4;
    	let current;
    	let dispose;

    	const indent = new Indent({
    			props: {
    				level: /*checklistItem*/ ctx[25].indent.clamp(0, 5)
    			},
    			$$inline: true
    		});

    	function select_block_type(ctx, dirty) {
    		if (/*checklistItem*/ ctx[25].is_completed) return create_if_block_2$7;
    		return create_else_block$j;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function inlineinput_value_binding(value) {
    		/*inlineinput_value_binding*/ ctx[19].call(null, value, /*checklistItem*/ ctx[25]);
    	}

    	let inlineinput_props = {
    		style: /*style*/ ctx[9],
    		$$slots: {
    			default: [
    				create_default_slot_2$7,
    				({ label }) => ({ 28: label }),
    				({ label }) => label ? 268435456 : 0
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*checklistItem*/ ctx[25].content !== void 0) {
    		inlineinput_props.value = /*checklistItem*/ ctx[25].content;
    	}

    	const inlineinput = new InlineInput({ props: inlineinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(inlineinput, "value", inlineinput_value_binding));

    	inlineinput.$on("update", function () {
    		if (is_function(/*saveName*/ ctx[8])) /*saveName*/ ctx[8].apply(this, arguments);
    	});

    	const duedatepopover = new DueDate({
    			props: {
    				item: /*checklistItem*/ ctx[25],
    				value: /*checklistItem*/ ctx[25].due_date
    			},
    			$$inline: true
    		});

    	duedatepopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[11])) /*updateAttribute*/ ctx[11].apply(this, arguments);
    	});

    	duedatepopover.$on("open", /*open_handler*/ ctx[20]);
    	duedatepopover.$on("close", /*close_handler*/ ctx[21]);
    	let if_block1 = /*project*/ ctx[1].assignments.length > 0 && create_if_block_1$j(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			create_component(indent.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if_block0.c();
    			t1 = space();
    			div1 = element("div");
    			create_component(inlineinput.$$.fragment);
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			create_component(duedatepopover.$$.fragment);
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			attr_dev(path, "fill", "none");
    			attr_dev(path, "d", "M0 0h24v24H0V0z");
    			add_location(path, file$X, 152, 97, 3903);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$X, 152, 14, 3820);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$X, 151, 12, 3735);
    			attr_dev(div0, "flex", "initial");
    			set_style(div0, "padding-right", "8px");
    			add_location(div0, file$X, 150, 10, 3674);
    			attr_dev(div1, "flex", "");
    			attr_dev(div1, "ellipsis", "");
    			add_location(div1, file$X, 161, 12, 4278);
    			attr_dev(div2, "flex", "initial");
    			add_location(div2, file$X, 168, 14, 4585);
    			attr_dev(div3, "layout", "row");
    			add_location(div3, file$X, 167, 12, 4551);
    			attr_dev(div4, "flex", "initial");
    			add_location(div4, file$X, 166, 10, 4517);
    			attr_dev(div5, "layout", "row");
    			attr_dev(div5, "type", "list-item");
    			attr_dev(div5, "class", "svelte-7bkolf");
    			add_location(div5, file$X, 148, 8, 3566);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div5, anchor);
    			mount_component(indent, div5, null);
    			append_dev(div5, t0);
    			append_dev(div5, div0);
    			append_dev(div0, button);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			if_block0.m(svg, null);
    			append_dev(div5, t1);
    			append_dev(div5, div1);
    			mount_component(inlineinput, div1, null);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			mount_component(duedatepopover, div2, null);
    			append_dev(div3, t3);
    			if (if_block1) if_block1.m(div3, null);
    			insert_dev(target, t4, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*toggleCompleted*/ ctx[10](/*checklistItem*/ ctx[25]))) /*toggleCompleted*/ ctx[10](/*checklistItem*/ ctx[25]).apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const indent_changes = {};
    			if (dirty & /*list*/ 4096) indent_changes.level = /*checklistItem*/ ctx[25].indent.clamp(0, 5);
    			indent.$set(indent_changes);

    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(svg, null);
    				}
    			}

    			const inlineinput_changes = {};
    			if (dirty & /*style*/ 512) inlineinput_changes.style = /*style*/ ctx[9];

    			if (dirty & /*$$scope, label*/ 805306368) {
    				inlineinput_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty & /*list*/ 4096) {
    				updating_value = true;
    				inlineinput_changes.value = /*checklistItem*/ ctx[25].content;
    				add_flush_callback(() => updating_value = false);
    			}

    			inlineinput.$set(inlineinput_changes);
    			const duedatepopover_changes = {};
    			if (dirty & /*list*/ 4096) duedatepopover_changes.item = /*checklistItem*/ ctx[25];
    			if (dirty & /*list*/ 4096) duedatepopover_changes.value = /*checklistItem*/ ctx[25].due_date;
    			duedatepopover.$set(duedatepopover_changes);

    			if (/*project*/ ctx[1].assignments.length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*project*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$j(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indent.$$.fragment, local);
    			transition_in(inlineinput.$$.fragment, local);
    			transition_in(duedatepopover.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indent.$$.fragment, local);
    			transition_out(inlineinput.$$.fragment, local);
    			transition_out(duedatepopover.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(indent);
    			if_block0.d();
    			destroy_component(inlineinput);
    			destroy_component(duedatepopover);
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t4);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(148:8) <DraggableItem item={checklistItem} index={index} {listId} {sameListOnly} on:drop={dropEvent} on:update={updateAttribute}>",
    		ctx
    	});

    	return block;
    }

    // (147:6) {#each list as checklistItem, index}
    function create_each_block$e(ctx) {
    	let t;
    	let current;

    	const draggableitem = new DraggableIndentableItem({
    			props: {
    				item: /*checklistItem*/ ctx[25],
    				index: /*index*/ ctx[27],
    				listId: /*listId*/ ctx[2],
    				sameListOnly: /*sameListOnly*/ ctx[3],
    				$$slots: {
    					default: [create_default_slot_1$a],
    					menu: [create_menu_slot$3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	draggableitem.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[7])) /*dropEvent*/ ctx[7].apply(this, arguments);
    	});

    	draggableitem.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[11])) /*updateAttribute*/ ctx[11].apply(this, arguments);
    	});

    	const droppabledivider = new DroppableDivider({
    			props: {
    				item: /*item*/ ctx[0],
    				index: /*index*/ ctx[27],
    				listId: /*listId*/ ctx[2],
    				sameListOnly: /*sameListOnly*/ ctx[3]
    			},
    			$$inline: true
    		});

    	droppabledivider.$on("drop", function () {
    		if (is_function(/*dropEvent*/ ctx[7])) /*dropEvent*/ ctx[7].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(draggableitem.$$.fragment);
    			t = space();
    			create_component(droppabledivider.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(draggableitem, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(droppabledivider, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const draggableitem_changes = {};
    			if (dirty & /*list*/ 4096) draggableitem_changes.item = /*checklistItem*/ ctx[25];
    			if (dirty & /*listId*/ 4) draggableitem_changes.listId = /*listId*/ ctx[2];
    			if (dirty & /*sameListOnly*/ 8) draggableitem_changes.sameListOnly = /*sameListOnly*/ ctx[3];

    			if (dirty & /*$$scope, list, updateAttribute, destroy, project, style, saveName, toggleCompleted*/ 536878914) {
    				draggableitem_changes.$$scope = { dirty, ctx };
    			}

    			draggableitem.$set(draggableitem_changes);
    			const droppabledivider_changes = {};
    			if (dirty & /*item*/ 1) droppabledivider_changes.item = /*item*/ ctx[0];
    			if (dirty & /*listId*/ 4) droppabledivider_changes.listId = /*listId*/ ctx[2];
    			if (dirty & /*sameListOnly*/ 8) droppabledivider_changes.sameListOnly = /*sameListOnly*/ ctx[3];
    			droppabledivider.$set(droppabledivider_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(draggableitem.$$.fragment, local);
    			transition_in(droppabledivider.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(draggableitem.$$.fragment, local);
    			transition_out(droppabledivider.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(draggableitem, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(droppabledivider, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(147:6) {#each list as checklistItem, index}",
    		ctx
    	});

    	return block;
    }

    // (141:0) <Section name={collection.titleize()} {open}>
    function create_default_slot$s(ctx) {
    	let t;
    	let current;
    	let if_block = /*list*/ ctx[12] && /*list*/ ctx[12].length && create_if_block$z(ctx);

    	const quickentry = new GenericItem({
    			props: {
    				stubPlaceholder: "Add Checklist Item",
    				attribute: "content"
    			},
    			$$inline: true
    		});

    	quickentry.$on("add", function () {
    		if (is_function(/*add*/ ctx[4])) /*add*/ ctx[4].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(quickentry.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(quickentry, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*list*/ ctx[12] && /*list*/ ctx[12].length) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*list*/ 4096) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$z(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(quickentry.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(quickentry.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(quickentry, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$s.name,
    		type: "slot",
    		source: "(141:0) <Section name={collection.titleize()} {open}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$12(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				name: /*collection*/ ctx[5].titleize(),
    				open,
    				$$slots: { default: [create_default_slot$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const section_changes = {};
    			if (dirty & /*collection*/ 32) section_changes.name = /*collection*/ ctx[5].titleize();

    			if (dirty & /*$$scope, add, list, item, listId, sameListOnly, dropEvent, updateAttribute, destroy, project, style, saveName, toggleCompleted*/ 536879071) {
    				section_changes.$$scope = { dirty, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	var add,
    		collection,
    		destroy,
    		dispatch,
    		dropEvent,
    		save,
    		saveName,
    		sort,
    		style,
    		subDocument,
    		toggleCompleted,
    		update,
    		updateAttribute;

    	dispatch = createEventDispatcher();
    	var { assignments = [] } = $$props;
    	collection = "checklist_items";
    	var { item = void 0 } = $$props;
    	var { project = void 0 } = $$props;
    	var { listId = uuid() } = $$props;
    	var { sameListOnly = true } = $$props;
    	subDocument = new checklist_item();
    	style = ":hover {font-weight: bold}";

    	// drag and drop
    	dropEvent = function (e) {
    		var invalidDrop, refresh, tree;
    		refresh = false;
    		tree = new hierarchical_list(item[collection]);
    		invalidDrop = tree.isInvalidDrop(e.detail);

    		if (invalidDrop != null) ; else {
    			refresh = tree.dropEvent(e.detail);
    		}

    		if (refresh) {
    			$$invalidate(0, item[collection] = tree.list, item);
    			return dispatch("update");
    		}
    	};

    	// crud --
    	update = function () {
    		return dispatch("update");
    	};

    	add = function (event) {
    		var newRecord;
    		console.log(subDocument);
    		newRecord = subDocument.stub(event.detail);
    		newRecord.ordinal = (item[collection] || []).length;
    		$$invalidate(0, item[collection] = item[collection].add(newRecord), item);
    		return dispatch("update");
    	};

    	saveName = function (e) {
    		var change;
    		change = { id: item.id, content: e.detail };
    		return dispatch("update", change);
    	};

    	save = function (e) {
    		var change;
    		change = e.detail;
    		change["id"] = item.id;
    		return dispatch("update", change);
    	};

    	toggleCompleted = function (checklistItem) {
    		var found;
    		found = item[collection].find({ id: checklistItem.id });

    		if (found != null) {
    			found.is_completed = !found.is_completed;
    			found.completion_date = checklistItem.is_completed ? Date.create() : null;
    		}

    		$$invalidate(0, item);
    		return dispatch("update");
    	};

    	updateAttribute = function (e) {
    		var change, changed;
    		change = e.detail;
    		changed = item[collection].find({ id: change.id });
    		Object.merge(changed, change);
    		$$invalidate(0, item);
    		return dispatch("update", change);
    	};

    	destroy = function (e) {
    		var showDeleteConfirmation;
    		item[collection].remove({ id: e.detail.id });
    		$$invalidate(0, item);
    		dispatch("update");
    		return showDeleteConfirmation = false;
    	};

    	sort = function () {
    		if (item[collection] != null) {
    			return item[collection].sortBy("ordinal");
    		} else {
    			return [];
    		}
    	};

    	const writable_props = ["assignments", "item", "project", "listId", "sameListOnly"];

    	Object_1$b.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$v.warn(`<Checklist> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Checklist", $$slots, []);

    	function inlineinput_value_binding(value, checklistItem) {
    		checklistItem.content = value;
    		((($$invalidate(12, list), $$invalidate(16, sort)), $$invalidate(0, item)), $$invalidate(5, collection));
    	}

    	function open_handler(event) {
    		bubble($$self, event);
    	}

    	function close_handler(event) {
    		bubble($$self, event);
    	}

    	function assignmentpopover_item_binding(value, checklistItem, each_value, index) {
    		each_value[index] = value;
    		((($$invalidate(12, list), $$invalidate(16, sort)), $$invalidate(0, item)), $$invalidate(5, collection));
    	}

    	function open_handler_1(event) {
    		bubble($$self, event);
    	}

    	function close_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("assignments" in $$props) $$invalidate(13, assignments = $$props.assignments);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("project" in $$props) $$invalidate(1, project = $$props.project);
    		if ("listId" in $$props) $$invalidate(2, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(3, sameListOnly = $$props.sameListOnly);
    	};

    	$$self.$capture_state = () => ({
    		add,
    		collection,
    		destroy,
    		dispatch,
    		dropEvent,
    		save,
    		saveName,
    		sort,
    		style,
    		subDocument,
    		toggleCompleted,
    		update,
    		updateAttribute,
    		onMount,
    		createEventDispatcher,
    		DraggableItem: DraggableIndentableItem,
    		DroppableDivider,
    		QuickEntry: GenericItem,
    		InlineInput,
    		DueDatePopover: DueDate,
    		AssignmentPopover: Assignment$1,
    		Section,
    		SubDocument: checklist_item,
    		HierarchicalList: hierarchical_list,
    		Menu: Checklist,
    		Indent,
    		assignments,
    		item,
    		project,
    		listId,
    		sameListOnly,
    		list
    	});

    	$$self.$inject_state = $$props => {
    		if ("add" in $$props) $$invalidate(4, add = $$props.add);
    		if ("collection" in $$props) $$invalidate(5, collection = $$props.collection);
    		if ("destroy" in $$props) $$invalidate(6, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("dropEvent" in $$props) $$invalidate(7, dropEvent = $$props.dropEvent);
    		if ("save" in $$props) save = $$props.save;
    		if ("saveName" in $$props) $$invalidate(8, saveName = $$props.saveName);
    		if ("sort" in $$props) $$invalidate(16, sort = $$props.sort);
    		if ("style" in $$props) $$invalidate(9, style = $$props.style);
    		if ("subDocument" in $$props) subDocument = $$props.subDocument;
    		if ("toggleCompleted" in $$props) $$invalidate(10, toggleCompleted = $$props.toggleCompleted);
    		if ("update" in $$props) update = $$props.update;
    		if ("updateAttribute" in $$props) $$invalidate(11, updateAttribute = $$props.updateAttribute);
    		if ("assignments" in $$props) $$invalidate(13, assignments = $$props.assignments);
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("project" in $$props) $$invalidate(1, project = $$props.project);
    		if ("listId" in $$props) $$invalidate(2, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(3, sameListOnly = $$props.sameListOnly);
    		if ("list" in $$props) $$invalidate(12, list = $$props.list);
    	};

    	let list;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*sort, item, collection*/ 65569) {
    			 $$invalidate(12, list = sort(item[collection]));
    		}
    	};

    	return [
    		item,
    		project,
    		listId,
    		sameListOnly,
    		add,
    		collection,
    		destroy,
    		dropEvent,
    		saveName,
    		style,
    		toggleCompleted,
    		updateAttribute,
    		list,
    		assignments,
    		dispatch,
    		save,
    		sort,
    		subDocument,
    		update,
    		inlineinput_value_binding,
    		open_handler,
    		close_handler,
    		assignmentpopover_item_binding,
    		open_handler_1,
    		close_handler_1
    	];
    }

    class Checklist$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$12, create_fragment$12, safe_not_equal, {
    			assignments: 13,
    			item: 0,
    			project: 1,
    			listId: 2,
    			sameListOnly: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checklist",
    			options,
    			id: create_fragment$12.name
    		});
    	}

    	get assignments() {
    		throw new Error("<Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set assignments(value) {
    		throw new Error("<Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get project() {
    		throw new Error("<Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set project(value) {
    		throw new Error("<Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listId() {
    		throw new Error("<Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listId(value) {
    		throw new Error("<Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sameListOnly() {
    		throw new Error("<Checklist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sameListOnly(value) {
    		throw new Error("<Checklist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var SubDocument$7, TimeEntry;

    SubDocument$7 = sub_document;

    TimeEntry = (function() {
      class TimeEntry extends SubDocument$7 {
        model() {
          return {
            // if sourceversion < latest version, then some upgrades may be required
            // if null then return latest
            id: null,
            type: this.type,
            name: "",
            effort_minutes: 0,
            is_billable: true,
            booked_at: null,
            assigned_to: null,
            created_at: null,
            updated_at: null,
            metadata: {}
          };
        }

      }
      TimeEntry.prototype.name = "Time Entry";

      TimeEntry.prototype.type = "time_entry";

      return TimeEntry;

    }).call(commonjsGlobal);

    var time_entry = TimeEntry;

    /* src\svelte\components\Date\DatePicker\DatePicker.svelte generated by Svelte v3.22.2 */
    const file$Y = "src\\svelte\\components\\Date\\DatePicker\\DatePicker.svelte";

    // (116:2) <Popover bind:show={open} bind:trigger={triggerRef} width="240px" align="left">
    function create_default_slot$t(ctx) {
    	let updating_value;
    	let current;

    	function calendar_value_binding(value) {
    		/*calendar_value_binding*/ ctx[20].call(null, value);
    	}

    	let calendar_props = {};

    	if (/*selectedDate*/ ctx[2] !== void 0) {
    		calendar_props.value = /*selectedDate*/ ctx[2];
    	}

    	const calendar = new Calendar({ props: calendar_props, $$inline: true });
    	binding_callbacks.push(() => bind(calendar, "value", calendar_value_binding));

    	calendar.$on("change", function () {
    		if (is_function(/*setDay*/ ctx[3])) /*setDay*/ ctx[3].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(calendar.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(calendar, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const calendar_changes = {};

    			if (!updating_value && dirty & /*selectedDate*/ 4) {
    				updating_value = true;
    				calendar_changes.value = /*selectedDate*/ ctx[2];
    				add_flush_callback(() => updating_value = false);
    			}

    			calendar.$set(calendar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(calendar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(calendar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(calendar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$t.name,
    		type: "slot",
    		source: "(116:2) <Popover bind:show={open} bind:trigger={triggerRef} width=\\\"240px\\\" align=\\\"left\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$13(ctx) {
    	let div2;
    	let div0;
    	let input;
    	let t0;
    	let div1;
    	let button;
    	let svg;
    	let path0;
    	let path1;
    	let t1;
    	let updating_show;
    	let updating_trigger;
    	let current;
    	let dispose;

    	function popover_show_binding(value) {
    		/*popover_show_binding*/ ctx[21].call(null, value);
    	}

    	function popover_trigger_binding(value) {
    		/*popover_trigger_binding*/ ctx[22].call(null, value);
    	}

    	let popover_props = {
    		width: "240px",
    		align: "left",
    		$$slots: { default: [create_default_slot$t] },
    		$$scope: { ctx }
    	};

    	if (/*open*/ ctx[0] !== void 0) {
    		popover_props.show = /*open*/ ctx[0];
    	}

    	if (/*triggerRef*/ ctx[4] !== void 0) {
    		popover_props.trigger = /*triggerRef*/ ctx[4];
    	}

    	const popover = new Popover({ props: popover_props, $$inline: true });
    	binding_callbacks.push(() => bind(popover, "show", popover_show_binding));
    	binding_callbacks.push(() => bind(popover, "trigger", popover_trigger_binding));

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t0 = space();
    			div1 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t1 = space();
    			create_component(popover.$$.fragment);
    			attr_dev(input, "type", "text");
    			add_location(input, file$Y, 108, 4, 2247);
    			attr_dev(div0, "flex", "initial");
    			set_style(div0, "width", "100px");
    			add_location(div0, file$Y, 107, 2, 2201);
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			attr_dev(path0, "fill", "none");
    			add_location(path0, file$Y, 112, 89, 2523);
    			attr_dev(path1, "d", "M22 3h-3V1h-2v2H7V1H5v2H2v20h20V3zm-2 18H4V8h16v13z");
    			add_location(path1, file$Y, 112, 128, 2562);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "width", "24");
    			add_location(svg, file$Y, 112, 6, 2440);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$Y, 111, 4, 2362);
    			attr_dev(div1, "flex", "initial");
    			set_style(div1, "width", "40px");
    			add_location(div1, file$Y, 110, 2, 2316);
    			attr_dev(div2, "layout", "row");
    			add_location(div2, file$Y, 106, 0, 2179);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, input);
    			set_input_value(input, /*selectedDate*/ ctx[2]);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, button);
    			append_dev(button, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			/*button_binding*/ ctx[19](button);
    			append_dev(div2, t1);
    			mount_component(popover, div2, null);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(input, "input", /*input_input_handler*/ ctx[18]),
    				listen_dev(input, "keyup", /*keyup_handler*/ ctx[17], false, false, false),
    				listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(/*openMenu*/ ctx[1])) /*openMenu*/ ctx[1].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (dirty & /*selectedDate*/ 4 && input.value !== /*selectedDate*/ ctx[2]) {
    				set_input_value(input, /*selectedDate*/ ctx[2]);
    			}

    			const popover_changes = {};

    			if (dirty & /*$$scope, selectedDate, setDay*/ 8388620) {
    				popover_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_show && dirty & /*open*/ 1) {
    				updating_show = true;
    				popover_changes.show = /*open*/ ctx[0];
    				add_flush_callback(() => updating_show = false);
    			}

    			if (!updating_trigger && dirty & /*triggerRef*/ 16) {
    				updating_trigger = true;
    				popover_changes.trigger = /*triggerRef*/ ctx[4];
    				add_flush_callback(() => updating_trigger = false);
    			}

    			popover.$set(popover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(popover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(popover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			/*button_binding*/ ctx[19](null);
    			destroy_component(popover);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	var buttonRef,
    		buttonWidth,
    		closeMenu,
    		dispatch,
    		onKeydown,
    		openMenu,
    		selectedDate,
    		setDay,
    		toggleMenu,
    		tooltipRef,
    		triggerRef;

    	dispatch = createEventDispatcher();
    	var { value = Date.create() } = $$props;
    	var { direction = "bottom" } = $$props;
    	var { flipped = false } = $$props;
    	var { id = uuid() } = $$props;
    	var { open = false } = $$props;
    	var { style = void 0 } = $$props;
    	open = false;
    	buttonRef = void 0;
    	buttonWidth = void 0;
    	tooltipRef = void 0;
    	triggerRef = void 0;

    	openMenu = function () {
    		return $$invalidate(0, open = true);
    	};

    	closeMenu = function () {
    		return $$invalidate(0, open = false);
    	};

    	toggleMenu = function () {
    		return $$invalidate(0, open = !open);
    	};

    	onKeydown = function (event) {
    		if (event.key === "Escape") {
    			event.stopPropagation();
    			return $$invalidate(0, open = false);
    		}
    	};

    	selectedDate = value.format("{yyyy}-{MM}-{dd}");

    	setDay = function (e) {
    		$$invalidate(5, value = e.detail);
    		$$invalidate(2, selectedDate = e.detail.format("{yyyy}-{MM}-{dd}"));
    		dispatch("change", selectedDate);
    		return $$invalidate(0, open = false);
    	};

    	const writable_props = ["value", "direction", "flipped", "id", "open", "style"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatePicker> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatePicker", $$slots, []);

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function input_input_handler() {
    		selectedDate = this.value;
    		$$invalidate(2, selectedDate);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(4, triggerRef = $$value);
    		});
    	}

    	function calendar_value_binding(value) {
    		selectedDate = value;
    		$$invalidate(2, selectedDate);
    	}

    	function popover_show_binding(value) {
    		open = value;
    		$$invalidate(0, open);
    	}

    	function popover_trigger_binding(value) {
    		triggerRef = value;
    		$$invalidate(4, triggerRef);
    	}

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(5, value = $$props.value);
    		if ("direction" in $$props) $$invalidate(6, direction = $$props.direction);
    		if ("flipped" in $$props) $$invalidate(7, flipped = $$props.flipped);
    		if ("id" in $$props) $$invalidate(8, id = $$props.id);
    		if ("open" in $$props) $$invalidate(0, open = $$props.open);
    		if ("style" in $$props) $$invalidate(9, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({
    		buttonRef,
    		buttonWidth,
    		closeMenu,
    		dispatch,
    		onKeydown,
    		openMenu,
    		selectedDate,
    		setDay,
    		toggleMenu,
    		tooltipRef,
    		triggerRef,
    		createEventDispatcher,
    		afterUpdate,
    		Calendar,
    		Popover,
    		value,
    		direction,
    		flipped,
    		id,
    		open,
    		style
    	});

    	$$self.$inject_state = $$props => {
    		if ("buttonRef" in $$props) buttonRef = $$props.buttonRef;
    		if ("buttonWidth" in $$props) buttonWidth = $$props.buttonWidth;
    		if ("closeMenu" in $$props) closeMenu = $$props.closeMenu;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("onKeydown" in $$props) onKeydown = $$props.onKeydown;
    		if ("openMenu" in $$props) $$invalidate(1, openMenu = $$props.openMenu);
    		if ("selectedDate" in $$props) $$invalidate(2, selectedDate = $$props.selectedDate);
    		if ("setDay" in $$props) $$invalidate(3, setDay = $$props.setDay);
    		if ("toggleMenu" in $$props) toggleMenu = $$props.toggleMenu;
    		if ("tooltipRef" in $$props) tooltipRef = $$props.tooltipRef;
    		if ("triggerRef" in $$props) $$invalidate(4, triggerRef = $$props.triggerRef);
    		if ("value" in $$props) $$invalidate(5, value = $$props.value);
    		if ("direction" in $$props) $$invalidate(6, direction = $$props.direction);
    		if ("flipped" in $$props) $$invalidate(7, flipped = $$props.flipped);
    		if ("id" in $$props) $$invalidate(8, id = $$props.id);
    		if ("open" in $$props) $$invalidate(0, open = $$props.open);
    		if ("style" in $$props) $$invalidate(9, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		open,
    		openMenu,
    		selectedDate,
    		setDay,
    		triggerRef,
    		value,
    		direction,
    		flipped,
    		id,
    		style,
    		buttonRef,
    		buttonWidth,
    		closeMenu,
    		dispatch,
    		onKeydown,
    		toggleMenu,
    		tooltipRef,
    		keyup_handler,
    		input_input_handler,
    		button_binding,
    		calendar_value_binding,
    		popover_show_binding,
    		popover_trigger_binding
    	];
    }

    class DatePicker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$13, create_fragment$13, safe_not_equal, {
    			value: 5,
    			direction: 6,
    			flipped: 7,
    			id: 8,
    			open: 0,
    			style: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatePicker",
    			options,
    			id: create_fragment$13.name
    		});
    	}

    	get value() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get flipped() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set flipped(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\QuickEntry\TimeEntry.svelte generated by Svelte v3.22.2 */

    const { console: console_1$w } = globals;
    const file$Z = "src\\svelte\\pages\\_Common\\QuickEntry\\TimeEntry.svelte";

    // (89:0) {:else}
    function create_else_block$k(ctx) {
    	let div4;
    	let div0;
    	let updating_value;
    	let t0;
    	let div1;
    	let updating_value_1;
    	let t1;
    	let div2;
    	let button0;
    	let svg0;
    	let title;
    	let t2;
    	let line0;
    	let line1;
    	let button0_disabled_value;
    	let t3;
    	let div3;
    	let button1;
    	let svg1;
    	let path0;
    	let path1;
    	let current;
    	let dispose;

    	function datepicker_value_binding(value) {
    		/*datepicker_value_binding*/ ctx[15].call(null, value);
    	}

    	let datepicker_props = {};

    	if (/*bookingDate*/ ctx[3] !== void 0) {
    		datepicker_props.value = /*bookingDate*/ ctx[3];
    	}

    	const datepicker = new DatePicker({ props: datepicker_props, $$inline: true });
    	binding_callbacks.push(() => bind(datepicker, "value", datepicker_value_binding));

    	datepicker.$on("change", function () {
    		if (is_function(/*updateDate*/ ctx[10])) /*updateDate*/ ctx[10].apply(this, arguments);
    	});

    	datepicker.$on("keyup", function () {
    		if (is_function(/*datepickerKeyup*/ ctx[5])) /*datepickerKeyup*/ ctx[5].apply(this, arguments);
    	});

    	function durationinput_value_binding(value) {
    		/*durationinput_value_binding*/ ctx[16].call(null, value);
    	}

    	let durationinput_props = { autofocus: true };

    	if (/*effort*/ ctx[8] !== void 0) {
    		durationinput_props.value = /*effort*/ ctx[8];
    	}

    	const durationinput = new DurationInput({
    			props: durationinput_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(durationinput, "value", durationinput_value_binding));

    	durationinput.$on("change", function () {
    		if (is_function(/*updateEffortMinutes*/ ctx[11])) /*updateEffortMinutes*/ ctx[11].apply(this, arguments);
    	});

    	durationinput.$on("keyup", function () {
    		if (is_function(/*durationKeyup*/ ctx[6])) /*durationKeyup*/ ctx[6].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			create_component(datepicker.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(durationinput.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			button0 = element("button");
    			svg0 = svg_element("svg");
    			title = svg_element("title");
    			t2 = text("ionicons-v5-a");
    			line0 = svg_element("line");
    			line1 = svg_element("line");
    			t3 = space();
    			div3 = element("div");
    			button1 = element("button");
    			svg1 = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(div0, "flex", "initial");
    			add_location(div0, file$Z, 91, 4, 1708);
    			attr_dev(div1, "flex", "");
    			add_location(div1, file$Z, 95, 4, 1840);
    			add_location(title, file$Z, 101, 93, 2157);
    			attr_dev(line0, "x1", "256");
    			attr_dev(line0, "y1", "112");
    			attr_dev(line0, "x2", "256");
    			attr_dev(line0, "y2", "400");
    			set_style(line0, "fill", "none");
    			set_style(line0, "stroke", "#000");
    			set_style(line0, "stroke-linecap", "round");
    			set_style(line0, "stroke-linejoin", "round");
    			set_style(line0, "stroke-width", "32px");
    			add_location(line0, file$Z, 101, 121, 2185);
    			attr_dev(line1, "x1", "400");
    			attr_dev(line1, "y1", "256");
    			attr_dev(line1, "x2", "112");
    			attr_dev(line1, "y2", "256");
    			set_style(line1, "fill", "none");
    			set_style(line1, "stroke", "#000");
    			set_style(line1, "stroke-linecap", "round");
    			set_style(line1, "stroke-linejoin", "round");
    			set_style(line1, "stroke-width", "32px");
    			add_location(line1, file$Z, 101, 255, 2319);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 512 512");
    			add_location(svg0, file$Z, 101, 8, 2072);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "icon", "");
    			button0.disabled = button0_disabled_value = false;
    			add_location(button0, file$Z, 100, 6, 2004);
    			attr_dev(div2, "flex", "initial");
    			add_location(div2, file$Z, 99, 4, 1977);
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$Z, 106, 91, 2655);
    			attr_dev(path1, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z");
    			add_location(path1, file$Z, 106, 130, 2694);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			add_location(svg1, file$Z, 106, 8, 2572);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "icon", "");
    			add_location(button1, file$Z, 105, 6, 2518);
    			attr_dev(div3, "flex", "initial");
    			add_location(div3, file$Z, 104, 4, 2491);
    			attr_dev(div4, "layout", "row");
    			add_location(div4, file$Z, 89, 2, 1684);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			mount_component(datepicker, div0, null);
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			mount_component(durationinput, div1, null);
    			append_dev(div4, t1);
    			append_dev(div4, div2);
    			append_dev(div2, button0);
    			append_dev(button0, svg0);
    			append_dev(svg0, title);
    			append_dev(title, t2);
    			append_dev(svg0, line0);
    			append_dev(svg0, line1);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, button1);
    			append_dev(button1, svg1);
    			append_dev(svg1, path0);
    			append_dev(svg1, path1);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					button0,
    					"click",
    					function () {
    						if (is_function(/*add*/ ctx[2])) /*add*/ ctx[2].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button1,
    					"click",
    					function () {
    						if (is_function(/*cancel*/ ctx[4])) /*cancel*/ ctx[4].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const datepicker_changes = {};

    			if (!updating_value && dirty & /*bookingDate*/ 8) {
    				updating_value = true;
    				datepicker_changes.value = /*bookingDate*/ ctx[3];
    				add_flush_callback(() => updating_value = false);
    			}

    			datepicker.$set(datepicker_changes);
    			const durationinput_changes = {};

    			if (!updating_value_1 && dirty & /*effort*/ 256) {
    				updating_value_1 = true;
    				durationinput_changes.value = /*effort*/ ctx[8];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			durationinput.$set(durationinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepicker.$$.fragment, local);
    			transition_in(durationinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datepicker.$$.fragment, local);
    			transition_out(durationinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(datepicker);
    			destroy_component(durationinput);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$k.name,
    		type: "else",
    		source: "(89:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (87:0) {#if !showForm}
    function create_if_block$A(ctx) {
    	let current;

    	const addstub = new AddStub({
    			props: {
    				itemType: /*itemType*/ ctx[9],
    				stubPlaceholder: /*stubPlaceholder*/ ctx[1]
    			},
    			$$inline: true
    		});

    	addstub.$on("edit", function () {
    		if (is_function(/*edit*/ ctx[7])) /*edit*/ ctx[7].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(addstub.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(addstub, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const addstub_changes = {};
    			if (dirty & /*itemType*/ 512) addstub_changes.itemType = /*itemType*/ ctx[9];
    			if (dirty & /*stubPlaceholder*/ 2) addstub_changes.stubPlaceholder = /*stubPlaceholder*/ ctx[1];
    			addstub.$set(addstub_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(addstub.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(addstub.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(addstub, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$A.name,
    		type: "if",
    		source: "(87:0) {#if !showForm}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$14(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$A, create_else_block$k];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*showForm*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	var add,
    		bookingDate,
    		cancel,
    		datepickerKeyup,
    		dispatch,
    		durationKeyup,
    		edit,
    		effort,
    		itemType,
    		resetStub,
    		stub,
    		updateDate,
    		updateEffortMinutes;

    	var { stubPlaceholder = void 0 } = $$props;
    	itemType = "time entry";
    	var { showForm = false } = $$props;
    	effort = 0;

    	stub = {
    		booking_date: Date.create(),
    		effort_minutes: 0
    	};

    	resetStub = function () {
    		stub.effort_minutes = 0;
    		$$invalidate(8, effort = 0);
    		console.log("resetStub");
    		return console.log(stub);
    	};

    	edit = function () {
    		return $$invalidate(0, showForm = true);
    	};

    	cancel = function () {
    		resetStub();
    		return $$invalidate(0, showForm = false);
    	};
    	dispatch = createEventDispatcher();

    	add = function () {
    		console.log("enter");
    		console.log(stub);

    		if (stub.effort_minutes > 0) {
    			dispatch("add", stub);
    			return resetStub();
    		}
    	};

    	datepickerKeyup = function (e) {
    		if (e.key === "Escape") {
    			return cancel();
    		}
    	};

    	durationKeyup = function (e) {
    		switch (e.key) {
    			case "Escape":
    				return cancel();
    			case "Enter":
    				return add();
    		}
    	};

    	//}
    	bookingDate = Date.create();

    	updateDate = function (e) {
    		console.log("updateDate");
    		return stub.booked_at = Date.create(bookingDate);
    	};

    	updateEffortMinutes = function (e) {
    		console.log("updateEffortMinutes");
    		console.log(e.detail);
    		return stub.effort_minutes = e.detail.inMinutes;
    	};

    	const writable_props = ["stubPlaceholder", "showForm"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$w.warn(`<TimeEntry> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TimeEntry", $$slots, []);

    	function datepicker_value_binding(value) {
    		bookingDate = value;
    		$$invalidate(3, bookingDate);
    	}

    	function durationinput_value_binding(value) {
    		effort = value;
    		$$invalidate(8, effort);
    	}

    	$$self.$set = $$props => {
    		if ("stubPlaceholder" in $$props) $$invalidate(1, stubPlaceholder = $$props.stubPlaceholder);
    		if ("showForm" in $$props) $$invalidate(0, showForm = $$props.showForm);
    	};

    	$$self.$capture_state = () => ({
    		add,
    		bookingDate,
    		cancel,
    		datepickerKeyup,
    		dispatch,
    		durationKeyup,
    		edit,
    		effort,
    		itemType,
    		resetStub,
    		stub,
    		updateDate,
    		updateEffortMinutes,
    		createEventDispatcher,
    		DurationInput,
    		DatePicker,
    		AddStub,
    		stubPlaceholder,
    		showForm
    	});

    	$$self.$inject_state = $$props => {
    		if ("add" in $$props) $$invalidate(2, add = $$props.add);
    		if ("bookingDate" in $$props) $$invalidate(3, bookingDate = $$props.bookingDate);
    		if ("cancel" in $$props) $$invalidate(4, cancel = $$props.cancel);
    		if ("datepickerKeyup" in $$props) $$invalidate(5, datepickerKeyup = $$props.datepickerKeyup);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("durationKeyup" in $$props) $$invalidate(6, durationKeyup = $$props.durationKeyup);
    		if ("edit" in $$props) $$invalidate(7, edit = $$props.edit);
    		if ("effort" in $$props) $$invalidate(8, effort = $$props.effort);
    		if ("itemType" in $$props) $$invalidate(9, itemType = $$props.itemType);
    		if ("resetStub" in $$props) resetStub = $$props.resetStub;
    		if ("stub" in $$props) stub = $$props.stub;
    		if ("updateDate" in $$props) $$invalidate(10, updateDate = $$props.updateDate);
    		if ("updateEffortMinutes" in $$props) $$invalidate(11, updateEffortMinutes = $$props.updateEffortMinutes);
    		if ("stubPlaceholder" in $$props) $$invalidate(1, stubPlaceholder = $$props.stubPlaceholder);
    		if ("showForm" in $$props) $$invalidate(0, showForm = $$props.showForm);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		showForm,
    		stubPlaceholder,
    		add,
    		bookingDate,
    		cancel,
    		datepickerKeyup,
    		durationKeyup,
    		edit,
    		effort,
    		itemType,
    		updateDate,
    		updateEffortMinutes,
    		dispatch,
    		resetStub,
    		stub,
    		datepicker_value_binding,
    		durationinput_value_binding
    	];
    }

    class TimeEntry$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$14, safe_not_equal, { stubPlaceholder: 1, showForm: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TimeEntry",
    			options,
    			id: create_fragment$14.name
    		});
    	}

    	get stubPlaceholder() {
    		throw new Error("<TimeEntry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stubPlaceholder(value) {
    		throw new Error("<TimeEntry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showForm() {
    		throw new Error("<TimeEntry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showForm(value) {
    		throw new Error("<TimeEntry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Lists\HoverableItem.svelte generated by Svelte v3.22.2 */

    const { console: console_1$x } = globals;
    const file$_ = "src\\svelte\\pages\\_Common\\Lists\\HoverableItem.svelte";

    const get_menu_slot_changes$1 = dirty => ({
    	item: dirty & /*item*/ 2,
    	index: dirty & /*index*/ 1
    });

    const get_menu_slot_context$1 = ctx => ({
    	item: /*item*/ ctx[1],
    	index: /*index*/ ctx[0]
    });

    const get_default_slot_changes$4 = dirty => ({
    	item: dirty & /*item*/ 2,
    	index: dirty & /*index*/ 1
    });

    const get_default_slot_context$4 = ctx => ({
    	item: /*item*/ ctx[1],
    	index: /*index*/ ctx[0]
    });

    function create_fragment$15(ctx) {
    	let div2;
    	let div0;
    	let t;
    	let div1;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], get_default_slot_context$4);
    	const menu_slot_template = /*$$slots*/ ctx[15].menu;
    	const menu_slot = create_slot(menu_slot_template, ctx, /*$$scope*/ ctx[14], get_menu_slot_context$1);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			t = space();
    			div1 = element("div");
    			if (menu_slot) menu_slot.c();
    			attr_dev(div0, "flex", "");
    			attr_dev(div0, "class", "slot");
    			add_location(div0, file$_, 64, 6, 1127);
    			attr_dev(div1, "flex", "initial");
    			attr_dev(div1, "draggable-item-menu", "");
    			set_style(div1, "padding-left", "24px");
    			set_style(div1, "padding-right", "4px");
    			add_location(div1, file$_, 65, 6, 1196);
    			attr_dev(div2, "item-hoverable", "");
    			add_location(div2, file$_, 61, 0, 1098);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			append_dev(div2, t);
    			append_dev(div2, div1);

    			if (menu_slot) {
    				menu_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, item, index*/ 16387) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[14], get_default_slot_context$4), get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, get_default_slot_changes$4));
    				}
    			}

    			if (menu_slot) {
    				if (menu_slot.p && dirty & /*$$scope, item, index*/ 16387) {
    					menu_slot.p(get_slot_context(menu_slot_template, ctx, /*$$scope*/ ctx[14], get_menu_slot_context$1), get_slot_changes(menu_slot_template, /*$$scope*/ ctx[14], dirty, get_menu_slot_changes$1));
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(menu_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(menu_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (default_slot) default_slot.d(detaching);
    			if (menu_slot) menu_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	var closeMenu,
    		dispatch,
    		draggable,
    		draggableEl,
    		getWidth,
    		indent,
    		indentButtonRef,
    		showIndentMenu,
    		toggleIndentMenu;

    	dispatch = createEventDispatcher();
    	var { index = void 0 } = $$props;
    	var { item = void 0 } = $$props;
    	var { listId = void 0 } = $$props;
    	var { showMenu = true } = $$props;
    	showIndentMenu = false;
    	indentButtonRef = void 0;
    	draggableEl = void 0;
    	draggable = false;

    	getWidth = function (el) {
    		if (el != null) {
    			return el.clientWidth - 48;
    		} else {
    			return 0;
    		}
    	};

    	closeMenu = function () {
    		return showIndentMenu = false;
    	};

    	indent = function (indentLevel) {
    		console.log(`indent ${indentLevel}`);
    		dispatch("update", { id: item.id, indent: indentLevel });

    		// console.log {id: item.id, indent: indentLevel }
    		return closeMenu();
    	};

    	toggleIndentMenu = function () {
    		return showIndentMenu = true;
    	};

    	const writable_props = ["index", "item", "listId", "showMenu"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$x.warn(`<HoverableItem> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("HoverableItem", $$slots, ['default','menu']);

    	$$self.$set = $$props => {
    		if ("index" in $$props) $$invalidate(0, index = $$props.index);
    		if ("item" in $$props) $$invalidate(1, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(2, listId = $$props.listId);
    		if ("showMenu" in $$props) $$invalidate(3, showMenu = $$props.showMenu);
    		if ("$$scope" in $$props) $$invalidate(14, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		closeMenu,
    		dispatch,
    		draggable,
    		draggableEl,
    		getWidth,
    		indent,
    		indentButtonRef,
    		showIndentMenu,
    		toggleIndentMenu,
    		Row,
    		RowCell,
    		Menu: ComposedMenu,
    		createEventDispatcher,
    		index,
    		item,
    		listId,
    		showMenu,
    		draggableWidth
    	});

    	$$self.$inject_state = $$props => {
    		if ("closeMenu" in $$props) closeMenu = $$props.closeMenu;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("draggable" in $$props) draggable = $$props.draggable;
    		if ("draggableEl" in $$props) $$invalidate(7, draggableEl = $$props.draggableEl);
    		if ("getWidth" in $$props) $$invalidate(8, getWidth = $$props.getWidth);
    		if ("indent" in $$props) indent = $$props.indent;
    		if ("indentButtonRef" in $$props) indentButtonRef = $$props.indentButtonRef;
    		if ("showIndentMenu" in $$props) showIndentMenu = $$props.showIndentMenu;
    		if ("toggleIndentMenu" in $$props) toggleIndentMenu = $$props.toggleIndentMenu;
    		if ("index" in $$props) $$invalidate(0, index = $$props.index);
    		if ("item" in $$props) $$invalidate(1, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(2, listId = $$props.listId);
    		if ("showMenu" in $$props) $$invalidate(3, showMenu = $$props.showMenu);
    		if ("draggableWidth" in $$props) draggableWidth = $$props.draggableWidth;
    	};

    	let draggableWidth;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*getWidth, draggableEl*/ 384) {
    			 draggableWidth = getWidth(draggableEl);
    		}
    	};

    	return [
    		index,
    		item,
    		listId,
    		showMenu,
    		closeMenu,
    		dispatch,
    		draggable,
    		draggableEl,
    		getWidth,
    		indent,
    		indentButtonRef,
    		showIndentMenu,
    		toggleIndentMenu,
    		draggableWidth,
    		$$scope,
    		$$slots
    	];
    }

    class HoverableItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$15, create_fragment$15, safe_not_equal, {
    			index: 0,
    			item: 1,
    			listId: 2,
    			showMenu: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HoverableItem",
    			options,
    			id: create_fragment$15.name
    		});
    	}

    	get index() {
    		throw new Error("<HoverableItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<HoverableItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<HoverableItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<HoverableItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listId() {
    		throw new Error("<HoverableItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listId(value) {
    		throw new Error("<HoverableItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showMenu() {
    		throw new Error("<HoverableItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showMenu(value) {
    		throw new Error("<HoverableItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Menus\TimeEntry.svelte generated by Svelte v3.22.2 */

    const { console: console_1$y } = globals;
    const file$$ = "src\\svelte\\pages\\_Common\\Menus\\TimeEntry.svelte";

    // (90:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align="right" {width}>
    function create_default_slot$u(ctx) {
    	let ul;
    	let li;
    	let button;
    	let dispose;

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			li = element("li");
    			button = element("button");
    			button.textContent = "Delete Item";
    			attr_dev(button, "type", "button");
    			attr_dev(button, "class", "svelte-7ppehr");
    			add_location(button, file$$, 94, 6, 2453);
    			attr_dev(li, "class", "svelte-7ppehr");
    			add_location(li, file$$, 93, 4, 2442);
    			attr_dev(ul, "class", "svelte-7ppehr");
    			add_location(ul, file$$, 90, 2, 2431);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, ul, anchor);
    			append_dev(ul, li);
    			append_dev(li, button);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*deleteConfirmation*/ ctx[0])) /*deleteConfirmation*/ ctx[0].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$u.name,
    		type: "slot",
    		source: "(90:0) <Menu trigger={menuButtonRef} bind:showMenu={showMenu} align=\\\"right\\\" {width}>",
    		ctx
    	});

    	return block;
    }

    // (99:0) {#if showDeleteConfirmation}
    function create_if_block$B(ctx) {
    	let current;
    	const deleteconfirmation = new DeleteConfirmation({ $$inline: true });

    	deleteconfirmation.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[2])) /*destroy*/ ctx[2].apply(this, arguments);
    	});

    	deleteconfirmation.$on("cancel", function () {
    		if (is_function(/*deleteConfirmationCancel*/ ctx[1])) /*deleteConfirmationCancel*/ ctx[1].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(deleteconfirmation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deleteconfirmation, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteconfirmation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteconfirmation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deleteconfirmation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$B.name,
    		type: "if",
    		source: "(99:0) {#if showDeleteConfirmation}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$16(ctx) {
    	let button;
    	let svg;
    	let path;
    	let t0;
    	let updating_showMenu;
    	let t1;
    	let if_block_anchor;
    	let current;
    	let dispose;

    	function menu_showMenu_binding(value) {
    		/*menu_showMenu_binding*/ ctx[13].call(null, value);
    	}

    	let menu_props = {
    		trigger: /*menuButtonRef*/ ctx[3],
    		align: "right",
    		width: /*width*/ ctx[7],
    		$$slots: { default: [create_default_slot$u] },
    		$$scope: { ctx }
    	};

    	if (/*showMenu*/ ctx[6] !== void 0) {
    		menu_props.showMenu = /*showMenu*/ ctx[6];
    	}

    	const menu = new ComposedMenu({ props: menu_props, $$inline: true });
    	binding_callbacks.push(() => bind(menu, "showMenu", menu_showMenu_binding));
    	let if_block = /*showDeleteConfirmation*/ ctx[5] && create_if_block$B(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t0 = space();
    			create_component(menu.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(path, "d", "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z");
    			add_location(path, file$$, 87, 112, 2116);
    			attr_dev(svg, "class", "menu");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$$, 87, 2, 2006);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$$, 86, 0, 1930);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			/*button_binding*/ ctx[12](button);
    			insert_dev(target, t0, anchor);
    			mount_component(menu, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*openMenu*/ ctx[4])) /*openMenu*/ ctx[4].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			const menu_changes = {};
    			if (dirty & /*menuButtonRef*/ 8) menu_changes.trigger = /*menuButtonRef*/ ctx[3];
    			if (dirty & /*width*/ 128) menu_changes.width = /*width*/ ctx[7];

    			if (dirty & /*$$scope, deleteConfirmation*/ 16385) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_showMenu && dirty & /*showMenu*/ 64) {
    				updating_showMenu = true;
    				menu_changes.showMenu = /*showMenu*/ ctx[6];
    				add_flush_callback(() => updating_showMenu = false);
    			}

    			menu.$set(menu_changes);

    			if (/*showDeleteConfirmation*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showDeleteConfirmation*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$B(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			/*button_binding*/ ctx[12](null);
    			if (detaching) detach_dev(t0);
    			destroy_component(menu, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	var closeMenu,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		indent,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	menuButtonRef = void 0;
    	showMenu = false;

    	openMenu = function () {
    		return $$invalidate(6, showMenu = true);
    	};

    	closeMenu = function () {
    		return $$invalidate(6, showMenu = false);
    	};

    	width = "189px";

    	destroy = function () {
    		dispatch("destroy", item);
    		return closeMenu();
    	};

    	indent = function (indentLevel) {
    		console.log("indent");
    		dispatch("update", { id: item.id, indent: indentLevel });
    		return closeMenu();
    	};

    	showDeleteConfirmation = false;

    	deleteConfirmation = function () {
    		closeMenu();
    		return $$invalidate(5, showDeleteConfirmation = true);
    	};

    	deleteConfirmationCancel = function () {
    		return $$invalidate(5, showDeleteConfirmation = false);
    	};

    	destroy = function () {
    		dispatch("destroy", item);
    		return $$invalidate(5, showDeleteConfirmation = false);
    	};

    	const writable_props = ["item"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$y.warn(`<TimeEntry> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TimeEntry", $$slots, []);

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(3, menuButtonRef = $$value);
    		});
    	}

    	function menu_showMenu_binding(value) {
    		showMenu = value;
    		$$invalidate(6, showMenu);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(8, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({
    		closeMenu,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		indent,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width,
    		createEventDispatcher,
    		Menu: ComposedMenu,
    		DeleteConfirmation,
    		item
    	});

    	$$self.$inject_state = $$props => {
    		if ("closeMenu" in $$props) closeMenu = $$props.closeMenu;
    		if ("deleteConfirmation" in $$props) $$invalidate(0, deleteConfirmation = $$props.deleteConfirmation);
    		if ("deleteConfirmationCancel" in $$props) $$invalidate(1, deleteConfirmationCancel = $$props.deleteConfirmationCancel);
    		if ("destroy" in $$props) $$invalidate(2, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("indent" in $$props) indent = $$props.indent;
    		if ("menuButtonRef" in $$props) $$invalidate(3, menuButtonRef = $$props.menuButtonRef);
    		if ("openMenu" in $$props) $$invalidate(4, openMenu = $$props.openMenu);
    		if ("showDeleteConfirmation" in $$props) $$invalidate(5, showDeleteConfirmation = $$props.showDeleteConfirmation);
    		if ("showMenu" in $$props) $$invalidate(6, showMenu = $$props.showMenu);
    		if ("width" in $$props) $$invalidate(7, width = $$props.width);
    		if ("item" in $$props) $$invalidate(8, item = $$props.item);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		menuButtonRef,
    		openMenu,
    		showDeleteConfirmation,
    		showMenu,
    		width,
    		item,
    		closeMenu,
    		dispatch,
    		indent,
    		button_binding,
    		menu_showMenu_binding
    	];
    }

    class TimeEntry$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$16, safe_not_equal, { item: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TimeEntry",
    			options,
    			id: create_fragment$16.name
    		});
    	}

    	get item() {
    		throw new Error("<TimeEntry>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<TimeEntry>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Form\InlineInput\InlineEffort.svelte generated by Svelte v3.22.2 */

    const { console: console_1$z } = globals;
    const file$10 = "src\\svelte\\components\\Form\\InlineInput\\InlineEffort.svelte";
    const get_default_slot_changes$5 = dirty => ({ label: dirty & /*label*/ 2048 });
    const get_default_slot_context$5 = ctx => ({ label: /*label*/ ctx[11] });

    // (176:0) {:else}
    function create_else_block$l(ctx) {
    	let div;
    	let span;
    	let div_class_value;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[30].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[29], get_default_slot_context$5);
    	const default_slot_or_fallback = default_slot || fallback_block$5(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(span, "ellipsis", "");
    			attr_dev(span, "class", "svelte-1msu0ku");
    			add_location(span, file$10, 180, 4, 3282);
    			attr_dev(div, "id", /*id*/ ctx[4]);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*labelClasses*/ ctx[3]) + " svelte-1msu0ku"));
    			attr_dev(div, "ellipsis", "");
    			attr_dev(div, "style", /*style*/ ctx[2]);
    			add_location(div, file$10, 176, 2, 3213);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(span, null);
    			}

    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				span,
    				"click",
    				function () {
    					if (is_function(/*click*/ ctx[5])) /*click*/ ctx[5].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, label*/ 536872960) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[29], get_default_slot_context$5), get_slot_changes(default_slot_template, /*$$scope*/ ctx[29], dirty, get_default_slot_changes$5));
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 2048) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty & /*id*/ 16) {
    				attr_dev(div, "id", /*id*/ ctx[4]);
    			}

    			if (!current || dirty & /*labelClasses*/ 8 && div_class_value !== (div_class_value = "" + (null_to_empty(/*labelClasses*/ ctx[3]) + " svelte-1msu0ku"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty & /*style*/ 4) {
    				attr_dev(div, "style", /*style*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$l.name,
    		type: "else",
    		source: "(176:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (165:0) {#if editing && (isText || isNumber)}
    function create_if_block$C(ctx) {
    	let current;

    	const durationinput = new DurationInput({
    			props: {
    				value: /*value*/ ctx[0] / 60,
    				isMinutes: true
    			},
    			$$inline: true
    		});

    	durationinput.$on("change", function () {
    		if (is_function(/*handleChange*/ ctx[7])) /*handleChange*/ ctx[7].apply(this, arguments);
    	});

    	durationinput.$on("input", function () {
    		if (is_function(/*handleInput*/ ctx[8])) /*handleInput*/ ctx[8].apply(this, arguments);
    	});

    	durationinput.$on("keyup", function () {
    		if (is_function(/*handleKeyup*/ ctx[10])) /*handleKeyup*/ ctx[10].apply(this, arguments);
    	});

    	durationinput.$on("blur", function () {
    		if (is_function(/*handleBlur*/ ctx[6])) /*handleBlur*/ ctx[6].apply(this, arguments);
    	});

    	durationinput.$on("click", function () {
    		if (is_function(/*handleInputClick*/ ctx[9])) /*handleInputClick*/ ctx[9].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(durationinput.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(durationinput, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const durationinput_changes = {};
    			if (dirty & /*value*/ 1) durationinput_changes.value = /*value*/ ctx[0] / 60;
    			durationinput.$set(durationinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(durationinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(durationinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(durationinput, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$C.name,
    		type: "if",
    		source: "(165:0) {#if editing && (isText || isNumber)}",
    		ctx
    	});

    	return block;
    }

    // (181:50) <span ellipsis>
    function fallback_block$5(ctx) {
    	let span1;
    	let t;
    	let span0;

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			t = text(/*label*/ ctx[11]);
    			span0 = element("span");
    			attr_dev(span0, "spacer", "");
    			attr_dev(span0, "class", "svelte-1msu0ku");
    			add_location(span0, file$10, 180, 72, 3350);
    			attr_dev(span1, "ellipsis", "");
    			attr_dev(span1, "class", "svelte-1msu0ku");
    			add_location(span1, file$10, 180, 50, 3328);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, t);
    			append_dev(span1, span0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 2048) set_data_dev(t, /*label*/ ctx[11]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$5.name,
    		type: "fallback",
    		source: "(181:50) <span ellipsis>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$17(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$C, create_else_block$l];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*editing*/ ctx[1] && (/*isText*/ ctx[12] || /*isNumber*/ ctx[13])) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	var click,
    		clickCount,
    		clickReset,
    		delayedReset,
    		dispatch,
    		double,
    		handleBlur,
    		handleChange,
    		handleInput,
    		handleInputClick,
    		handleKeyup,
    		inputEl,
    		label,
    		originalValue,
    		single;

    	dispatch = createEventDispatcher();
    	var { value = "" } = $$props;
    	var { style = void 0 } = $$props;
    	var { inputStyle = void 0 } = $$props;
    	var { type = "text" } = $$props;
    	var { placeholder = "" } = $$props;
    	var { labelClasses = "" } = $$props;
    	var { inputClasses = "" } = $$props;
    	var { doubleClick = true } = $$props;
    	var { id = void 0 } = $$props;
    	var { delay = 250 } = $$props;
    	var { editing = false } = $$props;
    	inputEl = void 0;
    	label = void 0;
    	originalValue = void 0;

    	const toggle = async _ => {
    		$$invalidate(1, editing = !editing);
    		originalValue = value;

    		if (editing) {
    			await tick();
    			inputEl.focus();
    		}
    	};

    	onMount(function () {
    		return originalValue = value;
    	});

    	handleInput = function (e) {
    		if (isNumber) {
    			$$invalidate(0, value = +e.target.value);
    		}

    		return $$invalidate(0, value = e.target.value);
    	};

    	handleKeyup = function (e) {
    		// dispatch("keyup", value)
    		switch (e.keyCode) {
    			case 13:
    				// inputEl.blur()
    				console.log("should save");
    				$$invalidate(1, editing = false);
    				return dispatch("update", value);
    			case 27:
    				$$invalidate(0, value = originalValue);
    				$$invalidate(1, editing = false);
    				return console.log("should cancel");
    		}
    	};

    	// }
    	handleBlur = function (_) {
    		var unchanged;
    		unchanged = value === originalValue;

    		// toggle()
    		$$invalidate(1, editing = false);

    		if (!unchanged) {
    			return dispatch("update", value);
    		}
    	};

    	// Click tracking
    	clickCount = 0;

    	clickReset = function () {
    		switch (clickCount) {
    			case 1:
    				return single();
    			case 2:
    				return double();
    			default:
    				return clickCount = 0;
    		}
    	};

    	// }
    	delayedReset = clickReset.debounce(delay);

    	single = function () {
    		clickCount = 0;

    		if (!doubleClick) {
    			toggle();
    		}

    		return dispatch("clicked", id);
    	};

    	double = function () {
    		clickCount = 0;

    		if (doubleClick) {
    			toggle();
    		}

    		return dispatch("doubleclicked", id);
    	};

    	click = function () {
    		clickCount++;
    		return delayedReset();
    	};

    	handleInputClick = function (e) {
    		return e.preventDefault;
    	};

    	handleChange = function (e) {
    		console.log("handleChange");
    		return $$invalidate(0, value = e.detail.inMinutes);
    	};

    	const writable_props = [
    		"value",
    		"style",
    		"inputStyle",
    		"type",
    		"placeholder",
    		"labelClasses",
    		"inputClasses",
    		"doubleClick",
    		"id",
    		"delay",
    		"editing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$z.warn(`<InlineEffort> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("InlineEffort", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("style" in $$props) $$invalidate(2, style = $$props.style);
    		if ("inputStyle" in $$props) $$invalidate(14, inputStyle = $$props.inputStyle);
    		if ("type" in $$props) $$invalidate(15, type = $$props.type);
    		if ("placeholder" in $$props) $$invalidate(16, placeholder = $$props.placeholder);
    		if ("labelClasses" in $$props) $$invalidate(3, labelClasses = $$props.labelClasses);
    		if ("inputClasses" in $$props) $$invalidate(17, inputClasses = $$props.inputClasses);
    		if ("doubleClick" in $$props) $$invalidate(18, doubleClick = $$props.doubleClick);
    		if ("id" in $$props) $$invalidate(4, id = $$props.id);
    		if ("delay" in $$props) $$invalidate(19, delay = $$props.delay);
    		if ("editing" in $$props) $$invalidate(1, editing = $$props.editing);
    		if ("$$scope" in $$props) $$invalidate(29, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		click,
    		clickCount,
    		clickReset,
    		delayedReset,
    		dispatch,
    		double,
    		handleBlur,
    		handleChange,
    		handleInput,
    		handleInputClick,
    		handleKeyup,
    		inputEl,
    		label,
    		originalValue,
    		single,
    		tick,
    		createEventDispatcher,
    		onMount,
    		DurationInput,
    		value,
    		style,
    		inputStyle,
    		type,
    		placeholder,
    		labelClasses,
    		inputClasses,
    		doubleClick,
    		id,
    		delay,
    		editing,
    		toggle,
    		isText,
    		isNumber
    	});

    	$$self.$inject_state = $$props => {
    		if ("click" in $$props) $$invalidate(5, click = $$props.click);
    		if ("clickCount" in $$props) clickCount = $$props.clickCount;
    		if ("clickReset" in $$props) clickReset = $$props.clickReset;
    		if ("delayedReset" in $$props) delayedReset = $$props.delayedReset;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("double" in $$props) double = $$props.double;
    		if ("handleBlur" in $$props) $$invalidate(6, handleBlur = $$props.handleBlur);
    		if ("handleChange" in $$props) $$invalidate(7, handleChange = $$props.handleChange);
    		if ("handleInput" in $$props) $$invalidate(8, handleInput = $$props.handleInput);
    		if ("handleInputClick" in $$props) $$invalidate(9, handleInputClick = $$props.handleInputClick);
    		if ("handleKeyup" in $$props) $$invalidate(10, handleKeyup = $$props.handleKeyup);
    		if ("inputEl" in $$props) inputEl = $$props.inputEl;
    		if ("label" in $$props) $$invalidate(11, label = $$props.label);
    		if ("originalValue" in $$props) originalValue = $$props.originalValue;
    		if ("single" in $$props) single = $$props.single;
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("style" in $$props) $$invalidate(2, style = $$props.style);
    		if ("inputStyle" in $$props) $$invalidate(14, inputStyle = $$props.inputStyle);
    		if ("type" in $$props) $$invalidate(15, type = $$props.type);
    		if ("placeholder" in $$props) $$invalidate(16, placeholder = $$props.placeholder);
    		if ("labelClasses" in $$props) $$invalidate(3, labelClasses = $$props.labelClasses);
    		if ("inputClasses" in $$props) $$invalidate(17, inputClasses = $$props.inputClasses);
    		if ("doubleClick" in $$props) $$invalidate(18, doubleClick = $$props.doubleClick);
    		if ("id" in $$props) $$invalidate(4, id = $$props.id);
    		if ("delay" in $$props) $$invalidate(19, delay = $$props.delay);
    		if ("editing" in $$props) $$invalidate(1, editing = $$props.editing);
    		if ("isText" in $$props) $$invalidate(12, isText = $$props.isText);
    		if ("isNumber" in $$props) $$invalidate(13, isNumber = $$props.isNumber);
    	};

    	let isText;
    	let isNumber;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*type*/ 32768) {
    			// Computed
    			 $$invalidate(12, isText = type === "text");
    		}

    		if ($$self.$$.dirty & /*type*/ 32768) {
    			 $$invalidate(13, isNumber = type === "number");
    		}

    		if ($$self.$$.dirty & /*isNumber, value, placeholder, isText*/ 77825) {
    			 if (isNumber) {
    				$$invalidate(11, label = value === "" ? placeholder : value);
    			} else if (isText) {
    				$$invalidate(11, label = value ? value : placeholder);
    			}
    		}
    	};

    	return [
    		value,
    		editing,
    		style,
    		labelClasses,
    		id,
    		click,
    		handleBlur,
    		handleChange,
    		handleInput,
    		handleInputClick,
    		handleKeyup,
    		label,
    		isText,
    		isNumber,
    		inputStyle,
    		type,
    		placeholder,
    		inputClasses,
    		doubleClick,
    		delay,
    		clickCount,
    		clickReset,
    		delayedReset,
    		dispatch,
    		double,
    		inputEl,
    		originalValue,
    		single,
    		toggle,
    		$$scope,
    		$$slots
    	];
    }

    class InlineEffort extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$17, create_fragment$17, safe_not_equal, {
    			value: 0,
    			style: 2,
    			inputStyle: 14,
    			type: 15,
    			placeholder: 16,
    			labelClasses: 3,
    			inputClasses: 17,
    			doubleClick: 18,
    			id: 4,
    			delay: 19,
    			editing: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InlineEffort",
    			options,
    			id: create_fragment$17.name
    		});
    	}

    	get value() {
    		throw new Error("<InlineEffort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<InlineEffort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<InlineEffort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<InlineEffort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputStyle() {
    		throw new Error("<InlineEffort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputStyle(value) {
    		throw new Error("<InlineEffort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<InlineEffort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<InlineEffort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<InlineEffort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<InlineEffort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelClasses() {
    		throw new Error("<InlineEffort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelClasses(value) {
    		throw new Error("<InlineEffort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputClasses() {
    		throw new Error("<InlineEffort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputClasses(value) {
    		throw new Error("<InlineEffort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get doubleClick() {
    		throw new Error("<InlineEffort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set doubleClick(value) {
    		throw new Error("<InlineEffort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<InlineEffort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<InlineEffort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get delay() {
    		throw new Error("<InlineEffort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set delay(value) {
    		throw new Error("<InlineEffort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get editing() {
    		throw new Error("<InlineEffort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set editing(value) {
    		throw new Error("<InlineEffort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Popovers\TimeEntryDate.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$c } = globals;
    const file$11 = "src\\svelte\\pages\\_Common\\Popovers\\TimeEntryDate.svelte";

    // (137:6) {:else}
    function create_else_block_2$1(ctx) {
    	let a;
    	let em;
    	let t;
    	let current;
    	let if_block = !/*isListItem*/ ctx[0] && create_if_block_3$6(ctx);

    	const relativedateformat = new RelativeDateFormat({
    			props: {
    				value: /*dueDate*/ ctx[3](/*newValue*/ ctx[4])
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			em = element("em");
    			if (if_block) if_block.c();
    			t = space();
    			create_component(relativedateformat.$$.fragment);
    			add_location(em, file$11, 137, 40, 2754);
    			attr_dev(a, "duedate", "");
    			attr_dev(a, "state", /*state*/ ctx[9]);
    			attr_dev(a, "islistitem", /*isListItem*/ ctx[0]);
    			attr_dev(a, "class", "svelte-91s7gv");
    			add_location(a, file$11, 137, 8, 2722);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, em);
    			if (if_block) if_block.m(em, null);
    			append_dev(em, t);
    			mount_component(relativedateformat, em, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*isListItem*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$6(ctx);
    					if_block.c();
    					if_block.m(em, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const relativedateformat_changes = {};
    			if (dirty & /*dueDate, newValue*/ 24) relativedateformat_changes.value = /*dueDate*/ ctx[3](/*newValue*/ ctx[4]);
    			relativedateformat.$set(relativedateformat_changes);

    			if (!current || dirty & /*state*/ 512) {
    				attr_dev(a, "state", /*state*/ ctx[9]);
    			}

    			if (!current || dirty & /*isListItem*/ 1) {
    				attr_dev(a, "islistitem", /*isListItem*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(relativedateformat.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(relativedateformat.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block) if_block.d();
    			destroy_component(relativedateformat);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(137:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (131:6) {#if newValue == null}
    function create_if_block_1$k(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*isListItem*/ ctx[0]) return create_if_block_2$8;
    		return create_else_block_1$6;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$k.name,
    		type: "if",
    		source: "(131:6) {#if newValue == null}",
    		ctx
    	});

    	return block;
    }

    // (139:10) {#if !isListItem}
    function create_if_block_3$6(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text("Due");
    			attr_dev(span, "duedate", "");
    			attr_dev(span, "state", /*state*/ ctx[9]);
    			attr_dev(span, "class", "svelte-91s7gv");
    			add_location(span, file$11, 139, 12, 2799);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*state*/ 512) {
    				attr_dev(span, "state", /*state*/ ctx[9]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(139:10) {#if !isListItem}",
    		ctx
    	});

    	return block;
    }

    // (134:8) {:else}
    function create_else_block_1$6(ctx) {
    	let a;
    	let em;

    	const block = {
    		c: function create() {
    			a = element("a");
    			em = element("em");
    			em.textContent = "No Due Date specified";
    			add_location(em, file$11, 134, 42, 2651);
    			attr_dev(a, "duedate", "");
    			attr_dev(a, "state", /*state*/ ctx[9]);
    			attr_dev(a, "islistitem", /*isListItem*/ ctx[0]);
    			attr_dev(a, "class", "svelte-91s7gv");
    			add_location(a, file$11, 134, 10, 2619);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, em);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*state*/ 512) {
    				attr_dev(a, "state", /*state*/ ctx[9]);
    			}

    			if (dirty & /*isListItem*/ 1) {
    				attr_dev(a, "islistitem", /*isListItem*/ ctx[0]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$6.name,
    		type: "else",
    		source: "(134:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (132:8) {#if isListItem}
    function create_if_block_2$8(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			attr_dev(path0, "fill", "none");
    			add_location(path0, file$11, 132, 93, 2465);
    			attr_dev(path1, "d", "M22 3h-3V1h-2v2H7V1H5v2H2v20h20V3zm-2 18H4V8h16v13z");
    			attr_dev(path1, "fill", "var(--gray)");
    			add_location(path1, file$11, 132, 132, 2504);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "width", "24");
    			add_location(svg, file$11, 132, 10, 2382);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(132:8) {#if isListItem}",
    		ctx
    	});

    	return block;
    }

    // (155:12) {:else}
    function create_else_block$m(ctx) {
    	let current;

    	const relativedateformat = new RelativeDateFormat({
    			props: {
    				value: /*dueDate*/ ctx[3](/*newValue*/ ctx[4])
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(relativedateformat.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(relativedateformat, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const relativedateformat_changes = {};
    			if (dirty & /*dueDate, newValue*/ 24) relativedateformat_changes.value = /*dueDate*/ ctx[3](/*newValue*/ ctx[4]);
    			relativedateformat.$set(relativedateformat_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(relativedateformat.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(relativedateformat.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(relativedateformat, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$m.name,
    		type: "else",
    		source: "(155:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (153:12) {#if newValue == null}
    function create_if_block$D(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No Due Date");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$D.name,
    		type: "if",
    		source: "(153:12) {#if newValue == null}",
    		ctx
    	});

    	return block;
    }

    // (152:10) <RowCell flex="flex" style="padding: 4px 0px 4px 8px">
    function create_default_slot_6$2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$D, create_else_block$m];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*newValue*/ ctx[4] == null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(152:10) <RowCell flex=\\\"flex\\\" style=\\\"padding: 4px 0px 4px 8px\\\">",
    		ctx
    	});

    	return block;
    }

    // (159:10) <RowCell>
    function create_default_slot_5$3(ctx) {
    	let button;
    	let svg;
    	let path0;
    	let path1;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			add_location(path0, file$11, 160, 97, 3516);
    			attr_dev(path1, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z");
    			attr_dev(path1, "class", "fill");
    			add_location(path1, file$11, 160, 136, 3555);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$11, 160, 14, 3433);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "icon", "");
    			add_location(button, file$11, 159, 12, 3374);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*clear*/ ctx[2])) /*clear*/ ctx[2].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(159:10) <RowCell>",
    		ctx
    	});

    	return block;
    }

    // (151:8) <Row>
    function create_default_slot_4$3(ctx) {
    	let t;
    	let current;

    	const rowcell0 = new RowCell({
    			props: {
    				flex: "flex",
    				style: "padding: 4px 0px 4px 8px",
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const rowcell1 = new RowCell({
    			props: {
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(rowcell0.$$.fragment);
    			t = space();
    			create_component(rowcell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rowcell0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(rowcell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const rowcell0_changes = {};

    			if (dirty & /*$$scope, newValue, dueDate*/ 524312) {
    				rowcell0_changes.$$scope = { dirty, ctx };
    			}

    			rowcell0.$set(rowcell0_changes);
    			const rowcell1_changes = {};

    			if (dirty & /*$$scope, clear*/ 524292) {
    				rowcell1_changes.$$scope = { dirty, ctx };
    			}

    			rowcell1.$set(rowcell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rowcell0.$$.fragment, local);
    			transition_in(rowcell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rowcell0.$$.fragment, local);
    			transition_out(rowcell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rowcell0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(rowcell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(151:8) <Row>",
    		ctx
    	});

    	return block;
    }

    // (150:6) <ColumnCell>
    function create_default_slot_3$4(ctx) {
    	let current;

    	const row = new Row({
    			props: {
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(row.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(row, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const row_changes = {};

    			if (dirty & /*$$scope, clear, newValue, dueDate*/ 524316) {
    				row_changes.$$scope = { dirty, ctx };
    			}

    			row.$set(row_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(row.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(row.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(row, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(150:6) <ColumnCell>",
    		ctx
    	});

    	return block;
    }

    // (166:6) <ColumnCell>
    function create_default_slot_2$8(ctx) {
    	let div;
    	let updating_value;
    	let current;

    	function calendar_value_binding(value) {
    		/*calendar_value_binding*/ ctx[16].call(null, value);
    	}

    	let calendar_props = {};

    	if (/*newValue*/ ctx[4] !== void 0) {
    		calendar_props.value = /*newValue*/ ctx[4];
    	}

    	const calendar = new Calendar({ props: calendar_props, $$inline: true });
    	binding_callbacks.push(() => bind(calendar, "value", calendar_value_binding));

    	calendar.$on("change", function () {
    		if (is_function(/*setDate*/ ctx[5])) /*setDate*/ ctx[5].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(calendar.$$.fragment);
    			attr_dev(div, "calendar", "");
    			attr_dev(div, "class", "svelte-91s7gv");
    			add_location(div, file$11, 166, 8, 3801);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(calendar, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const calendar_changes = {};

    			if (!updating_value && dirty & /*newValue*/ 16) {
    				updating_value = true;
    				calendar_changes.value = /*newValue*/ ctx[4];
    				add_flush_callback(() => updating_value = false);
    			}

    			calendar.$set(calendar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(calendar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(calendar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(calendar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(166:6) <ColumnCell>",
    		ctx
    	});

    	return block;
    }

    // (149:4) <Column>
    function create_default_slot_1$b(ctx) {
    	let t;
    	let current;

    	const columncell0 = new ColumnCell({
    			props: {
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const columncell1 = new ColumnCell({
    			props: {
    				$$slots: { default: [create_default_slot_2$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(columncell0.$$.fragment);
    			t = space();
    			create_component(columncell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(columncell0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(columncell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const columncell0_changes = {};

    			if (dirty & /*$$scope, clear, newValue, dueDate*/ 524316) {
    				columncell0_changes.$$scope = { dirty, ctx };
    			}

    			columncell0.$set(columncell0_changes);
    			const columncell1_changes = {};

    			if (dirty & /*$$scope, newValue, setDate*/ 524336) {
    				columncell1_changes.$$scope = { dirty, ctx };
    			}

    			columncell1.$set(columncell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(columncell0.$$.fragment, local);
    			transition_in(columncell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(columncell0.$$.fragment, local);
    			transition_out(columncell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(columncell0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(columncell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(149:4) <Column>",
    		ctx
    	});

    	return block;
    }

    // (148:2) <Popover bind:show={show} on:close={cancel} bind:trigger={triggerRef} width="240px" align="right">
    function create_default_slot$v(ctx) {
    	let current;

    	const column = new Column({
    			props: {
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(column.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(column, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const column_changes = {};

    			if (dirty & /*$$scope, newValue, setDate, clear, dueDate*/ 524348) {
    				column_changes.$$scope = { dirty, ctx };
    			}

    			column.$set(column_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(column.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(column.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(column, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$v.name,
    		type: "slot",
    		source: "(148:2) <Popover bind:show={show} on:close={cancel} bind:trigger={triggerRef} width=\\\"240px\\\" align=\\\"right\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$18(ctx) {
    	let div1;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let updating_show;
    	let updating_trigger;
    	let current;
    	let dispose;
    	const if_block_creators = [create_if_block_1$k, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*newValue*/ ctx[4] == null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	function popover_show_binding(value) {
    		/*popover_show_binding*/ ctx[17].call(null, value);
    	}

    	function popover_trigger_binding(value) {
    		/*popover_trigger_binding*/ ctx[18].call(null, value);
    	}

    	let popover_props = {
    		width: "240px",
    		align: "right",
    		$$slots: { default: [create_default_slot$v] },
    		$$scope: { ctx }
    	};

    	if (/*show*/ ctx[6] !== void 0) {
    		popover_props.show = /*show*/ ctx[6];
    	}

    	if (/*triggerRef*/ ctx[8] !== void 0) {
    		popover_props.trigger = /*triggerRef*/ ctx[8];
    	}

    	const popover = new Popover({ props: popover_props, $$inline: true });
    	binding_callbacks.push(() => bind(popover, "show", popover_show_binding));
    	binding_callbacks.push(() => bind(popover, "trigger", popover_trigger_binding));

    	popover.$on("close", function () {
    		if (is_function(/*cancel*/ ctx[1])) /*cancel*/ ctx[1].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if_block.c();
    			t = space();
    			create_component(popover.$$.fragment);
    			add_location(div0, file$11, 128, 2, 2264);
    			add_location(div1, file$11, 127, 0, 2256);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			/*div0_binding*/ ctx[15](div0);
    			append_dev(div1, t);
    			mount_component(popover, div1, null);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				div0,
    				"click",
    				function () {
    					if (is_function(/*triggerClick*/ ctx[7])) /*triggerClick*/ ctx[7].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			const popover_changes = {};

    			if (dirty & /*$$scope, newValue, setDate, clear, dueDate*/ 524348) {
    				popover_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_show && dirty & /*show*/ 64) {
    				updating_show = true;
    				popover_changes.show = /*show*/ ctx[6];
    				add_flush_callback(() => updating_show = false);
    			}

    			if (!updating_trigger && dirty & /*triggerRef*/ 256) {
    				updating_trigger = true;
    				popover_changes.trigger = /*triggerRef*/ ctx[8];
    				add_flush_callback(() => updating_trigger = false);
    			}

    			popover.$set(popover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(popover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(popover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    			/*div0_binding*/ ctx[15](null);
    			destroy_component(popover);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	var cancel,
    		clear,
    		dispatch,
    		dueDate,
    		dueDateState,
    		newValue,
    		save,
    		setDate,
    		show,
    		triggerClick,
    		triggerRef;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	var { value = null } = $$props;
    	var { isListItem = true } = $$props;
    	newValue = void 0;

    	// menu
    	show = false;

    	triggerClick = function () {
    		dispatch("open");
    		return $$invalidate(6, show = true);
    	};

    	triggerRef = void 0;

    	setDate = function (e) {
    		$$invalidate(4, newValue = e.detail);
    		save();
    		return cancel();
    	};

    	cancel = function () {
    		$$invalidate(6, show = false);
    		dispatch("close");
    		return $$invalidate(4, newValue = value);
    	};

    	save = function () {
    		$$invalidate(6, show = false);
    		dispatch("close");
    		return dispatch("update", { id: item.id, due_date: newValue });
    	};

    	clear = function () {
    		$$invalidate(4, newValue = null);
    		return save();
    	};

    	dueDate = function (due_date) {
    		if (due_date != null) {
    			if (Object.isDate(due_date)) {
    				return due_date;
    			} else {
    				return Date.create(due_date);
    			}
    		} else {
    			return due_date;
    		}
    	};

    	dueDateState = function (item, date) {
    		if (date != null) {
    			if (item.percent_complete === 100) {
    				return "complete";
    			} else {
    				if (Object.isDate(date)) {
    					return date.comparedTo(Date.create());
    				} else {
    					return Date.create(date).comparedTo(Date.create());
    				}
    			}
    		} else {
    			return "before";
    		}
    	};

    	const writable_props = ["item", "value", "isListItem"];

    	Object_1$c.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TimeEntryDate> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TimeEntryDate", $$slots, []);

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(8, triggerRef = $$value);
    		});
    	}

    	function calendar_value_binding(value$1) {
    		newValue = value$1;
    		($$invalidate(4, newValue), $$invalidate(11, value));
    	}

    	function popover_show_binding(value) {
    		show = value;
    		$$invalidate(6, show);
    	}

    	function popover_trigger_binding(value) {
    		triggerRef = value;
    		$$invalidate(8, triggerRef);
    	}

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(10, item = $$props.item);
    		if ("value" in $$props) $$invalidate(11, value = $$props.value);
    		if ("isListItem" in $$props) $$invalidate(0, isListItem = $$props.isListItem);
    	};

    	$$self.$capture_state = () => ({
    		cancel,
    		clear,
    		dispatch,
    		dueDate,
    		dueDateState,
    		newValue,
    		save,
    		setDate,
    		show,
    		triggerClick,
    		triggerRef,
    		createEventDispatcher,
    		item,
    		value,
    		isListItem,
    		Popover,
    		Column,
    		ColumnCell,
    		Row,
    		RowCell,
    		Calendar,
    		RelativeDateFormat,
    		state
    	});

    	$$self.$inject_state = $$props => {
    		if ("cancel" in $$props) $$invalidate(1, cancel = $$props.cancel);
    		if ("clear" in $$props) $$invalidate(2, clear = $$props.clear);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("dueDate" in $$props) $$invalidate(3, dueDate = $$props.dueDate);
    		if ("dueDateState" in $$props) $$invalidate(13, dueDateState = $$props.dueDateState);
    		if ("newValue" in $$props) $$invalidate(4, newValue = $$props.newValue);
    		if ("save" in $$props) save = $$props.save;
    		if ("setDate" in $$props) $$invalidate(5, setDate = $$props.setDate);
    		if ("show" in $$props) $$invalidate(6, show = $$props.show);
    		if ("triggerClick" in $$props) $$invalidate(7, triggerClick = $$props.triggerClick);
    		if ("triggerRef" in $$props) $$invalidate(8, triggerRef = $$props.triggerRef);
    		if ("item" in $$props) $$invalidate(10, item = $$props.item);
    		if ("value" in $$props) $$invalidate(11, value = $$props.value);
    		if ("isListItem" in $$props) $$invalidate(0, isListItem = $$props.isListItem);
    		if ("state" in $$props) $$invalidate(9, state = $$props.state);
    	};

    	let state;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 2048) {
    			 $$invalidate(4, newValue = value);
    		}

    		if ($$self.$$.dirty & /*dueDateState, item, newValue*/ 9232) {
    			 $$invalidate(9, state = dueDateState(item, newValue));
    		}
    	};

    	return [
    		isListItem,
    		cancel,
    		clear,
    		dueDate,
    		newValue,
    		setDate,
    		show,
    		triggerClick,
    		triggerRef,
    		state,
    		item,
    		value,
    		dispatch,
    		dueDateState,
    		save,
    		div0_binding,
    		calendar_value_binding,
    		popover_show_binding,
    		popover_trigger_binding
    	];
    }

    class TimeEntryDate extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$18, safe_not_equal, { item: 10, value: 11, isListItem: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TimeEntryDate",
    			options,
    			id: create_fragment$18.name
    		});
    	}

    	get item() {
    		throw new Error("<TimeEntryDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<TimeEntryDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<TimeEntryDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<TimeEntryDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isListItem() {
    		throw new Error("<TimeEntryDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isListItem(value) {
    		throw new Error("<TimeEntryDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Sections\Time.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$d, console: console_1$A } = globals;
    const file$12 = "src\\svelte\\pages\\_Common\\Sections\\Time.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[24] = list[i];
    	child_ctx[25] = list;
    	child_ctx[26] = i;
    	return child_ctx;
    }

    // (224:2) {#if list && list.length}
    function create_if_block$E(ctx) {
    	let div;
    	let current;
    	let each_value = /*list*/ ctx[7];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$12, 224, 4, 5165);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*list, updateAttribute, destroy, project, save, state, style, label, Date*/ 134217978) {
    				each_value = /*list*/ ctx[7];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$E.name,
    		type: "if",
    		source: "(224:2) {#if list && list.length}",
    		ctx
    	});

    	return block;
    }

    // (246:18) <InlineInput bind:value={timeItem.effort_minutes} on:update={updateAttribute({detail: {id: timeItem.id, effort_minutes: timeItem.effort_minutes}})}  {style} let:label>
    function create_default_slot_3$5(ctx) {
    	let current;

    	const effortformat = new EffortFormat({
    			props: { value: /*label*/ ctx[27] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(effortformat.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(effortformat, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const effortformat_changes = {};
    			if (dirty & /*label*/ 134217728) effortformat_changes.value = /*label*/ ctx[27];
    			effortformat.$set(effortformat_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(effortformat.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(effortformat.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(effortformat, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(246:18) <InlineInput bind:value={timeItem.effort_minutes} on:update={updateAttribute({detail: {id: timeItem.id, effort_minutes: timeItem.effort_minutes}})}  {style} let:label>",
    		ctx
    	});

    	return block;
    }

    // (250:16) {#if (timeItem.memo || "").length > 0}
    function create_if_block_2$9(ctx) {
    	let div;
    	let current;

    	const tooltip = new Tooltip({
    			props: {
    				content: "Has content",
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tooltip.$$.fragment);
    			attr_dev(div, "flex", "initial");
    			add_location(div, file$12, 250, 18, 6254);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tooltip, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tooltip_changes = {};

    			if (dirty & /*$$scope*/ 268435456) {
    				tooltip_changes.$$scope = { dirty, ctx };
    			}

    			tooltip.$set(tooltip_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tooltip.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tooltip.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tooltip);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(250:16) {#if (timeItem.memo || \\\"\\\").length > 0}",
    		ctx
    	});

    	return block;
    }

    // (252:20) <Tooltip content="Has content">
    function create_default_slot_2$9(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "d", "M0 0h24v24H0V0z");
    			attr_dev(path0, "fill", "none");
    			add_location(path0, file$12, 252, 113, 6440);
    			attr_dev(path1, "d", "M14 2H4v20h16V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z");
    			attr_dev(path1, "class", "fill svelte-1g3owgp");
    			add_location(path1, file$12, 252, 152, 6479);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "state", state);
    			attr_dev(svg, "class", "svelte-1g3owgp");
    			add_location(svg, file$12, 252, 22, 6349);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(252:20) <Tooltip content=\\\"Has content\\\">",
    		ctx
    	});

    	return block;
    }

    // (261:16) {#if (project.assignments.length > 0)}
    function create_if_block_1$l(ctx) {
    	let div;
    	let div_present_value;
    	let current;

    	const assignmentpopover = new Assignment$1({
    			props: {
    				project: /*project*/ ctx[1],
    				item: /*timeItem*/ ctx[24],
    				value: /*timeItem*/ ctx[24].assigned_to_id
    			},
    			$$inline: true
    		});

    	assignmentpopover.$on("save", function () {
    		if (is_function(/*save*/ ctx[4])) /*save*/ ctx[4].apply(this, arguments);
    	});

    	assignmentpopover.$on("open", /*open_handler_1*/ ctx[22]);
    	assignmentpopover.$on("close", /*close_handler_1*/ ctx[23]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(assignmentpopover.$$.fragment);
    			attr_dev(div, "flex", "initial");
    			attr_dev(div, "present", div_present_value = false);
    			add_location(div, file$12, 261, 18, 6806);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(assignmentpopover, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const assignmentpopover_changes = {};
    			if (dirty & /*project*/ 2) assignmentpopover_changes.project = /*project*/ ctx[1];
    			if (dirty & /*list*/ 128) assignmentpopover_changes.item = /*timeItem*/ ctx[24];
    			if (dirty & /*list*/ 128) assignmentpopover_changes.value = /*timeItem*/ ctx[24].assigned_to_id;
    			assignmentpopover.$set(assignmentpopover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(assignmentpopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(assignmentpopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(assignmentpopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$l.name,
    		type: "if",
    		source: "(261:16) {#if (project.assignments.length > 0)}",
    		ctx
    	});

    	return block;
    }

    // (270:10) <div slot="menu">
    function create_menu_slot$4(ctx) {
    	let div;
    	let current;

    	const menu = new TimeEntry$2({
    			props: { item: /*timeItem*/ ctx[24] },
    			$$inline: true
    		});

    	menu.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[6])) /*updateAttribute*/ ctx[6].apply(this, arguments);
    	});

    	menu.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[3])) /*destroy*/ ctx[3].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(menu.$$.fragment);
    			attr_dev(div, "slot", "menu");
    			add_location(div, file$12, 269, 10, 7069);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(menu, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const menu_changes = {};
    			if (dirty & /*list*/ 128) menu_changes.item = /*timeItem*/ ctx[24];
    			menu.$set(menu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(menu);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_menu_slot$4.name,
    		type: "slot",
    		source: "(270:10) <div slot=\\\"menu\\\">",
    		ctx
    	});

    	return block;
    }

    // (228:8) <HoverableItem item={timeItem} index={index}>
    function create_default_slot_1$c(ctx) {
    	let div7;
    	let div5;
    	let div4;
    	let div0;
    	let t0;
    	let div1;
    	let a;
    	let em;
    	let t1_value = Date.create(/*timeItem*/ ctx[24].booking_date).dbDate() + "";
    	let t1;
    	let t2;
    	let div2;
    	let span;
    	let t3;
    	let div3;
    	let updating_value;
    	let t4;
    	let t5;
    	let div6;
    	let t6;
    	let t7;
    	let current;

    	const timeentrydatepopover = new TimeEntryDate({
    			props: {
    				item: /*timeItem*/ ctx[24],
    				value: /*timeItem*/ ctx[24].booking_date
    			},
    			$$inline: true
    		});

    	timeentrydatepopover.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[6])) /*updateAttribute*/ ctx[6].apply(this, arguments);
    	});

    	timeentrydatepopover.$on("open", /*open_handler*/ ctx[19]);
    	timeentrydatepopover.$on("close", /*close_handler*/ ctx[20]);

    	function inlineinput_value_binding(value) {
    		/*inlineinput_value_binding*/ ctx[21].call(null, value, /*timeItem*/ ctx[24]);
    	}

    	let inlineinput_props = {
    		style: /*style*/ ctx[5],
    		$$slots: {
    			default: [
    				create_default_slot_3$5,
    				({ label }) => ({ 27: label }),
    				({ label }) => label ? 134217728 : 0
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*timeItem*/ ctx[24].effort_minutes !== void 0) {
    		inlineinput_props.value = /*timeItem*/ ctx[24].effort_minutes;
    	}

    	const inlineinput = new InlineEffort({ props: inlineinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(inlineinput, "value", inlineinput_value_binding));

    	inlineinput.$on("update", function () {
    		if (is_function(/*updateAttribute*/ ctx[6]({
    			detail: {
    				id: /*timeItem*/ ctx[24].id,
    				effort_minutes: /*timeItem*/ ctx[24].effort_minutes
    			}
    		}))) /*updateAttribute*/ ctx[6]({
    			detail: {
    				id: /*timeItem*/ ctx[24].id,
    				effort_minutes: /*timeItem*/ ctx[24].effort_minutes
    			}
    		}).apply(this, arguments);
    	});

    	let if_block0 = (/*timeItem*/ ctx[24].memo || "").length > 0 && create_if_block_2$9(ctx);
    	let if_block1 = /*project*/ ctx[1].assignments.length > 0 && create_if_block_1$l(ctx);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			create_component(timeentrydatepopover.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			a = element("a");
    			em = element("em");
    			t1 = text(t1_value);
    			t2 = space();
    			div2 = element("div");
    			span = element("span");
    			t3 = space();
    			div3 = element("div");
    			create_component(inlineinput.$$.fragment);
    			t4 = space();
    			if (if_block0) if_block0.c();
    			t5 = space();
    			div6 = element("div");
    			if (if_block1) if_block1.c();
    			t6 = space();
    			t7 = space();
    			attr_dev(div0, "flex", "initial");
    			attr_dev(div0, "section", "due-date");
    			add_location(div0, file$12, 233, 16, 5391);
    			add_location(em, file$12, 238, 20, 5666);
    			attr_dev(a, "class", "svelte-1g3owgp");
    			add_location(a, file$12, 237, 18, 5642);
    			attr_dev(div1, "flex", "initial");
    			add_location(div1, file$12, 236, 16, 5603);
    			attr_dev(span, "spacer", "");
    			add_location(span, file$12, 243, 36, 5825);
    			attr_dev(div2, "flex", "initial");
    			add_location(div2, file$12, 243, 16, 5805);
    			attr_dev(div3, "flex", "flex");
    			attr_dev(div3, "ellipsis", "");
    			add_location(div3, file$12, 244, 16, 5862);
    			attr_dev(div4, "layout", "row");
    			add_location(div4, file$12, 232, 14, 5356);
    			attr_dev(div5, "flex", "flex");
    			add_location(div5, file$12, 231, 12, 5324);
    			attr_dev(div6, "flex", "initial");
    			add_location(div6, file$12, 259, 12, 6712);
    			attr_dev(div7, "layout", "row");
    			attr_dev(div7, "type", "list-item");
    			attr_dev(div7, "class", "svelte-1g3owgp");
    			add_location(div7, file$12, 228, 10, 5274);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			mount_component(timeentrydatepopover, div0, null);
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div1, a);
    			append_dev(a, em);
    			append_dev(em, t1);
    			append_dev(div4, t2);
    			append_dev(div4, div2);
    			append_dev(div2, span);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			mount_component(inlineinput, div3, null);
    			append_dev(div4, t4);
    			if (if_block0) if_block0.m(div4, null);
    			append_dev(div7, t5);
    			append_dev(div7, div6);
    			if (if_block1) if_block1.m(div6, null);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, t7, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const timeentrydatepopover_changes = {};
    			if (dirty & /*list*/ 128) timeentrydatepopover_changes.item = /*timeItem*/ ctx[24];
    			if (dirty & /*list*/ 128) timeentrydatepopover_changes.value = /*timeItem*/ ctx[24].booking_date;
    			timeentrydatepopover.$set(timeentrydatepopover_changes);
    			if ((!current || dirty & /*list*/ 128) && t1_value !== (t1_value = Date.create(/*timeItem*/ ctx[24].booking_date).dbDate() + "")) set_data_dev(t1, t1_value);
    			const inlineinput_changes = {};
    			if (dirty & /*style*/ 32) inlineinput_changes.style = /*style*/ ctx[5];

    			if (dirty & /*$$scope, label*/ 402653184) {
    				inlineinput_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty & /*list*/ 128) {
    				updating_value = true;
    				inlineinput_changes.value = /*timeItem*/ ctx[24].effort_minutes;
    				add_flush_callback(() => updating_value = false);
    			}

    			inlineinput.$set(inlineinput_changes);

    			if ((/*timeItem*/ ctx[24].memo || "").length > 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*list*/ 128) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$9(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div4, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*project*/ ctx[1].assignments.length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*project*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$l(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div6, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(timeentrydatepopover.$$.fragment, local);
    			transition_in(inlineinput.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(timeentrydatepopover.$$.fragment, local);
    			transition_out(inlineinput.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_component(timeentrydatepopover);
    			destroy_component(inlineinput);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(t7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(228:8) <HoverableItem item={timeItem} index={index}>",
    		ctx
    	});

    	return block;
    }

    // (227:6) {#each list as timeItem, index}
    function create_each_block$f(ctx) {
    	let current;

    	const hoverableitem = new HoverableItem({
    			props: {
    				item: /*timeItem*/ ctx[24],
    				index: /*index*/ ctx[26],
    				$$slots: {
    					default: [create_default_slot_1$c],
    					menu: [create_menu_slot$4]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hoverableitem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hoverableitem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hoverableitem_changes = {};
    			if (dirty & /*list*/ 128) hoverableitem_changes.item = /*timeItem*/ ctx[24];

    			if (dirty & /*$$scope, list, updateAttribute, destroy, project, save, style*/ 268435706) {
    				hoverableitem_changes.$$scope = { dirty, ctx };
    			}

    			hoverableitem.$set(hoverableitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hoverableitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hoverableitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hoverableitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(227:6) {#each list as timeItem, index}",
    		ctx
    	});

    	return block;
    }

    // (222:0) <Section name={collection.titleize()} {open}>
    function create_default_slot$w(ctx) {
    	let t;
    	let current;
    	let if_block = /*list*/ ctx[7] && /*list*/ ctx[7].length && create_if_block$E(ctx);

    	const quickentry = new TimeEntry$1({
    			props: { stubPlaceholder: "Add Time Entry" },
    			$$inline: true
    		});

    	quickentry.$on("add", function () {
    		if (is_function(/*add*/ ctx[2])) /*add*/ ctx[2].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(quickentry.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(quickentry, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*list*/ ctx[7] && /*list*/ ctx[7].length) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*list*/ 128) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$E(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(quickentry.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(quickentry.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(quickentry, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$w.name,
    		type: "slot",
    		source: "(222:0) <Section name={collection.titleize()} {open}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$19(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				name: /*collection*/ ctx[0].titleize(),
    				open,
    				$$slots: { default: [create_default_slot$w] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const section_changes = {};
    			if (dirty & /*collection*/ 1) section_changes.name = /*collection*/ ctx[0].titleize();

    			if (dirty & /*$$scope, add, list, updateAttribute, destroy, project, save, style*/ 268435710) {
    				section_changes.$$scope = { dirty, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	var add,
    		destroy,
    		dispatch,
    		dropEvent,
    		save,
    		saveName,
    		sort,
    		style,
    		subDocument,
    		update,
    		updateAttribute,
    		updateName;

    	dispatch = createEventDispatcher();
    	var { assignments = [] } = $$props;
    	var { collection = "time_entries" } = $$props;
    	var { item = void 0 } = $$props;
    	var { listId = uuid() } = $$props;
    	var { sameListOnly = true } = $$props;
    	var { project = void 0 } = $$props;
    	subDocument = new time_entry();

    	onMount(function () {
    		switch (collection) {
    			case "tasks":
    				subDocument = new Task();
    				break;
    			case "documents":
    				subDocument = new Document();
    				break;
    			case "assignments":
    				subDocument = new Assignment();
    		}

    		// }
    		return console.log(item[collection]);
    	});

    	updateName = function (e) {
    		var change;
    		console.log(e.detail);
    		change = { id: item.id, name: e.detail };
    		return dispatch("update", change);
    	};

    	updateAttribute = function (e) {
    		var change, changedTask;
    		console.log("Time.svelte updateAttribute");
    		console.log(e.detail);
    		change = e.detail;

    		// change["id"] = item.id
    		changedTask = item[collection].find({ id: change.id });

    		Object.merge(changedTask, change);
    		$$invalidate(8, item);
    		console.log(change);
    		return dispatch("update", change);
    	};

    	update = function () {
    		return dispatch("update");
    	};

    	add = function (event) {
    		var newRecord;
    		newRecord = subDocument.stub(event.detail);
    		newRecord.ordinal = (item[collection] || []).length;
    		$$invalidate(8, item[collection] = item[collection].add(newRecord), item);
    		return dispatch("update");
    	};

    	saveName = function (e) {
    		var change;
    		change = { id: item.id, name: e.detail };
    		return dispatch("update", change);
    	};

    	save = function (e) {
    		var change;
    		change = e.detail;
    		change["id"] = item.id;
    		return dispatch("update", change);
    	};

    	destroy = function (e) {
    		var showDeleteConfirmation;
    		console.log("Time.destroy");
    		console.log(e.detail);
    		item[collection].remove({ id: e.detail.id });
    		$$invalidate(8, item);
    		dispatch("update");
    		return showDeleteConfirmation = false;
    	};

    	style = ":hover {font-weight: bold}";

    	dropEvent = function (e) {
    		var dragged, dropped, refresh;
    		refresh = true;

    		if (e.detail.divider != null) {
    			console.log("shift ordinals");

    			// up or down?
    			if (e.detail.dragIndex !== e.detail.dropIndex) {
    				if (e.detail.dropIndex < e.detail.dragIndex) {
    					item[collection].forEach(function (item) {
    						if (item.ordinal >= e.detail.dropIndex) {
    							return item.ordinal = item.ordinal + 1;
    						}
    					});

    					dragged = item[collection].find({ id: e.detail.dragItem.id });
    					dragged.ordinal = e.detail.dropIndex;
    				} else {
    					item[collection].forEach(function (item) {
    						if (item.ordinal <= e.detail.dropIndex) {
    							return item.ordinal = item.ordinal - 1;
    						}
    					});

    					dragged = item[collection].find({ id: e.detail.dragItem.id });
    					dragged.ordinal = e.detail.dropIndex - 1;
    				}
    			} else {
    				refresh = false;
    			}
    		} else {
    			dragged = item[collection].find({ id: e.detail.dragItem.id });
    			dropped = item[collection].find({ id: e.detail.dropItem.id });
    			dragged.ordinal = e.detail.dropItem.ordinal;
    			dropped.ordinal = e.detail.dragItem.ordinal;
    		}

    		// cleanup ordinals in case there are stragglers
    		item[collection].sortBy("ordinal");

    		item[collection].forEach(function (item, index) {
    			return item.ordinal = index;
    		});

    		//#console.log "---before"
    		//console.log item[collection]
    		$$invalidate(8, item);

    		//console.log "sorted and fixed"
    		//console.log item[collection]
    		if (refresh) {
    			return dispatch("update");
    		}
    	};

    	sort = function (list) {
    		if (item[collection] != null) {
    			return item[collection].sortBy("ordinal");
    		} else {
    			return [];
    		}
    	};

    	const writable_props = ["assignments", "collection", "item", "listId", "sameListOnly", "project"];

    	Object_1$d.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$A.warn(`<Time> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Time", $$slots, []);

    	function open_handler(event) {
    		bubble($$self, event);
    	}

    	function close_handler(event) {
    		bubble($$self, event);
    	}

    	function inlineinput_value_binding(value, timeItem) {
    		timeItem.effort_minutes = value;
    		((($$invalidate(7, list), $$invalidate(15, sort)), $$invalidate(8, item)), $$invalidate(0, collection));
    	}

    	function open_handler_1(event) {
    		bubble($$self, event);
    	}

    	function close_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("assignments" in $$props) $$invalidate(9, assignments = $$props.assignments);
    		if ("collection" in $$props) $$invalidate(0, collection = $$props.collection);
    		if ("item" in $$props) $$invalidate(8, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(10, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(11, sameListOnly = $$props.sameListOnly);
    		if ("project" in $$props) $$invalidate(1, project = $$props.project);
    	};

    	$$self.$capture_state = () => ({
    		add,
    		destroy,
    		dispatch,
    		dropEvent,
    		save,
    		saveName,
    		sort,
    		style,
    		subDocument,
    		update,
    		updateAttribute,
    		updateName,
    		onMount,
    		createEventDispatcher,
    		SubDocument: time_entry,
    		QuickEntry: TimeEntry$1,
    		HoverableItem,
    		Menu: TimeEntry$2,
    		InlineInput: InlineEffort,
    		Tooltip,
    		EffortFormat,
    		TimeEntryDatePopover: TimeEntryDate,
    		AssignmentPopover: Assignment$1,
    		Section,
    		assignments,
    		collection,
    		item,
    		listId,
    		sameListOnly,
    		project,
    		list
    	});

    	$$self.$inject_state = $$props => {
    		if ("add" in $$props) $$invalidate(2, add = $$props.add);
    		if ("destroy" in $$props) $$invalidate(3, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("dropEvent" in $$props) dropEvent = $$props.dropEvent;
    		if ("save" in $$props) $$invalidate(4, save = $$props.save);
    		if ("saveName" in $$props) saveName = $$props.saveName;
    		if ("sort" in $$props) $$invalidate(15, sort = $$props.sort);
    		if ("style" in $$props) $$invalidate(5, style = $$props.style);
    		if ("subDocument" in $$props) subDocument = $$props.subDocument;
    		if ("update" in $$props) update = $$props.update;
    		if ("updateAttribute" in $$props) $$invalidate(6, updateAttribute = $$props.updateAttribute);
    		if ("updateName" in $$props) updateName = $$props.updateName;
    		if ("assignments" in $$props) $$invalidate(9, assignments = $$props.assignments);
    		if ("collection" in $$props) $$invalidate(0, collection = $$props.collection);
    		if ("item" in $$props) $$invalidate(8, item = $$props.item);
    		if ("listId" in $$props) $$invalidate(10, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(11, sameListOnly = $$props.sameListOnly);
    		if ("project" in $$props) $$invalidate(1, project = $$props.project);
    		if ("list" in $$props) $$invalidate(7, list = $$props.list);
    	};

    	let list;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*sort, item, collection*/ 33025) {
    			 $$invalidate(7, list = sort(item[collection]));
    		}
    	};

    	return [
    		collection,
    		project,
    		add,
    		destroy,
    		save,
    		style,
    		updateAttribute,
    		list,
    		item,
    		assignments,
    		listId,
    		sameListOnly,
    		dispatch,
    		dropEvent,
    		saveName,
    		sort,
    		subDocument,
    		update,
    		updateName,
    		open_handler,
    		close_handler,
    		inlineinput_value_binding,
    		open_handler_1,
    		close_handler_1
    	];
    }

    class Time$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$19, create_fragment$19, safe_not_equal, {
    			assignments: 9,
    			collection: 0,
    			item: 8,
    			listId: 10,
    			sameListOnly: 11,
    			project: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Time",
    			options,
    			id: create_fragment$19.name
    		});
    	}

    	get assignments() {
    		throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set assignments(value) {
    		throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collection() {
    		throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collection(value) {
    		throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listId() {
    		throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listId(value) {
    		throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sameListOnly() {
    		throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sameListOnly(value) {
    		throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get project() {
    		throw new Error("<Time>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set project(value) {
    		throw new Error("<Time>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var defaults = createCommonjsModule(function (module) {
    function getDefaults() {
      return {
        baseUrl: null,
        breaks: false,
        gfm: true,
        headerIds: true,
        headerPrefix: '',
        highlight: null,
        langPrefix: 'language-',
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        tokenizer: null,
        xhtml: false
      };
    }

    function changeDefaults(newDefaults) {
      module.exports.defaults = newDefaults;
    }

    module.exports = {
      defaults: getDefaults(),
      getDefaults,
      changeDefaults
    };
    });
    var defaults_1 = defaults.defaults;
    var defaults_2 = defaults.getDefaults;
    var defaults_3 = defaults.changeDefaults;

    /**
     * Helpers
     */
    const escapeTest = /[&<>"']/;
    const escapeReplace = /[&<>"']/g;
    const escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    const escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    const escapeReplacements = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    const getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape$1(html, encode) {
      if (encode) {
        if (escapeTest.test(html)) {
          return html.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html)) {
          return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }

      return html;
    }

    const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;

    function unescape$1(html) {
      // explicitly match decimal, hex, and named HTML entities
      return html.replace(unescapeTest, (_, n) => {
        n = n.toLowerCase();
        if (n === 'colon') return ':';
        if (n.charAt(0) === '#') {
          return n.charAt(1) === 'x'
            ? String.fromCharCode(parseInt(n.substring(2), 16))
            : String.fromCharCode(+n.substring(1));
        }
        return '';
      });
    }

    const caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
      regex = regex.source || regex;
      opt = opt || '';
      const obj = {
        replace: (name, val) => {
          val = val.source || val;
          val = val.replace(caret, '$1');
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: () => {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }

    const nonWordAndColonTest = /[^\w:]/g;
    const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        let prot;
        try {
          prot = decodeURIComponent(unescape$1(href))
            .replace(nonWordAndColonTest, '')
            .toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, '%');
      } catch (e) {
        return null;
      }
      return href;
    }

    const baseUrls = {};
    const justDomain = /^[^:]+:\/*[^/]*$/;
    const protocol = /^([^:]+:)[\s\S]*$/;
    const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

    function resolveUrl(base, href) {
      if (!baseUrls[' ' + base]) {
        // we can ignore everything in base after the last slash of its path component,
        // but we might need to add _that_
        // https://tools.ietf.org/html/rfc3986#section-3
        if (justDomain.test(base)) {
          baseUrls[' ' + base] = base + '/';
        } else {
          baseUrls[' ' + base] = rtrim(base, '/', true);
        }
      }
      base = baseUrls[' ' + base];
      const relativeBase = base.indexOf(':') === -1;

      if (href.substring(0, 2) === '//') {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, '$1') + href;
      } else if (href.charAt(0) === '/') {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, '$1') + href;
      } else {
        return base + href;
      }
    }

    const noopTest = { exec: function noopTest() {} };

    function merge(obj) {
      let i = 1,
        target,
        key;

      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }

      return obj;
    }

    function splitCells(tableRow, count) {
      // ensure that every cell-delimiting pipe has a space
      // before it to distinguish it from an escaped pipe
      const row = tableRow.replace(/\|/g, (match, offset, str) => {
          let escaped = false,
            curr = offset;
          while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
          if (escaped) {
            // odd number of slashes means | is escaped
            // so we leave it alone
            return '|';
          } else {
            // add space before unescaped |
            return ' |';
          }
        }),
        cells = row.split(/ \|/);
      let i = 0;

      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) cells.push('');
      }

      for (; i < cells.length; i++) {
        // leading or trailing whitespace is ignored per the gfm spec
        cells[i] = cells[i].trim().replace(/\\\|/g, '|');
      }
      return cells;
    }

    // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
    // /c*$/ is vulnerable to REDOS.
    // invert: Remove suffix of non-c chars instead. Default falsey.
    function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
        return '';
      }

      // Length of suffix matching the invert condition.
      let suffLen = 0;

      // Step left until we fail to match the invert condition.
      while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }

      return str.substr(0, l - suffLen);
    }

    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      const l = str.length;
      let level = 0,
        i = 0;
      for (; i < l; i++) {
        if (str[i] === '\\') {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }

    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
      }
    }

    var helpers = {
      escape: escape$1,
      unescape: unescape$1,
      edit,
      cleanUrl,
      resolveUrl,
      noopTest,
      merge,
      splitCells,
      rtrim,
      findClosingBracket,
      checkSanitizeDeprecation
    };

    const { defaults: defaults$1 } = defaults;
    const {
      rtrim: rtrim$1,
      splitCells: splitCells$1,
      escape: escape$2,
      findClosingBracket: findClosingBracket$1
    } = helpers;

    function outputLink(cap, link, raw) {
      const href = link.href;
      const title = link.title ? escape$2(link.title) : null;

      if (cap[0].charAt(0) !== '!') {
        return {
          type: 'link',
          raw,
          href,
          title,
          text: cap[1]
        };
      } else {
        return {
          type: 'image',
          raw,
          text: escape$2(cap[1]),
          href,
          title
        };
      }
    }

    /**
     * Tokenizer
     */
    var Tokenizer_1 = class Tokenizer {
      constructor(options) {
        this.options = options || defaults$1;
      }

      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap) {
          if (cap[0].length > 1) {
            return {
              type: 'space',
              raw: cap[0]
            };
          }
          return { raw: '\n' };
        }
      }

      code(src, tokens) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const lastToken = tokens[tokens.length - 1];
          // An indented code block cannot interrupt a paragraph.
          if (lastToken && lastToken.type === 'paragraph') {
            tokens.pop();
            lastToken.text += '\n' + cap[0].trimRight();
            lastToken.raw += '\n' + cap[0];
            return lastToken;
          } else {
            const text = cap[0].replace(/^ {4}/gm, '');
            return {
              type: 'code',
              raw: cap[0],
              codeBlockStyle: 'indented',
              text: !this.options.pedantic
                ? rtrim$1(text, '\n')
                : text
            };
          }
        }
      }

      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          return {
            type: 'code',
            raw: cap[0],
            lang: cap[2] ? cap[2].trim() : cap[2],
            text: cap[3] || ''
          };
        }
      }

      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          return {
            type: 'heading',
            raw: cap[0],
            depth: cap[1].length,
            text: cap[2]
          };
        }
      }

      nptable(src) {
        const cap = this.rules.block.nptable.exec(src);
        if (cap) {
          const item = {
            type: 'table',
            header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [],
            raw: cap[0]
          };

          if (item.header.length === item.align.length) {
            let l = item.align.length;
            let i;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = 'right';
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = 'center';
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = 'left';
              } else {
                item.align[i] = null;
              }
            }

            l = item.cells.length;
            for (i = 0; i < l; i++) {
              item.cells[i] = splitCells$1(item.cells[i], item.header.length);
            }

            return item;
          }
        }
      }

      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: 'hr',
            raw: cap[0]
          };
        }
      }

      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ *> ?/gm, '');

          return {
            type: 'blockquote',
            raw: cap[0],
            text
          };
        }
      }

      list(src) {
        const cap = this.rules.block.list.exec(src);
        if (cap) {
          let raw = cap[0];
          const bull = cap[2];
          const isordered = bull.length > 1;

          const list = {
            type: 'list',
            raw,
            ordered: isordered,
            start: isordered ? +bull : '',
            loose: false,
            items: []
          };

          // Get each top-level item.
          const itemMatch = cap[0].match(this.rules.block.item);

          let next = false,
            item,
            space,
            b,
            addBack,
            loose,
            istask,
            ischecked;

          const l = itemMatch.length;
          for (let i = 0; i < l; i++) {
            item = itemMatch[i];
            raw = item;

            // Remove the list item's bullet
            // so it is seen as the next token.
            space = item.length;
            item = item.replace(/^ *([*+-]|\d+\.) */, '');

            // Outdent whatever the
            // list item contains. Hacky.
            if (~item.indexOf('\n ')) {
              space -= item.length;
              item = !this.options.pedantic
                ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
                : item.replace(/^ {1,4}/gm, '');
            }

            // Determine whether the next list item belongs here.
            // Backpedal if it does not belong in this list.
            if (i !== l - 1) {
              b = this.rules.block.bullet.exec(itemMatch[i + 1])[0];
              if (bull.length > 1 ? b.length === 1
                : (b.length > 1 || (this.options.smartLists && b !== bull))) {
                addBack = itemMatch.slice(i + 1).join('\n');
                list.raw = list.raw.substring(0, list.raw.length - addBack.length);
                i = l - 1;
              }
            }

            // Determine whether item is loose or not.
            // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
            // for discount behavior.
            loose = next || /\n\n(?!\s*$)/.test(item);
            if (i !== l - 1) {
              next = item.charAt(item.length - 1) === '\n';
              if (!loose) loose = next;
            }

            if (loose) {
              list.loose = true;
            }

            // Check for task list items
            istask = /^\[[ xX]\] /.test(item);
            ischecked = undefined;
            if (istask) {
              ischecked = item[1] !== ' ';
              item = item.replace(/^\[[ xX]\] +/, '');
            }

            list.items.push({
              raw,
              task: istask,
              checked: ischecked,
              loose: loose,
              text: item
            });
          }

          return list;
        }
      }

      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          return {
            type: this.options.sanitize
              ? 'paragraph'
              : 'html',
            raw: cap[0],
            pre: !this.options.sanitizer
              && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
            text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$2(cap[0])) : cap[0]
          };
        }
      }

      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
          const tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
          return {
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      }

      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          const item = {
            type: 'table',
            header: splitCells$1(cap[1].replace(/^ *| *\| *$/g, '')),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
          };

          if (item.header.length === item.align.length) {
            item.raw = cap[0];

            let l = item.align.length;
            let i;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = 'right';
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = 'center';
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = 'left';
              } else {
                item.align[i] = null;
              }
            }

            l = item.cells.length;
            for (i = 0; i < l; i++) {
              item.cells[i] = splitCells$1(
                item.cells[i].replace(/^ *\| *| *\| *$/g, ''),
                item.header.length);
            }

            return item;
          }
        }
      }

      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          return {
            type: 'heading',
            raw: cap[0],
            depth: cap[2].charAt(0) === '=' ? 1 : 2,
            text: cap[1]
          };
        }
      }

      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          return {
            type: 'paragraph',
            raw: cap[0],
            text: cap[1].charAt(cap[1].length - 1) === '\n'
              ? cap[1].slice(0, -1)
              : cap[1]
          };
        }
      }

      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          return {
            type: 'text',
            raw: cap[0],
            text: cap[0]
          };
        }
      }

      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: 'escape',
            raw: cap[0],
            text: escape$2(cap[1])
          };
        }
      }

      tag(src, inLink, inRawBlock) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!inLink && /^<a /i.test(cap[0])) {
            inLink = true;
          } else if (inLink && /^<\/a>/i.test(cap[0])) {
            inLink = false;
          }
          if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = true;
          } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            inRawBlock = false;
          }

          return {
            type: this.options.sanitize
              ? 'text'
              : 'html',
            raw: cap[0],
            inLink,
            inRawBlock,
            text: this.options.sanitize
              ? (this.options.sanitizer
                ? this.options.sanitizer(cap[0])
                : escape$2(cap[0]))
              : cap[0]
          };
        }
      }

      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const lastParenIndex = findClosingBracket$1(cap[2], '()');
          if (lastParenIndex > -1) {
            const start = cap[0].indexOf('!') === 0 ? 5 : 4;
            const linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = '';
          }
          let href = cap[2];
          let title = '';
          if (this.options.pedantic) {
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

            if (link) {
              href = link[1];
              title = link[3];
            } else {
              title = '';
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : '';
          }
          href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
          const token = outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
            title: title ? title.replace(this.rules.inline._escapes, '$1') : title
          }, cap[0]);
          return token;
        }
      }

      reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src))
            || (cap = this.rules.inline.nolink.exec(src))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
          link = links[link.toLowerCase()];
          if (!link || !link.href) {
            const text = cap[0].charAt(0);
            return {
              type: 'text',
              raw: text,
              text
            };
          }
          const token = outputLink(cap, link, cap[0]);
          return token;
        }
      }

      strong(src) {
        const cap = this.rules.inline.strong.exec(src);
        if (cap) {
          return {
            type: 'strong',
            raw: cap[0],
            text: cap[4] || cap[3] || cap[2] || cap[1]
          };
        }
      }

      em(src) {
        const cap = this.rules.inline.em.exec(src);
        if (cap) {
          return {
            type: 'em',
            raw: cap[0],
            text: cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]
          };
        }
      }

      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          return {
            type: 'codespan',
            raw: cap[0],
            text: escape$2(cap[2].trim(), true)
          };
        }
      }

      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: 'br',
            raw: cap[0]
          };
        }
      }

      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: 'del',
            raw: cap[0],
            text: cap[1]
          };
        }
      }

      autolink(src, mangle) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text, href;
          if (cap[2] === '@') {
            text = escape$2(this.options.mangle ? mangle(cap[1]) : cap[1]);
            href = 'mailto:' + text;
          } else {
            text = escape$2(cap[1]);
            href = text;
          }

          return {
            type: 'link',
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: 'text',
                raw: text,
                text
              }
            ]
          };
        }
      }

      url(src, mangle) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text, href;
          if (cap[2] === '@') {
            text = escape$2(this.options.mangle ? mangle(cap[0]) : cap[0]);
            href = 'mailto:' + text;
          } else {
            // do extended autolink path validation
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape$2(cap[0]);
            if (cap[1] === 'www.') {
              href = 'http://' + text;
            } else {
              href = text;
            }
          }
          return {
            type: 'link',
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: 'text',
                raw: text,
                text
              }
            ]
          };
        }
      }

      inlineText(src, inRawBlock, smartypants) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text;
          if (inRawBlock) {
            text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape$2(cap[0])) : cap[0];
          } else {
            text = escape$2(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
          }
          return {
            type: 'text',
            raw: cap[0],
            text
          };
        }
      }
    };

    const {
      noopTest: noopTest$1,
      edit: edit$1,
      merge: merge$1
    } = helpers;

    /**
     * Block-Level Grammar
     */
    const block = {
      newline: /^\n+/,
      code: /^( {4}[^\n]+\n*)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
      html: '^ {0,3}(?:' // optional indentation
        + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
        + '|comment[^\\n]*(\\n+|$)' // (2)
        + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
        + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
        + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
        + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
        + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
        + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
        + ')',
      def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
      nptable: noopTest$1,
      table: noopTest$1,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
      text: /^[^\n]+/
    };

    block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit$1(block.def)
      .replace('label', block._label)
      .replace('title', block._title)
      .getRegex();

    block.bullet = /(?:[*+-]|\d{1,9}\.)/;
    block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
    block.item = edit$1(block.item, 'gm')
      .replace(/bull/g, block.bullet)
      .getRegex();

    block.list = edit$1(block.list)
      .replace(/bull/g, block.bullet)
      .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
      .replace('def', '\\n+(?=' + block.def.source + ')')
      .getRegex();

    block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
      + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
      + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
      + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
      + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
      + '|track|ul';
    block._comment = /<!--(?!-?>)[\s\S]*?-->/;
    block.html = edit$1(block.html, 'i')
      .replace('comment', block._comment)
      .replace('tag', block._tag)
      .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
      .getRegex();

    block.paragraph = edit$1(block._paragraph)
      .replace('hr', block.hr)
      .replace('heading', ' {0,3}#{1,6} ')
      .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
      .replace('blockquote', ' {0,3}>')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
      .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
      .getRegex();

    block.blockquote = edit$1(block.blockquote)
      .replace('paragraph', block.paragraph)
      .getRegex();

    /**
     * Normal Block Grammar
     */

    block.normal = merge$1({}, block);

    /**
     * GFM Block Grammar
     */

    block.gfm = merge$1({}, block.normal, {
      nptable: '^ *([^|\\n ].*\\|.*)\\n' // Header
        + ' *([-:]+ *\\|[-| :]*)' // Align
        + '(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)', // Cells
      table: '^ *\\|(.+)\\n' // Header
        + ' *\\|?( *[-:]+[-| :]*)' // Align
        + '(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)' // Cells
    });

    block.gfm.nptable = edit$1(block.gfm.nptable)
      .replace('hr', block.hr)
      .replace('heading', ' {0,3}#{1,6} ')
      .replace('blockquote', ' {0,3}>')
      .replace('code', ' {4}[^\\n]')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
      .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
      .getRegex();

    block.gfm.table = edit$1(block.gfm.table)
      .replace('hr', block.hr)
      .replace('heading', ' {0,3}#{1,6} ')
      .replace('blockquote', ' {0,3}>')
      .replace('code', ' {4}[^\\n]')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
      .replace('tag', block._tag) // tables can be interrupted by type (6) html blocks
      .getRegex();

    /**
     * Pedantic grammar (original John Gruber's loose markdown specification)
     */

    block.pedantic = merge$1({}, block.normal, {
      html: edit$1(
        '^ *(?:comment *(?:\\n|\\s*$)'
        + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
        + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
        .replace('comment', block._comment)
        .replace(/tag/g, '(?!(?:'
          + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
          + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
          + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
        .getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
      fences: noopTest$1, // fences not supported
      paragraph: edit$1(block.normal._paragraph)
        .replace('hr', block.hr)
        .replace('heading', ' *#{1,6} *[^\n]')
        .replace('lheading', block.lheading)
        .replace('blockquote', ' {0,3}>')
        .replace('|fences', '')
        .replace('|list', '')
        .replace('|html', '')
        .getRegex()
    });

    /**
     * Inline-Level Grammar
     */
    const inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest$1,
      tag: '^comment'
        + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
        + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
        + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
        + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
        + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
      nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
      strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
      em: /^_([^\s_])_(?!_)|^_([^\s_<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s*<\[])\*(?!\*)|^\*([^\s<"][\s\S]*?[^\s\[\*])\*(?![\]`punctuation])|^\*([^\s*"<\[][\s\S]*[^\s])\*(?!\*)/,
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest$1,
      text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
    };

    // list of punctuation marks from common mark spec
    // without ` and ] to workaround Rule 17 (inline code blocks/links)
    inline._punctuation = '!"#$%&\'()*+\\-./:;<=>?@\\[^_{|}~';
    inline.em = edit$1(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();

    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit$1(inline.autolink)
      .replace('scheme', inline._scheme)
      .replace('email', inline._email)
      .getRegex();

    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

    inline.tag = edit$1(inline.tag)
      .replace('comment', block._comment)
      .replace('attribute', inline._attribute)
      .getRegex();

    inline._label = /(?:\[[^\[\]]*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

    inline.link = edit$1(inline.link)
      .replace('label', inline._label)
      .replace('href', inline._href)
      .replace('title', inline._title)
      .getRegex();

    inline.reflink = edit$1(inline.reflink)
      .replace('label', inline._label)
      .getRegex();

    /**
     * Normal Inline Grammar
     */

    inline.normal = merge$1({}, inline);

    /**
     * Pedantic Inline Grammar
     */

    inline.pedantic = merge$1({}, inline.normal, {
      strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
      link: edit$1(/^!?\[(label)\]\((.*?)\)/)
        .replace('label', inline._label)
        .getRegex(),
      reflink: edit$1(/^!?\[(label)\]\s*\[([^\]]*)\]/)
        .replace('label', inline._label)
        .getRegex()
    });

    /**
     * GFM Inline Grammar
     */

    inline.gfm = merge$1({}, inline.normal, {
      escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^~+(?=\S)([\s\S]*?\S)~+/,
      text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
    });

    inline.gfm.url = edit$1(inline.gfm.url, 'i')
      .replace('email', inline.gfm._extended_email)
      .getRegex();
    /**
     * GFM + Line Breaks Inline Grammar
     */

    inline.breaks = merge$1({}, inline.gfm, {
      br: edit$1(inline.br).replace('{2,}', '*').getRegex(),
      text: edit$1(inline.gfm.text)
        .replace('\\b_', '\\b_| {2,}\\n')
        .replace(/\{2,\}/g, '*')
        .getRegex()
    });

    var rules = {
      block,
      inline
    };

    const { defaults: defaults$2 } = defaults;
    const { block: block$1, inline: inline$1 } = rules;

    /**
     * smartypants text replacement
     */
    function smartypants(text) {
      return text
        // em-dashes
        .replace(/---/g, '\u2014')
        // en-dashes
        .replace(/--/g, '\u2013')
        // opening singles
        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
        // closing singles & apostrophes
        .replace(/'/g, '\u2019')
        // opening doubles
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
        // closing doubles
        .replace(/"/g, '\u201d')
        // ellipses
        .replace(/\.{3}/g, '\u2026');
    }

    /**
     * mangle email addresses
     */
    function mangle(text) {
      let out = '',
        i,
        ch;

      const l = text.length;
      for (i = 0; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = 'x' + ch.toString(16);
        }
        out += '&#' + ch + ';';
      }

      return out;
    }

    /**
     * Block Lexer
     */
    var Lexer_1 = class Lexer {
      constructor(options) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || defaults$2;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;

        const rules = {
          block: block$1.normal,
          inline: inline$1.normal
        };

        if (this.options.pedantic) {
          rules.block = block$1.pedantic;
          rules.inline = inline$1.pedantic;
        } else if (this.options.gfm) {
          rules.block = block$1.gfm;
          if (this.options.breaks) {
            rules.inline = inline$1.breaks;
          } else {
            rules.inline = inline$1.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }

      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block: block$1,
          inline: inline$1
        };
      }

      /**
       * Static Lex Method
       */
      static lex(src, options) {
        const lexer = new Lexer(options);
        return lexer.lex(src);
      }

      /**
       * Preprocessing
       */
      lex(src) {
        src = src
          .replace(/\r\n|\r/g, '\n')
          .replace(/\t/g, '    ');

        this.blockTokens(src, this.tokens, true);

        this.inline(this.tokens);

        return this.tokens;
      }

      /**
       * Lexing
       */
      blockTokens(src, tokens = [], top = true) {
        src = src.replace(/^ +$/gm, '');
        let token, i, l;

        while (src) {
          // newline
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.type) {
              tokens.push(token);
            }
            continue;
          }

          // code
          if (token = this.tokenizer.code(src, tokens)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // fences
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // heading
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // table no leading pipe (gfm)
          if (token = this.tokenizer.nptable(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // hr
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // blockquote
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.blockTokens(token.text, [], top);
            tokens.push(token);
            continue;
          }

          // list
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            l = token.items.length;
            for (i = 0; i < l; i++) {
              token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
            }
            tokens.push(token);
            continue;
          }

          // html
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // def
          if (top && (token = this.tokenizer.def(src))) {
            src = src.substring(token.raw.length);
            if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }

          // table (gfm)
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // lheading
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // top-level paragraph
          if (top && (token = this.tokenizer.paragraph(src))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // text
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          if (src) {
            const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }

        return tokens;
      }

      inline(tokens) {
        let i,
          j,
          k,
          l2,
          row,
          token;

        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          switch (token.type) {
            case 'paragraph':
            case 'text':
            case 'heading': {
              token.tokens = [];
              this.inlineTokens(token.text, token.tokens);
              break;
            }
            case 'table': {
              token.tokens = {
                header: [],
                cells: []
              };

              // header
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                token.tokens.header[j] = [];
                this.inlineTokens(token.header[j], token.tokens.header[j]);
              }

              // cells
              l2 = token.cells.length;
              for (j = 0; j < l2; j++) {
                row = token.cells[j];
                token.tokens.cells[j] = [];
                for (k = 0; k < row.length; k++) {
                  token.tokens.cells[j][k] = [];
                  this.inlineTokens(row[k], token.tokens.cells[j][k]);
                }
              }

              break;
            }
            case 'blockquote': {
              this.inline(token.tokens);
              break;
            }
            case 'list': {
              l2 = token.items.length;
              for (j = 0; j < l2; j++) {
                this.inline(token.items[j].tokens);
              }
              break;
            }
          }
        }

        return tokens;
      }

      /**
       * Lexing/Compiling
       */
      inlineTokens(src, tokens = [], inLink = false, inRawBlock = false) {
        let token;

        while (src) {
          // escape
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // tag
          if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {
            src = src.substring(token.raw.length);
            inLink = token.inLink;
            inRawBlock = token.inRawBlock;
            tokens.push(token);
            continue;
          }

          // link
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            if (token.type === 'link') {
              token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
            }
            tokens.push(token);
            continue;
          }

          // reflink, nolink
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            if (token.type === 'link') {
              token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
            }
            tokens.push(token);
            continue;
          }

          // strong
          if (token = this.tokenizer.strong(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }

          // em
          if (token = this.tokenizer.em(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }

          // code
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // br
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // del (gfm)
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
            tokens.push(token);
            continue;
          }

          // autolink
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // url (gfm)
          if (!inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          // text
          if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }

          if (src) {
            const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }

        return tokens;
      }
    };

    const { defaults: defaults$3 } = defaults;
    const {
      cleanUrl: cleanUrl$1,
      escape: escape$3
    } = helpers;

    /**
     * Renderer
     */
    var Renderer_1 = class Renderer {
      constructor(options) {
        this.options = options || defaults$3;
      }

      code(code, infostring, escaped) {
        const lang = (infostring || '').match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }

        if (!lang) {
          return '<pre><code>'
            + (escaped ? code : escape$3(code, true))
            + '</code></pre>';
        }

        return '<pre><code class="'
          + this.options.langPrefix
          + escape$3(lang, true)
          + '">'
          + (escaped ? code : escape$3(code, true))
          + '</code></pre>\n';
      }

      blockquote(quote) {
        return '<blockquote>\n' + quote + '</blockquote>\n';
      }

      html(html) {
        return html;
      }

      heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          return '<h'
            + level
            + ' id="'
            + this.options.headerPrefix
            + slugger.slug(raw)
            + '">'
            + text
            + '</h'
            + level
            + '>\n';
        }
        // ignore IDs
        return '<h' + level + '>' + text + '</h' + level + '>\n';
      }

      hr() {
        return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
      }

      list(body, ordered, start) {
        const type = ordered ? 'ol' : 'ul',
          startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
        return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
      }

      listitem(text) {
        return '<li>' + text + '</li>\n';
      }

      checkbox(checked) {
        return '<input '
          + (checked ? 'checked="" ' : '')
          + 'disabled="" type="checkbox"'
          + (this.options.xhtml ? ' /' : '')
          + '> ';
      }

      paragraph(text) {
        return '<p>' + text + '</p>\n';
      }

      table(header, body) {
        if (body) body = '<tbody>' + body + '</tbody>';

        return '<table>\n'
          + '<thead>\n'
          + header
          + '</thead>\n'
          + body
          + '</table>\n';
      }

      tablerow(content) {
        return '<tr>\n' + content + '</tr>\n';
      }

      tablecell(content, flags) {
        const type = flags.header ? 'th' : 'td';
        const tag = flags.align
          ? '<' + type + ' align="' + flags.align + '">'
          : '<' + type + '>';
        return tag + content + '</' + type + '>\n';
      }

      // span level renderer
      strong(text) {
        return '<strong>' + text + '</strong>';
      }

      em(text) {
        return '<em>' + text + '</em>';
      }

      codespan(text) {
        return '<code>' + text + '</code>';
      }

      br() {
        return this.options.xhtml ? '<br/>' : '<br>';
      }

      del(text) {
        return '<del>' + text + '</del>';
      }

      link(href, title, text) {
        href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<a href="' + escape$3(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += '>' + text + '</a>';
        return out;
      }

      image(href, title, text) {
        href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }

        let out = '<img src="' + href + '" alt="' + text + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? '/>' : '>';
        return out;
      }

      text(text) {
        return text;
      }
    };

    /**
     * TextRenderer
     * returns only the textual part of the token
     */
    var TextRenderer_1 = class TextRenderer {
      // no need for block level renderers
      strong(text) {
        return text;
      }

      em(text) {
        return text;
      }

      codespan(text) {
        return text;
      }

      del(text) {
        return text;
      }

      html(text) {
        return text;
      }

      text(text) {
        return text;
      }

      link(href, title, text) {
        return '' + text;
      }

      image(href, title, text) {
        return '' + text;
      }

      br() {
        return '';
      }
    };

    /**
     * Slugger generates header id
     */
    var Slugger_1 = class Slugger {
      constructor() {
        this.seen = {};
      }

      /**
       * Convert string to unique id
       */
      slug(value) {
        let slug = value
          .toLowerCase()
          .trim()
          // remove html tags
          .replace(/<[!\/a-z].*?>/ig, '')
          // remove unwanted chars
          .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
          .replace(/\s/g, '-');

        if (this.seen.hasOwnProperty(slug)) {
          const originalSlug = slug;
          do {
            this.seen[originalSlug]++;
            slug = originalSlug + '-' + this.seen[originalSlug];
          } while (this.seen.hasOwnProperty(slug));
        }
        this.seen[slug] = 0;

        return slug;
      }
    };

    const { defaults: defaults$4 } = defaults;
    const {
      unescape: unescape$2
    } = helpers;

    /**
     * Parsing & Compiling
     */
    var Parser_1 = class Parser {
      constructor(options) {
        this.options = options || defaults$4;
        this.options.renderer = this.options.renderer || new Renderer_1();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer_1();
        this.slugger = new Slugger_1();
      }

      /**
       * Static Parse Method
       */
      static parse(tokens, options) {
        const parser = new Parser(options);
        return parser.parse(tokens);
      }

      /**
       * Parse Loop
       */
      parse(tokens, top = true) {
        let out = '',
          i,
          j,
          k,
          l2,
          l3,
          row,
          cell,
          header,
          body,
          token,
          ordered,
          start,
          loose,
          itemBody,
          item,
          checked,
          task,
          checkbox;

        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          switch (token.type) {
            case 'space': {
              continue;
            }
            case 'hr': {
              out += this.renderer.hr();
              continue;
            }
            case 'heading': {
              out += this.renderer.heading(
                this.parseInline(token.tokens),
                token.depth,
                unescape$2(this.parseInline(token.tokens, this.textRenderer)),
                this.slugger);
              continue;
            }
            case 'code': {
              out += this.renderer.code(token.text,
                token.lang,
                token.escaped);
              continue;
            }
            case 'table': {
              header = '';

              // header
              cell = '';
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(
                  this.parseInline(token.tokens.header[j]),
                  { header: true, align: token.align[j] }
                );
              }
              header += this.renderer.tablerow(cell);

              body = '';
              l2 = token.cells.length;
              for (j = 0; j < l2; j++) {
                row = token.tokens.cells[j];

                cell = '';
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(
                    this.parseInline(row[k]),
                    { header: false, align: token.align[k] }
                  );
                }

                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case 'blockquote': {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case 'list': {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;

              body = '';
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;

                itemBody = '';
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens[0].type === 'text') {
                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: 'text',
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }

                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }

              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case 'html': {
              // TODO parse inline content if parameter markdown=1
              out += this.renderer.html(token.text);
              continue;
            }
            case 'paragraph': {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case 'text': {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === 'text') {
                token = tokens[++i];
                body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }

        return out;
      }

      /**
       * Parse Inline Tokens
       */
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = '',
          i,
          token;

        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          switch (token.type) {
            case 'escape': {
              out += renderer.text(token.text);
              break;
            }
            case 'html': {
              out += renderer.html(token.text);
              break;
            }
            case 'link': {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case 'image': {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case 'strong': {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'em': {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'codespan': {
              out += renderer.codespan(token.text);
              break;
            }
            case 'br': {
              out += renderer.br();
              break;
            }
            case 'del': {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case 'text': {
              out += renderer.text(token.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    };

    const {
      merge: merge$2,
      checkSanitizeDeprecation: checkSanitizeDeprecation$1,
      escape: escape$4
    } = helpers;
    const {
      getDefaults,
      changeDefaults,
      defaults: defaults$5
    } = defaults;

    /**
     * Marked
     */
    function marked(src, opt, callback) {
      // throw error in case of non string input
      if (typeof src === 'undefined' || src === null) {
        throw new Error('marked(): input parameter is undefined or null');
      }
      if (typeof src !== 'string') {
        throw new Error('marked(): input parameter is of type '
          + Object.prototype.toString.call(src) + ', string expected');
      }

      if (callback || typeof opt === 'function') {
        if (!callback) {
          callback = opt;
          opt = null;
        }

        opt = merge$2({}, marked.defaults, opt || {});
        checkSanitizeDeprecation$1(opt);
        const highlight = opt.highlight;
        let tokens,
          pending,
          i = 0;

        try {
          tokens = Lexer_1.lex(src, opt);
        } catch (e) {
          return callback(e);
        }

        pending = tokens.length;

        const done = function(err) {
          if (err) {
            opt.highlight = highlight;
            return callback(err);
          }

          let out;

          try {
            out = Parser_1.parse(tokens, opt);
          } catch (e) {
            err = e;
          }

          opt.highlight = highlight;

          return err
            ? callback(err)
            : callback(null, out);
        };

        if (!highlight || highlight.length < 3) {
          return done();
        }

        delete opt.highlight;

        if (!pending) return done();

        for (; i < tokens.length; i++) {
          (function(token) {
            if (token.type !== 'code') {
              return --pending || done();
            }
            return highlight(token.text, token.lang, function(err, code) {
              if (err) return done(err);
              if (code == null || code === token.text) {
                return --pending || done();
              }
              token.text = code;
              token.escaped = true;
              --pending || done();
            });
          })(tokens[i]);
        }

        return;
      }
      try {
        opt = merge$2({}, marked.defaults, opt || {});
        checkSanitizeDeprecation$1(opt);
        return Parser_1.parse(Lexer_1.lex(src, opt), opt);
      } catch (e) {
        e.message += '\nPlease report this to https://github.com/markedjs/marked.';
        if ((opt || marked.defaults).silent) {
          return '<p>An error occurred:</p><pre>'
            + escape$4(e.message + '', true)
            + '</pre>';
        }
        throw e;
      }
    }

    /**
     * Options
     */

    marked.options =
    marked.setOptions = function(opt) {
      merge$2(marked.defaults, opt);
      changeDefaults(marked.defaults);
      return marked;
    };

    marked.getDefaults = getDefaults;

    marked.defaults = defaults$5;

    /**
     * Use Extension
     */

    marked.use = function(extension) {
      const opts = merge$2({}, extension);
      if (extension.renderer) {
        const renderer = marked.defaults.renderer || new Renderer_1();
        for (const prop in extension.renderer) {
          const prevRenderer = renderer[prop];
          renderer[prop] = (...args) => {
            let ret = extension.renderer[prop].apply(renderer, args);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args);
            }
            return ret;
          };
        }
        opts.renderer = renderer;
      }
      if (extension.tokenizer) {
        const tokenizer = marked.defaults.tokenizer || new Tokenizer_1();
        for (const prop in extension.tokenizer) {
          const prevTokenizer = tokenizer[prop];
          tokenizer[prop] = (...args) => {
            let ret = extension.tokenizer[prop].apply(tokenizer, args);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      marked.setOptions(opts);
    };

    /**
     * Expose
     */

    marked.Parser = Parser_1;
    marked.parser = Parser_1.parse;

    marked.Renderer = Renderer_1;
    marked.TextRenderer = TextRenderer_1;

    marked.Lexer = Lexer_1;
    marked.lexer = Lexer_1.lex;

    marked.Tokenizer = Tokenizer_1;

    marked.Slugger = Slugger_1;

    marked.parse = marked;

    var marked_1 = marked;

    /* src\svelte\components\Format\RelativeDateTimeFormat.svelte generated by Svelte v3.22.2 */

    function create_fragment$1a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*output*/ ctx[0]);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*output*/ 1) set_data_dev(t, /*output*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	var translate;
    	var { value = void 0 } = $$props;
    	var { includeTime = true } = $$props;

    	// todo: show time will change conditions
    	translate = function (val) {
    		var baseDate,
    			isFuture,
    			isPast,
    			prefix,
    			suffix,
    			theDate,
    			timeFormat,
    			tomorrow,
    			yesterday;

    		// comparator dates
    		baseDate = Date.create(val).beginningOfDay();

    		yesterday = baseDate.clone().addDays(-1);
    		tomorrow = baseDate.clone().addDays(1);
    		theDate = Date.create(val);

    		timeFormat = "%H:%M";
    		isFuture = theDate.isFuture();

    		if (isFuture) {
    			prefix = "last";
    			suffix = "from now";
    		} else {
    			prefix = "next";
    			suffix = "ago";
    		}

    		isPast = !isFuture;

    		/*
      Rules
        PAST before: 00:00
          Yesterday "Yesterday [at hh:mm]"
          Up to a week ago - "days ago (mm/dd) [at hh:mm]"
          More than a week ago - "Full date [at hh:mm]"
        TODAY - since: 00 until 23:59
          pastPrefix = "ago"
          futurePrefix = "from now"
          < 1m "moments [prefix]"
          < 60m "minutes [prefix]"
          < 4h "hours [prefix]"
          < "[at hh:mm]"
        FUTURE after 23:59
          Tomorrow "Tomorrow [at hh:mm]"
          Up to a week from now - "Next full-day-of-week [at hh:mm]"
          More than a week from now - "Full date [at hh:mm]"
    */
    		if (Math.abs(theDate.secondsFromNow()) < 60) {
    			return `moments ${suffix}`;
    		} else if (Math.abs(theDate.minutesFromNow()) < 60) {
    			return `${Math.abs(theDate.hoursFromNow())} ${("minutes").pluralize(Math.abs(theDate.minutesFromNow()))} ${suffix}`;
    		} else if (Math.abs(theDate.hoursFromNow()) < 24) {
    			return `${Math.abs(theDate.hoursFromNow())} ${("hours").pluralize(Math.abs(theDate.minutesFromNow()))} ${suffix}`;
    		} else if (Math.abs(theDate.daysFromNow()) < 7) {
    			if (Math.abs(theDate.daysFromNow()) === 1) {
    				if (isPast) {
    					return `Yesterday at ${theDate.format(timeFormat)}`;
    				} else {
    					return `Tomorrow at ${theDate.format(timeFormat)}`;
    				}
    			} else if (Math.abs(theDate.daysFromNow()) < 7) {
    				if (isFuture) {
    					prefix = "";
    				}

    				return `${prefix.capitalize()} ${theDate.format("%A at " + timeFormat)}`.compact();
    			} else {
    				return `${theDate.format()}`;
    			}
    		} else {
    			return `${theDate.format()}`;
    		}
    	};

    	const writable_props = ["value", "includeTime"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<RelativeDateTimeFormat> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("RelativeDateTimeFormat", $$slots, []);

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("includeTime" in $$props) $$invalidate(2, includeTime = $$props.includeTime);
    	};

    	$$self.$capture_state = () => ({ translate, value, includeTime, output });

    	$$self.$inject_state = $$props => {
    		if ("translate" in $$props) $$invalidate(3, translate = $$props.translate);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("includeTime" in $$props) $$invalidate(2, includeTime = $$props.includeTime);
    		if ("output" in $$props) $$invalidate(0, output = $$props.output);
    	};

    	let output;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*translate, value*/ 10) {
    			 $$invalidate(0, output = translate(value));
    		}
    	};

    	return [output, value, includeTime];
    }

    class RelativeDateTimeFormat extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, { value: 1, includeTime: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RelativeDateTimeFormat",
    			options,
    			id: create_fragment$1a.name
    		});
    	}

    	get value() {
    		throw new Error("<RelativeDateTimeFormat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<RelativeDateTimeFormat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get includeTime() {
    		throw new Error("<RelativeDateTimeFormat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set includeTime(value) {
    		throw new Error("<RelativeDateTimeFormat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Comment$1, SubDocument$8;

    SubDocument$8 = sub_document;

    Comment$1 = (function() {
      class Comment extends SubDocument$8 {
        model() {
          return {
            // if sourceversion < latest version, then some upgrades may be required
            // if null then return latest
            id: null,
            type: this.type,
            ordinal: null,
            name: "",
            hierarchy: {},
            metadata: {},
            effort_minutes: 0,
            booked_at: null,
            created_at: null,
            updated_at: null,
            versions: []
          };
        }

      }
      Comment.prototype.name = "Comment";

      Comment.prototype.type = "comment";

      return Comment;

    }).call(commonjsGlobal);

    var comment = Comment$1;

    /* src\svelte\pages\_Common\Sections\Comments.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$e, console: console_1$B } = globals;
    const file$13 = "src\\svelte\\pages\\_Common\\Sections\\Comments.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	child_ctx[17] = i;
    	return child_ctx;
    }

    // (125:2) {#if list && list.length}
    function create_if_block$F(ctx) {
    	let div;
    	let current;
    	let each_value = /*list*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$13, 125, 4, 2619);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*list, marked*/ 4) {
    				each_value = /*list*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$F.name,
    		type: "if",
    		source: "(125:2) {#if list && list.length}",
    		ctx
    	});

    	return block;
    }

    // (127:6) {#each list as comment, index}
    function create_each_block$g(ctx) {
    	let div4;
    	let div2;
    	let div0;
    	let span;
    	let t0;
    	let div1;
    	let raw_value = marked_1(/*comment*/ ctx[15].content || "") + "";
    	let t1;
    	let div3;
    	let svg;
    	let path;
    	let t2;
    	let div4_id_value;
    	let current;

    	const relativedatetimeformat = new RelativeDateTimeFormat({
    			props: { value: /*comment*/ ctx[15].created_at },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			span = element("span");
    			create_component(relativedatetimeformat.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div3 = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t2 = space();
    			attr_dev(span, "class", "posted svelte-1jlslk2");
    			add_location(span, file$13, 130, 14, 2823);
    			add_location(div0, file$13, 129, 12, 2803);
    			add_location(div1, file$13, 132, 12, 2935);
    			attr_dev(div2, "flex", "");
    			attr_dev(div2, "ellipsis", "");
    			attr_dev(div2, "layout", "column");
    			add_location(div2, file$13, 128, 10, 2755);
    			attr_dev(path, "d", "M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z");
    			add_location(path, file$13, 135, 122, 3139);
    			attr_dev(svg, "class", "menu");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			add_location(svg, file$13, 135, 12, 3029);
    			add_location(div3, file$13, 134, 10, 3011);
    			attr_dev(div4, "type", "task");
    			attr_dev(div4, "id", div4_id_value = "task-" + /*comment*/ ctx[15].id);
    			attr_dev(div4, "div", "");
    			attr_dev(div4, "layout", "row");
    			attr_dev(div4, "class", "message svelte-1jlslk2");
    			add_location(div4, file$13, 127, 8, 2670);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, div0);
    			append_dev(div0, span);
    			mount_component(relativedatetimeformat, span, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			div1.innerHTML = raw_value;
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, svg);
    			append_dev(svg, path);
    			append_dev(div4, t2);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const relativedatetimeformat_changes = {};
    			if (dirty & /*list*/ 4) relativedatetimeformat_changes.value = /*comment*/ ctx[15].created_at;
    			relativedatetimeformat.$set(relativedatetimeformat_changes);
    			if ((!current || dirty & /*list*/ 4) && raw_value !== (raw_value = marked_1(/*comment*/ ctx[15].content || "") + "")) div1.innerHTML = raw_value;
    			if (!current || dirty & /*list*/ 4 && div4_id_value !== (div4_id_value = "task-" + /*comment*/ ctx[15].id)) {
    				attr_dev(div4, "id", div4_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(relativedatetimeformat.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(relativedatetimeformat.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(relativedatetimeformat);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(127:6) {#each list as comment, index}",
    		ctx
    	});

    	return block;
    }

    // (123:0) <Section name={collection.titleize()} {open}>
    function create_default_slot$x(ctx) {
    	let t;
    	let current;
    	let if_block = /*list*/ ctx[2] && /*list*/ ctx[2].length && create_if_block$F(ctx);

    	const quickentry = new GenericItem({
    			props: {
    				stubPlaceholder: "Add " + /*collection*/ ctx[0].singularize().titleize(),
    				attribute: "content",
    				isTextArea: true
    			},
    			$$inline: true
    		});

    	quickentry.$on("add", function () {
    		if (is_function(/*add*/ ctx[1])) /*add*/ ctx[1].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(quickentry.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(quickentry, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*list*/ ctx[2] && /*list*/ ctx[2].length) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*list*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$F(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const quickentry_changes = {};
    			if (dirty & /*collection*/ 1) quickentry_changes.stubPlaceholder = "Add " + /*collection*/ ctx[0].singularize().titleize();
    			quickentry.$set(quickentry_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(quickentry.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(quickentry.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(quickentry, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$x.name,
    		type: "slot",
    		source: "(123:0) <Section name={collection.titleize()} {open}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1b(ctx) {
    	let current;

    	const section = new Section({
    			props: {
    				name: /*collection*/ ctx[0].titleize(),
    				open,
    				$$slots: { default: [create_default_slot$x] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const section_changes = {};
    			if (dirty & /*collection*/ 1) section_changes.name = /*collection*/ ctx[0].titleize();

    			if (dirty & /*$$scope, collection, add, list*/ 262151) {
    				section_changes.$$scope = { dirty, ctx };
    			}

    			section.$set(section_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	var add,
    		dispatch,
    		dropEvent,
    		sort,
    		subDocument,
    		update,
    		updateAttribute,
    		updateName;

    	dispatch = createEventDispatcher();
    	var { item = void 0 } = $$props;
    	var { collection = "comments" } = $$props;
    	var { project = void 0 } = $$props;
    	var { listId = uuid() } = $$props;
    	var { sameListOnly = true } = $$props;
    	var { assignments = [] } = $$props;
    	subDocument = new comment();

    	update = function () {
    		return dispatch("update");
    	};

    	updateName = function (e) {
    		var change;
    		console.log(e.detail);
    		change = { id: item.id, name: e.detail };
    		return dispatch("update", change);
    	};

    	updateAttribute = function (e) {
    		var change, changedTask;
    		console.log("ListItme.svelte updateAttribute");
    		console.log(e.detail);
    		change = e.detail;

    		// change["id"] = item.id
    		changedTask = item[collection].find({ id: change.id });

    		Object.merge(changedTask, change);
    		$$invalidate(3, item);
    		console.log(change);
    		return dispatch("update", change);
    	};

    	add = function (event) {
    		var newRecord;
    		newRecord = subDocument.stub(event.detail);
    		newRecord.ordinal = (item[collection] || []).length;
    		$$invalidate(3, item[collection] = item[collection].add(newRecord), item);
    		return dispatch("update");
    	};

    	update = function () {
    		return dispatch("update");
    	};

    	sort = function (list) {
    		if (item[collection] != null) {
    			return item[collection].sortBy("ordinal");
    		} else {
    			return [];
    		}
    	};

    	dropEvent = function (e) {
    		
    	};

    	const writable_props = ["item", "collection", "project", "listId", "sameListOnly", "assignments"];

    	Object_1$e.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$B.warn(`<Comments> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Comments", $$slots, []);

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(3, item = $$props.item);
    		if ("collection" in $$props) $$invalidate(0, collection = $$props.collection);
    		if ("project" in $$props) $$invalidate(4, project = $$props.project);
    		if ("listId" in $$props) $$invalidate(5, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(6, sameListOnly = $$props.sameListOnly);
    		if ("assignments" in $$props) $$invalidate(7, assignments = $$props.assignments);
    	};

    	$$self.$capture_state = () => ({
    		add,
    		dispatch,
    		dropEvent,
    		sort,
    		subDocument,
    		update,
    		updateAttribute,
    		updateName,
    		onMount,
    		createEventDispatcher,
    		marked: marked_1,
    		Section,
    		QuickEntry: GenericItem,
    		InlineInput,
    		RelativeDateTimeFormat,
    		Gravatar,
    		Assignment: assignment,
    		SubDocument: comment,
    		item,
    		collection,
    		project,
    		listId,
    		sameListOnly,
    		assignments,
    		list
    	});

    	$$self.$inject_state = $$props => {
    		if ("add" in $$props) $$invalidate(1, add = $$props.add);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("dropEvent" in $$props) dropEvent = $$props.dropEvent;
    		if ("sort" in $$props) $$invalidate(10, sort = $$props.sort);
    		if ("subDocument" in $$props) subDocument = $$props.subDocument;
    		if ("update" in $$props) update = $$props.update;
    		if ("updateAttribute" in $$props) updateAttribute = $$props.updateAttribute;
    		if ("updateName" in $$props) updateName = $$props.updateName;
    		if ("item" in $$props) $$invalidate(3, item = $$props.item);
    		if ("collection" in $$props) $$invalidate(0, collection = $$props.collection);
    		if ("project" in $$props) $$invalidate(4, project = $$props.project);
    		if ("listId" in $$props) $$invalidate(5, listId = $$props.listId);
    		if ("sameListOnly" in $$props) $$invalidate(6, sameListOnly = $$props.sameListOnly);
    		if ("assignments" in $$props) $$invalidate(7, assignments = $$props.assignments);
    		if ("list" in $$props) $$invalidate(2, list = $$props.list);
    	};

    	let list;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*sort, item, collection*/ 1033) {
    			 $$invalidate(2, list = sort(item[collection]));
    		}
    	};

    	return [collection, add, list, item, project, listId, sameListOnly, assignments];
    }

    class Comments extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {
    			item: 3,
    			collection: 0,
    			project: 4,
    			listId: 5,
    			sameListOnly: 6,
    			assignments: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Comments",
    			options,
    			id: create_fragment$1b.name
    		});
    	}

    	get item() {
    		throw new Error("<Comments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Comments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collection() {
    		throw new Error("<Comments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collection(value) {
    		throw new Error("<Comments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get project() {
    		throw new Error("<Comments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set project(value) {
    		throw new Error("<Comments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listId() {
    		throw new Error("<Comments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listId(value) {
    		throw new Error("<Comments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sameListOnly() {
    		throw new Error("<Comments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sameListOnly(value) {
    		throw new Error("<Comments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get assignments() {
    		throw new Error("<Comments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set assignments(value) {
    		throw new Error("<Comments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\Sections\SubDocument_Settings.svelte generated by Svelte v3.22.2 */

    const { console: console_1$C } = globals;
    const file$14 = "src\\svelte\\pages\\_Common\\Sections\\SubDocument_Settings.svelte";

    // (88:0) <Section {open} name="Settings">
    function create_default_slot$y(ctx) {
    	let article;
    	let h20;
    	let t1;
    	let p0;
    	let t3;
    	let field0;
    	let t4;
    	let field1;
    	let t5;
    	let field2;
    	let t6;
    	let field3;
    	let t7;
    	let field4;
    	let t8;
    	let h21;
    	let t10;
    	let h30;
    	let t11;
    	let t12_value = /*item*/ ctx[0].type.titleize() + "";
    	let t12;
    	let t13;
    	let p1;
    	let t15;
    	let p2;
    	let button0;
    	let t16;
    	let t17_value = /*item*/ ctx[0].type.titleize() + "";
    	let t17;
    	let t18;
    	let h31;
    	let t19;
    	let t20_value = /*item*/ ctx[0].type.titleize() + "";
    	let t20;
    	let t21;
    	let p3;
    	let t22;
    	let t23_value = /*item*/ ctx[0].type + "";
    	let t23;
    	let t24;
    	let t25;
    	let button1;
    	let t27;
    	let h22;
    	let t29;
    	let p4;
    	let t30;
    	let b;
    	let t32;
    	let t33;
    	let div;
    	let button2;
    	let t34;
    	let t35_value = /*item*/ ctx[0].type.titleize() + "";
    	let t35;
    	let current;
    	let dispose;

    	const checkbox0 = new Checkbox({
    			props: {
    				checked: /*item*/ ctx[0].settings.sections.about.enabled,
    				key: "about",
    				label: "Enable About"
    			},
    			$$inline: true
    		});

    	checkbox0.$on("change", function () {
    		if (is_function(/*toggleSection*/ ctx[7])) /*toggleSection*/ ctx[7].apply(this, arguments);
    	});

    	const checkbox1 = new Checkbox({
    			props: {
    				checked: /*item*/ ctx[0].settings.sections.checklist.enabled,
    				key: "checklist",
    				label: "Enable Checklist"
    			},
    			$$inline: true
    		});

    	checkbox1.$on("change", function () {
    		if (is_function(/*toggleSection*/ ctx[7])) /*toggleSection*/ ctx[7].apply(this, arguments);
    	});

    	const checkbox2 = new Checkbox({
    			props: {
    				checked: /*item*/ ctx[0].settings.sections.clips.enabled,
    				key: "clips",
    				label: "Enable Clips"
    			},
    			$$inline: true
    		});

    	checkbox2.$on("change", function () {
    		if (is_function(/*toggleSection*/ ctx[7])) /*toggleSection*/ ctx[7].apply(this, arguments);
    	});

    	const checkbox3 = new Checkbox({
    			props: {
    				checked: /*item*/ ctx[0].settings.sections.time_entries.enabled,
    				key: "time_entries",
    				label: "Enable Time Entries"
    			},
    			$$inline: true
    		});

    	checkbox3.$on("change", function () {
    		if (is_function(/*toggleSection*/ ctx[7])) /*toggleSection*/ ctx[7].apply(this, arguments);
    	});

    	const checkbox4 = new Checkbox({
    			props: {
    				checked: /*item*/ ctx[0].settings.sections.comments.enabled,
    				key: "comments",
    				label: "Enable Comments"
    			},
    			$$inline: true
    		});

    	checkbox4.$on("change", function () {
    		if (is_function(/*toggleSection*/ ctx[7])) /*toggleSection*/ ctx[7].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			article = element("article");
    			h20 = element("h2");
    			h20.textContent = "Enable/Disable Sections";
    			t1 = space();
    			p0 = element("p");
    			p0.textContent = "Enabling and disabling will not delete existing items, it will only prevent them from being visible.";
    			t3 = space();
    			field0 = element("field");
    			create_component(checkbox0.$$.fragment);
    			t4 = space();
    			field1 = element("field");
    			create_component(checkbox1.$$.fragment);
    			t5 = space();
    			field2 = element("field");
    			create_component(checkbox2.$$.fragment);
    			t6 = space();
    			field3 = element("field");
    			create_component(checkbox3.$$.fragment);
    			t7 = space();
    			field4 = element("field");
    			create_component(checkbox4.$$.fragment);
    			t8 = space();
    			h21 = element("h2");
    			h21.textContent = "Common Actions";
    			t10 = space();
    			h30 = element("h3");
    			t11 = text("Clone ");
    			t12 = text(t12_value);
    			t13 = space();
    			p1 = element("p");
    			p1.textContent = "This will make a copy of the collection.";
    			t15 = space();
    			p2 = element("p");
    			button0 = element("button");
    			t16 = text("Clone ");
    			t17 = text(t17_value);
    			t18 = space();
    			h31 = element("h3");
    			t19 = text("Export ");
    			t20 = text(t20_value);
    			t21 = space();
    			p3 = element("p");
    			t22 = text("This will save your ");
    			t23 = text(t23_value);
    			t24 = text(" as a JSON file into your downloads folder.");
    			t25 = space();
    			button1 = element("button");
    			button1.textContent = "Save to Disk";
    			t27 = space();
    			h22 = element("h2");
    			h22.textContent = "Danger Zone";
    			t29 = space();
    			p4 = element("p");
    			t30 = text("Deleting the item will ");
    			b = element("b");
    			b.textContent = "permanently";
    			t32 = text(" delete it.");
    			t33 = space();
    			div = element("div");
    			button2 = element("button");
    			t34 = text("Delete ");
    			t35 = text(t35_value);
    			add_location(h20, file$14, 91, 2, 2272);
    			add_location(p0, file$14, 93, 2, 2308);
    			add_location(field0, file$14, 96, 2, 2420);
    			add_location(field1, file$14, 99, 2, 2563);
    			add_location(field2, file$14, 102, 2, 2718);
    			add_location(field3, file$14, 105, 2, 2861);
    			add_location(field4, file$14, 108, 2, 3025);
    			add_location(h21, file$14, 113, 2, 3179);
    			add_location(h30, file$14, 115, 2, 3206);
    			add_location(p1, file$14, 116, 2, 3246);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "primary", "");
    			add_location(button0, file$14, 118, 5, 3300);
    			add_location(p2, file$14, 118, 2, 3297);
    			add_location(h31, file$14, 120, 2, 3375);
    			add_location(p3, file$14, 121, 2, 3416);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "primary", "");
    			add_location(button1, file$14, 122, 2, 3502);
    			add_location(h22, file$14, 126, 2, 3577);
    			add_location(b, file$14, 127, 28, 3626);
    			add_location(p4, file$14, 127, 2, 3600);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "critical", "");
    			add_location(button2, file$14, 129, 4, 3672);
    			add_location(div, file$14, 128, 2, 3662);
    			attr_dev(article, "type", "content");
    			add_location(article, file$14, 88, 0, 2243);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, article, anchor);
    			append_dev(article, h20);
    			append_dev(article, t1);
    			append_dev(article, p0);
    			append_dev(article, t3);
    			append_dev(article, field0);
    			mount_component(checkbox0, field0, null);
    			append_dev(article, t4);
    			append_dev(article, field1);
    			mount_component(checkbox1, field1, null);
    			append_dev(article, t5);
    			append_dev(article, field2);
    			mount_component(checkbox2, field2, null);
    			append_dev(article, t6);
    			append_dev(article, field3);
    			mount_component(checkbox3, field3, null);
    			append_dev(article, t7);
    			append_dev(article, field4);
    			mount_component(checkbox4, field4, null);
    			append_dev(article, t8);
    			append_dev(article, h21);
    			append_dev(article, t10);
    			append_dev(article, h30);
    			append_dev(h30, t11);
    			append_dev(h30, t12);
    			append_dev(article, t13);
    			append_dev(article, p1);
    			append_dev(article, t15);
    			append_dev(article, p2);
    			append_dev(p2, button0);
    			append_dev(button0, t16);
    			append_dev(button0, t17);
    			append_dev(article, t18);
    			append_dev(article, h31);
    			append_dev(h31, t19);
    			append_dev(h31, t20);
    			append_dev(article, t21);
    			append_dev(article, p3);
    			append_dev(p3, t22);
    			append_dev(p3, t23);
    			append_dev(p3, t24);
    			append_dev(article, t25);
    			append_dev(article, button1);
    			append_dev(article, t27);
    			append_dev(article, h22);
    			append_dev(article, t29);
    			append_dev(article, p4);
    			append_dev(p4, t30);
    			append_dev(p4, b);
    			append_dev(p4, t32);
    			append_dev(article, t33);
    			append_dev(article, div);
    			append_dev(div, button2);
    			append_dev(button2, t34);
    			append_dev(button2, t35);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					button1,
    					"click",
    					function () {
    						if (is_function(/*saveAs*/ ctx[5])) /*saveAs*/ ctx[5].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button2,
    					"click",
    					function () {
    						if (is_function(/*deleteConfirmation*/ ctx[2])) /*deleteConfirmation*/ ctx[2].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const checkbox0_changes = {};
    			if (dirty & /*item*/ 1) checkbox0_changes.checked = /*item*/ ctx[0].settings.sections.about.enabled;
    			checkbox0.$set(checkbox0_changes);
    			const checkbox1_changes = {};
    			if (dirty & /*item*/ 1) checkbox1_changes.checked = /*item*/ ctx[0].settings.sections.checklist.enabled;
    			checkbox1.$set(checkbox1_changes);
    			const checkbox2_changes = {};
    			if (dirty & /*item*/ 1) checkbox2_changes.checked = /*item*/ ctx[0].settings.sections.clips.enabled;
    			checkbox2.$set(checkbox2_changes);
    			const checkbox3_changes = {};
    			if (dirty & /*item*/ 1) checkbox3_changes.checked = /*item*/ ctx[0].settings.sections.time_entries.enabled;
    			checkbox3.$set(checkbox3_changes);
    			const checkbox4_changes = {};
    			if (dirty & /*item*/ 1) checkbox4_changes.checked = /*item*/ ctx[0].settings.sections.comments.enabled;
    			checkbox4.$set(checkbox4_changes);
    			if ((!current || dirty & /*item*/ 1) && t12_value !== (t12_value = /*item*/ ctx[0].type.titleize() + "")) set_data_dev(t12, t12_value);
    			if ((!current || dirty & /*item*/ 1) && t17_value !== (t17_value = /*item*/ ctx[0].type.titleize() + "")) set_data_dev(t17, t17_value);
    			if ((!current || dirty & /*item*/ 1) && t20_value !== (t20_value = /*item*/ ctx[0].type.titleize() + "")) set_data_dev(t20, t20_value);
    			if ((!current || dirty & /*item*/ 1) && t23_value !== (t23_value = /*item*/ ctx[0].type + "")) set_data_dev(t23, t23_value);
    			if ((!current || dirty & /*item*/ 1) && t35_value !== (t35_value = /*item*/ ctx[0].type.titleize() + "")) set_data_dev(t35, t35_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox0.$$.fragment, local);
    			transition_in(checkbox1.$$.fragment, local);
    			transition_in(checkbox2.$$.fragment, local);
    			transition_in(checkbox3.$$.fragment, local);
    			transition_in(checkbox4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox0.$$.fragment, local);
    			transition_out(checkbox1.$$.fragment, local);
    			transition_out(checkbox2.$$.fragment, local);
    			transition_out(checkbox3.$$.fragment, local);
    			transition_out(checkbox4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(article);
    			destroy_component(checkbox0);
    			destroy_component(checkbox1);
    			destroy_component(checkbox2);
    			destroy_component(checkbox3);
    			destroy_component(checkbox4);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$y.name,
    		type: "slot",
    		source: "(88:0) <Section {open} name=\\\"Settings\\\">",
    		ctx
    	});

    	return block;
    }

    // (134:0) {#if showDeleteConfirmation}
    function create_if_block$G(ctx) {
    	let current;
    	const deleteconfirmation = new DeleteConfirmation({ $$inline: true });

    	deleteconfirmation.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[4])) /*destroy*/ ctx[4].apply(this, arguments);
    	});

    	deleteconfirmation.$on("cancel", function () {
    		if (is_function(/*deleteConfirmationCancel*/ ctx[3])) /*deleteConfirmationCancel*/ ctx[3].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(deleteconfirmation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deleteconfirmation, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteconfirmation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteconfirmation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deleteconfirmation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$G.name,
    		type: "if",
    		source: "(134:0) {#if showDeleteConfirmation}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1c(ctx) {
    	let t;
    	let if_block_anchor;
    	let current;

    	const section = new Section({
    			props: {
    				open: /*open*/ ctx[1],
    				name: "Settings",
    				$$slots: { default: [create_default_slot$y] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*showDeleteConfirmation*/ ctx[6] && create_if_block$G(ctx);

    	const block = {
    		c: function create() {
    			create_component(section.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(section, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const section_changes = {};
    			if (dirty & /*open*/ 2) section_changes.open = /*open*/ ctx[1];

    			if (dirty & /*$$scope, deleteConfirmation, item, saveAs, toggleSection*/ 4261) {
    				section_changes.$$scope = { dirty, ctx };
    			}

    			section.$set(section_changes);

    			if (/*showDeleteConfirmation*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*showDeleteConfirmation*/ 64) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$G(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(section.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(section.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(section, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	var deferredUpdate,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		resource,
    		saveAs,
    		showDeleteConfirmation,
    		toggleSection,
    		update;

    	dispatch = createEventDispatcher();
    	resource = new project({});
    	var { item = void 0 } = $$props;
    	var { open = true } = $$props;
    	showDeleteConfirmation = false;

    	deleteConfirmation = function () {
    		return $$invalidate(6, showDeleteConfirmation = true);
    	};

    	deleteConfirmationCancel = function () {
    		return $$invalidate(6, showDeleteConfirmation = false);
    	};

    	destroy = function () {
    		return dispatch("destroy");
    	};

    	update = function (changes) {
    		var ecb, scb;

    		scb = function (updated) {
    			console.log("updated");
    			return conole.log(scb);
    		};

    		ecb = function (err) {
    			console.log("udpate err");
    			console.log(err);
    			return console.log("should refresh the proejct");
    		};

    		return resource.update(item, scb, ecb, null);
    	};

    	deferredUpdate = update.debounce(500);

    	toggleSection = function (e) {
    		var details;
    		details = e.detail;

    		// item.settings.sections[details.key].enabled = details.checked
    		return dispatch("update");
    	};

    	saveAs = function () {
    		var blob, jsonString;
    		jsonString = JSON.stringify(item, null, 2);
    		blob = new Blob([jsonString], { type: "text/plain;charset=utf-8" });

    		// note - the md5 works on the string loaded in the file, which is not the same as the file''s md5
    		// use a different handler for electron
    		return FileSaver_min.saveAs(blob, `project-${item.name.replace(/[^a-z0-9]/gi, "_").first(50).toLowerCase()}-${Date.create().toTimestampId()}--${md5(jsonString)}.json`);
    	};

    	const writable_props = ["item", "open"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$C.warn(`<SubDocument_Settings> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SubDocument_Settings", $$slots, []);

    	$$self.$set = $$props => {
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("open" in $$props) $$invalidate(1, open = $$props.open);
    	};

    	$$self.$capture_state = () => ({
    		deferredUpdate,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		dispatch,
    		resource,
    		saveAs,
    		showDeleteConfirmation,
    		toggleSection,
    		update,
    		push,
    		pop,
    		replace,
    		location: location$1,
    		createEventDispatcher,
    		FileSaver: FileSaver_min,
    		md5,
    		Resource: project,
    		Section,
    		FilteredList,
    		DeleteConfirmation,
    		Checkbox,
    		item,
    		open
    	});

    	$$self.$inject_state = $$props => {
    		if ("deferredUpdate" in $$props) deferredUpdate = $$props.deferredUpdate;
    		if ("deleteConfirmation" in $$props) $$invalidate(2, deleteConfirmation = $$props.deleteConfirmation);
    		if ("deleteConfirmationCancel" in $$props) $$invalidate(3, deleteConfirmationCancel = $$props.deleteConfirmationCancel);
    		if ("destroy" in $$props) $$invalidate(4, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("resource" in $$props) resource = $$props.resource;
    		if ("saveAs" in $$props) $$invalidate(5, saveAs = $$props.saveAs);
    		if ("showDeleteConfirmation" in $$props) $$invalidate(6, showDeleteConfirmation = $$props.showDeleteConfirmation);
    		if ("toggleSection" in $$props) $$invalidate(7, toggleSection = $$props.toggleSection);
    		if ("update" in $$props) update = $$props.update;
    		if ("item" in $$props) $$invalidate(0, item = $$props.item);
    		if ("open" in $$props) $$invalidate(1, open = $$props.open);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		item,
    		open,
    		deleteConfirmation,
    		deleteConfirmationCancel,
    		destroy,
    		saveAs,
    		showDeleteConfirmation,
    		toggleSection
    	];
    }

    class SubDocument_Settings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, { item: 0, open: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SubDocument_Settings",
    			options,
    			id: create_fragment$1c.name
    		});
    	}

    	get item() {
    		throw new Error("<SubDocument_Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<SubDocument_Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		throw new Error("<SubDocument_Settings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<SubDocument_Settings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\_Common\ProjectChild.svelte generated by Svelte v3.22.2 */

    const { Object: Object_1$f, console: console_1$D } = globals;
    const file$15 = "src\\svelte\\pages\\_Common\\ProjectChild.svelte";

    // (149:3) {#if item}
    function create_if_block$H(ctx) {
    	let a0;
    	let t0;
    	let t1;
    	let a1;
    	let t2;
    	let updating_item;
    	let updating_open;
    	let t3;
    	let a2;
    	let t4;
    	let updating_item_1;
    	let updating_open_1;
    	let t5;
    	let a3;
    	let t6;
    	let updating_item_2;
    	let updating_open_2;
    	let t7;
    	let a4;
    	let t8;
    	let updating_item_3;
    	let updating_open_3;
    	let t9;
    	let a5;
    	let t10;
    	let updating_item_4;
    	let updating_open_4;
    	let t11;
    	let a6;
    	let t12;
    	let updating_item_5;
    	let current;

    	const pageheader = new PageHeader({
    			props: {
    				$$slots: {
    					default: [create_default_slot$z],
    					"secondary-info": [create_secondary_info_slot$1],
    					icon: [create_icon_slot$1],
    					subtitle: [create_subtitle_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function description_item_binding(value) {
    		/*description_item_binding*/ ctx[24].call(null, value);
    	}

    	function description_open_binding(value) {
    		/*description_open_binding*/ ctx[25].call(null, value);
    	}

    	let description_props = {};

    	if (/*item*/ ctx[4] !== void 0) {
    		description_props.item = /*item*/ ctx[4];
    	}

    	if (/*item*/ ctx[4].settings.sections.about.expanded !== void 0) {
    		description_props.open = /*item*/ ctx[4].settings.sections.about.expanded;
    	}

    	const description = new Description({ props: description_props, $$inline: true });
    	binding_callbacks.push(() => bind(description, "item", description_item_binding));
    	binding_callbacks.push(() => bind(description, "open", description_open_binding));

    	description.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[2])) /*deferredUpdate*/ ctx[2].apply(this, arguments);
    	});

    	function checklist_item_binding(value) {
    		/*checklist_item_binding*/ ctx[26].call(null, value);
    	}

    	function checklist_open_binding(value) {
    		/*checklist_open_binding*/ ctx[27].call(null, value);
    	}

    	let checklist_props = { project: /*project*/ ctx[0] };

    	if (/*item*/ ctx[4] !== void 0) {
    		checklist_props.item = /*item*/ ctx[4];
    	}

    	if (/*item*/ ctx[4].settings.sections.checklist.expanded !== void 0) {
    		checklist_props.open = /*item*/ ctx[4].settings.sections.checklist.expanded;
    	}

    	const checklist = new Checklist$2({ props: checklist_props, $$inline: true });
    	binding_callbacks.push(() => bind(checklist, "item", checklist_item_binding));
    	binding_callbacks.push(() => bind(checklist, "open", checklist_open_binding));

    	checklist.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[2])) /*deferredUpdate*/ ctx[2].apply(this, arguments);
    	});

    	function clips_item_binding(value) {
    		/*clips_item_binding*/ ctx[28].call(null, value);
    	}

    	function clips_open_binding(value) {
    		/*clips_open_binding*/ ctx[29].call(null, value);
    	}

    	let clips_props = {};

    	if (/*item*/ ctx[4] !== void 0) {
    		clips_props.item = /*item*/ ctx[4];
    	}

    	if (/*item*/ ctx[4].settings.sections.clips.expanded !== void 0) {
    		clips_props.open = /*item*/ ctx[4].settings.sections.clips.expanded;
    	}

    	const clips = new ClipList({ props: clips_props, $$inline: true });
    	binding_callbacks.push(() => bind(clips, "item", clips_item_binding));
    	binding_callbacks.push(() => bind(clips, "open", clips_open_binding));

    	clips.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[2])) /*deferredUpdate*/ ctx[2].apply(this, arguments);
    	});

    	function time_item_binding(value) {
    		/*time_item_binding*/ ctx[30].call(null, value);
    	}

    	function time_open_binding(value) {
    		/*time_open_binding*/ ctx[31].call(null, value);
    	}

    	let time_props = { project: /*project*/ ctx[0] };

    	if (/*item*/ ctx[4] !== void 0) {
    		time_props.item = /*item*/ ctx[4];
    	}

    	if (/*item*/ ctx[4].settings.sections.time_entries.expanded !== void 0) {
    		time_props.open = /*item*/ ctx[4].settings.sections.time_entries.expanded;
    	}

    	const time = new Time$1({ props: time_props, $$inline: true });
    	binding_callbacks.push(() => bind(time, "item", time_item_binding));
    	binding_callbacks.push(() => bind(time, "open", time_open_binding));

    	time.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[2])) /*deferredUpdate*/ ctx[2].apply(this, arguments);
    	});

    	function comments_item_binding(value) {
    		/*comments_item_binding*/ ctx[32].call(null, value);
    	}

    	function comments_open_binding(value) {
    		/*comments_open_binding*/ ctx[33].call(null, value);
    	}

    	let comments_props = {};

    	if (/*item*/ ctx[4] !== void 0) {
    		comments_props.item = /*item*/ ctx[4];
    	}

    	if (/*item*/ ctx[4].settings.sections.comments.expanded !== void 0) {
    		comments_props.open = /*item*/ ctx[4].settings.sections.comments.expanded;
    	}

    	const comments = new Comments({ props: comments_props, $$inline: true });
    	binding_callbacks.push(() => bind(comments, "item", comments_item_binding));
    	binding_callbacks.push(() => bind(comments, "open", comments_open_binding));

    	comments.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[2])) /*deferredUpdate*/ ctx[2].apply(this, arguments);
    	});

    	function subdocument_settings_item_binding(value) {
    		/*subdocument_settings_item_binding*/ ctx[34].call(null, value);
    	}

    	let subdocument_settings_props = { open: true };

    	if (/*item*/ ctx[4] !== void 0) {
    		subdocument_settings_props.item = /*item*/ ctx[4];
    	}

    	const subdocument_settings = new SubDocument_Settings({
    			props: subdocument_settings_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(subdocument_settings, "item", subdocument_settings_item_binding));

    	subdocument_settings.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[2])) /*deferredUpdate*/ ctx[2].apply(this, arguments);
    	});

    	subdocument_settings.$on("destroy", function () {
    		if (is_function(/*destroy*/ ctx[3])) /*destroy*/ ctx[3].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			t0 = space();
    			create_component(pageheader.$$.fragment);
    			t1 = space();
    			a1 = element("a");
    			t2 = space();
    			create_component(description.$$.fragment);
    			t3 = space();
    			a2 = element("a");
    			t4 = space();
    			create_component(checklist.$$.fragment);
    			t5 = space();
    			a3 = element("a");
    			t6 = space();
    			create_component(clips.$$.fragment);
    			t7 = space();
    			a4 = element("a");
    			t8 = space();
    			create_component(time.$$.fragment);
    			t9 = space();
    			a5 = element("a");
    			t10 = space();
    			create_component(comments.$$.fragment);
    			t11 = space();
    			a6 = element("a");
    			t12 = space();
    			create_component(subdocument_settings.$$.fragment);
    			attr_dev(a0, "name", "top");
    			add_location(a0, file$15, 149, 6, 3480);
    			attr_dev(a1, "name", "about");
    			add_location(a1, file$15, 179, 6, 4534);
    			attr_dev(a2, "name", "checklist");
    			add_location(a2, file$15, 182, 6, 4677);
    			attr_dev(a3, "name", "clips");
    			add_location(a3, file$15, 185, 6, 4836);
    			attr_dev(a4, "name", "time");
    			add_location(a4, file$15, 188, 6, 4973);
    			attr_dev(a5, "name", "comments");
    			add_location(a5, file$15, 191, 6, 5125);
    			attr_dev(a6, "name", "settings");
    			add_location(a6, file$15, 194, 6, 5271);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(pageheader, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a1, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(description, target, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, a2, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(checklist, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, a3, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(clips, target, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, a4, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(time, target, anchor);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, a5, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(comments, target, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, a6, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(subdocument_settings, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const pageheader_changes = {};

    			if (dirty[0] & /*item, updateItem, project, deferredUpdate, collection*/ 55 | dirty[1] & /*$$scope*/ 16) {
    				pageheader_changes.$$scope = { dirty, ctx };
    			}

    			pageheader.$set(pageheader_changes);
    			const description_changes = {};

    			if (!updating_item && dirty[0] & /*item*/ 16) {
    				updating_item = true;
    				description_changes.item = /*item*/ ctx[4];
    				add_flush_callback(() => updating_item = false);
    			}

    			if (!updating_open && dirty[0] & /*item*/ 16) {
    				updating_open = true;
    				description_changes.open = /*item*/ ctx[4].settings.sections.about.expanded;
    				add_flush_callback(() => updating_open = false);
    			}

    			description.$set(description_changes);
    			const checklist_changes = {};
    			if (dirty[0] & /*project*/ 1) checklist_changes.project = /*project*/ ctx[0];

    			if (!updating_item_1 && dirty[0] & /*item*/ 16) {
    				updating_item_1 = true;
    				checklist_changes.item = /*item*/ ctx[4];
    				add_flush_callback(() => updating_item_1 = false);
    			}

    			if (!updating_open_1 && dirty[0] & /*item*/ 16) {
    				updating_open_1 = true;
    				checklist_changes.open = /*item*/ ctx[4].settings.sections.checklist.expanded;
    				add_flush_callback(() => updating_open_1 = false);
    			}

    			checklist.$set(checklist_changes);
    			const clips_changes = {};

    			if (!updating_item_2 && dirty[0] & /*item*/ 16) {
    				updating_item_2 = true;
    				clips_changes.item = /*item*/ ctx[4];
    				add_flush_callback(() => updating_item_2 = false);
    			}

    			if (!updating_open_2 && dirty[0] & /*item*/ 16) {
    				updating_open_2 = true;
    				clips_changes.open = /*item*/ ctx[4].settings.sections.clips.expanded;
    				add_flush_callback(() => updating_open_2 = false);
    			}

    			clips.$set(clips_changes);
    			const time_changes = {};
    			if (dirty[0] & /*project*/ 1) time_changes.project = /*project*/ ctx[0];

    			if (!updating_item_3 && dirty[0] & /*item*/ 16) {
    				updating_item_3 = true;
    				time_changes.item = /*item*/ ctx[4];
    				add_flush_callback(() => updating_item_3 = false);
    			}

    			if (!updating_open_3 && dirty[0] & /*item*/ 16) {
    				updating_open_3 = true;
    				time_changes.open = /*item*/ ctx[4].settings.sections.time_entries.expanded;
    				add_flush_callback(() => updating_open_3 = false);
    			}

    			time.$set(time_changes);
    			const comments_changes = {};

    			if (!updating_item_4 && dirty[0] & /*item*/ 16) {
    				updating_item_4 = true;
    				comments_changes.item = /*item*/ ctx[4];
    				add_flush_callback(() => updating_item_4 = false);
    			}

    			if (!updating_open_4 && dirty[0] & /*item*/ 16) {
    				updating_open_4 = true;
    				comments_changes.open = /*item*/ ctx[4].settings.sections.comments.expanded;
    				add_flush_callback(() => updating_open_4 = false);
    			}

    			comments.$set(comments_changes);
    			const subdocument_settings_changes = {};

    			if (!updating_item_5 && dirty[0] & /*item*/ 16) {
    				updating_item_5 = true;
    				subdocument_settings_changes.item = /*item*/ ctx[4];
    				add_flush_callback(() => updating_item_5 = false);
    			}

    			subdocument_settings.$set(subdocument_settings_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pageheader.$$.fragment, local);
    			transition_in(description.$$.fragment, local);
    			transition_in(checklist.$$.fragment, local);
    			transition_in(clips.$$.fragment, local);
    			transition_in(time.$$.fragment, local);
    			transition_in(comments.$$.fragment, local);
    			transition_in(subdocument_settings.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pageheader.$$.fragment, local);
    			transition_out(description.$$.fragment, local);
    			transition_out(checklist.$$.fragment, local);
    			transition_out(clips.$$.fragment, local);
    			transition_out(time.$$.fragment, local);
    			transition_out(comments.$$.fragment, local);
    			transition_out(subdocument_settings.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			if (detaching) detach_dev(t0);
    			destroy_component(pageheader, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a1);
    			if (detaching) detach_dev(t2);
    			destroy_component(description, detaching);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(a2);
    			if (detaching) detach_dev(t4);
    			destroy_component(checklist, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(a3);
    			if (detaching) detach_dev(t6);
    			destroy_component(clips, detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(a4);
    			if (detaching) detach_dev(t8);
    			destroy_component(time, detaching);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(a5);
    			if (detaching) detach_dev(t10);
    			destroy_component(comments, detaching);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(a6);
    			if (detaching) detach_dev(t12);
    			destroy_component(subdocument_settings, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$H.name,
    		type: "if",
    		source: "(149:3) {#if item}",
    		ctx
    	});

    	return block;
    }

    // (152:8) <h6 slot="subtitle">
    function create_subtitle_slot$1(ctx) {
    	let h6;
    	let t0;
    	let a;
    	let em;
    	let t1_value = /*project*/ ctx[0].name + "";
    	let t1;
    	let a_href_value;
    	let t2;
    	let t3_value = /*collection*/ ctx[1].titleize().singularize() + "";
    	let t3;
    	let current;
    	const favoritesmenu = new Favorites({ $$inline: true });

    	const block = {
    		c: function create() {
    			h6 = element("h6");
    			create_component(favoritesmenu.$$.fragment);
    			t0 = text(" >\n          ");
    			a = element("a");
    			em = element("em");
    			t1 = text(t1_value);
    			t2 = text("\n          >\n          ");
    			t3 = text(t3_value);
    			add_location(em, file$15, 153, 44, 3624);
    			attr_dev(a, "href", a_href_value = "#/projects/" + /*project*/ ctx[0].id);
    			add_location(a, file$15, 153, 10, 3590);
    			attr_dev(h6, "slot", "subtitle");
    			attr_dev(h6, "class", "svelte-11a96n3");
    			add_location(h6, file$15, 151, 8, 3527);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h6, anchor);
    			mount_component(favoritesmenu, h6, null);
    			append_dev(h6, t0);
    			append_dev(h6, a);
    			append_dev(a, em);
    			append_dev(em, t1);
    			append_dev(h6, t2);
    			append_dev(h6, t3);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*project*/ 1) && t1_value !== (t1_value = /*project*/ ctx[0].name + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty[0] & /*project*/ 1 && a_href_value !== (a_href_value = "#/projects/" + /*project*/ ctx[0].id)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if ((!current || dirty[0] & /*collection*/ 2) && t3_value !== (t3_value = /*collection*/ ctx[1].titleize().singularize() + "")) set_data_dev(t3, t3_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(favoritesmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(favoritesmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h6);
    			destroy_component(favoritesmenu);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_subtitle_slot$1.name,
    		type: "slot",
    		source: "(152:8) <h6 slot=\\\"subtitle\\\">",
    		ctx
    	});

    	return block;
    }

    // (158:8) <div slot="icon">
    function create_icon_slot$1(ctx) {
    	let div;
    	let updating_value;
    	let current;

    	function progress_value_binding(value) {
    		/*progress_value_binding*/ ctx[18].call(null, value);
    	}

    	let progress_props = { item: /*item*/ ctx[4], size: 36 };

    	if (/*item*/ ctx[4].progress !== void 0) {
    		progress_props.value = /*item*/ ctx[4].progress;
    	}

    	const progress = new Progress({ props: progress_props, $$inline: true });
    	binding_callbacks.push(() => bind(progress, "value", progress_value_binding));

    	progress.$on("update", function () {
    		if (is_function(/*updateItem*/ ctx[5])) /*updateItem*/ ctx[5].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(progress.$$.fragment);
    			attr_dev(div, "slot", "icon");
    			add_location(div, file$15, 157, 8, 3737);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(progress, div, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const progress_changes = {};
    			if (dirty[0] & /*item*/ 16) progress_changes.item = /*item*/ ctx[4];

    			if (!updating_value && dirty[0] & /*item*/ 16) {
    				updating_value = true;
    				progress_changes.value = /*item*/ ctx[4].progress;
    				add_flush_callback(() => updating_value = false);
    			}

    			progress.$set(progress_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(progress.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(progress.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(progress);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_icon_slot$1.name,
    		type: "slot",
    		source: "(158:8) <div slot=\\\"icon\\\">",
    		ctx
    	});

    	return block;
    }

    // (160:8) <div slot="secondary-info">
    function create_secondary_info_slot$1(ctx) {
    	let div0;
    	let div3;
    	let div1;
    	let div1_present_value;
    	let t;
    	let div2;
    	let div2_present_value;
    	let current;

    	const duedatepopover = new DueDate({
    			props: {
    				item: /*project*/ ctx[0],
    				value: /*item*/ ctx[4].due_date,
    				isListItem: false
    			},
    			$$inline: true
    		});

    	duedatepopover.$on("update", function () {
    		if (is_function(/*updateItem*/ ctx[5])) /*updateItem*/ ctx[5].apply(this, arguments);
    	});

    	duedatepopover.$on("open", /*open_handler*/ ctx[20]);
    	duedatepopover.$on("close", /*close_handler*/ ctx[21]);

    	const estimatepopover = new Time({
    			props: { item: /*item*/ ctx[4], isListItem: false },
    			$$inline: true
    		});

    	estimatepopover.$on("update", function () {
    		if (is_function(/*updateItem*/ ctx[5])) /*updateItem*/ ctx[5].apply(this, arguments);
    	});

    	estimatepopover.$on("open", /*open_handler_1*/ ctx[22]);
    	estimatepopover.$on("close", /*close_handler_1*/ ctx[23]);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			create_component(duedatepopover.$$.fragment);
    			t = space();
    			div2 = element("div");
    			create_component(estimatepopover.$$.fragment);
    			attr_dev(div1, "flex", "initial");
    			attr_dev(div1, "present", div1_present_value = /*item*/ ctx[4].due_date != null);
    			add_location(div1, file$15, 165, 12, 4053);
    			attr_dev(div2, "flex", "initial");
    			attr_dev(div2, "present", div2_present_value = (/*item*/ ctx[4].estimate || 0) > 0);
    			set_style(div2, "padding-left", "8px");
    			add_location(div2, file$15, 168, 12, 4265);
    			attr_dev(div3, "layout", "row");
    			add_location(div3, file$15, 160, 10, 3984);
    			attr_dev(div0, "slot", "secondary-info");
    			add_location(div0, file$15, 159, 8, 3946);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, div3);
    			append_dev(div3, div1);
    			mount_component(duedatepopover, div1, null);
    			append_dev(div3, t);
    			append_dev(div3, div2);
    			mount_component(estimatepopover, div2, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const duedatepopover_changes = {};
    			if (dirty[0] & /*project*/ 1) duedatepopover_changes.item = /*project*/ ctx[0];
    			if (dirty[0] & /*item*/ 16) duedatepopover_changes.value = /*item*/ ctx[4].due_date;
    			duedatepopover.$set(duedatepopover_changes);

    			if (!current || dirty[0] & /*item*/ 16 && div1_present_value !== (div1_present_value = /*item*/ ctx[4].due_date != null)) {
    				attr_dev(div1, "present", div1_present_value);
    			}

    			const estimatepopover_changes = {};
    			if (dirty[0] & /*item*/ 16) estimatepopover_changes.item = /*item*/ ctx[4];
    			estimatepopover.$set(estimatepopover_changes);

    			if (!current || dirty[0] & /*item*/ 16 && div2_present_value !== (div2_present_value = (/*item*/ ctx[4].estimate || 0) > 0)) {
    				attr_dev(div2, "present", div2_present_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(duedatepopover.$$.fragment, local);
    			transition_in(estimatepopover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(duedatepopover.$$.fragment, local);
    			transition_out(estimatepopover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(duedatepopover);
    			destroy_component(estimatepopover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_secondary_info_slot$1.name,
    		type: "slot",
    		source: "(160:8) <div slot=\\\"secondary-info\\\">",
    		ctx
    	});

    	return block;
    }

    // (151:6) <PageHeader >
    function create_default_slot$z(ctx) {
    	let t0;
    	let t1;
    	let updating_value;
    	let t2;
    	let current;

    	function inlineinput_value_binding(value) {
    		/*inlineinput_value_binding*/ ctx[19].call(null, value);
    	}

    	let inlineinput_props = { style: "margin-left: -2px" };

    	if (/*item*/ ctx[4].name !== void 0) {
    		inlineinput_props.value = /*item*/ ctx[4].name;
    	}

    	const inlineinput = new InlineInput({ props: inlineinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(inlineinput, "value", inlineinput_value_binding));

    	inlineinput.$on("update", function () {
    		if (is_function(/*deferredUpdate*/ ctx[2])) /*deferredUpdate*/ ctx[2].apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			t0 = space();
    			t1 = space();
    			create_component(inlineinput.$$.fragment);
    			t2 = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(inlineinput, target, anchor);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const inlineinput_changes = {};

    			if (!updating_value && dirty[0] & /*item*/ 16) {
    				updating_value = true;
    				inlineinput_changes.value = /*item*/ ctx[4].name;
    				add_flush_callback(() => updating_value = false);
    			}

    			inlineinput.$set(inlineinput_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inlineinput.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inlineinput.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			destroy_component(inlineinput, detaching);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$z.name,
    		type: "slot",
    		source: "(151:6) <PageHeader >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1d(ctx) {
    	let title_value;
    	let t;
    	let div;
    	let current;
    	document.title = title_value = /*title*/ ctx[6];
    	let if_block = /*item*/ ctx[4] && create_if_block$H(ctx);

    	const block = {
    		c: function create() {
    			t = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			add_location(div, file$15, 147, 0, 3454);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*title*/ 64) && title_value !== (title_value = /*title*/ ctx[6])) {
    				document.title = title_value;
    			}

    			if (/*item*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*item*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$H(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	var deferredUpdate,
    		destroy,
    		expandState,
    		getProject,
    		item,
    		jump,
    		list,
    		resource,
    		setSubtitle,
    		setTitle,
    		subresource,
    		updateItem,
    		updateProject;

    	var { params = void 0 } = $$props;
    	var { project: project$1 = void 0 } = $$props;
    	var { collection = void 0 } = $$props;
    	resource = new project();
    	subresource = new sub_document();
    	item = void 0;
    	list = [];

    	getProject = function () {
    		var scb;

    		scb = function (doc) {
    			$$invalidate(0, project$1 = doc);
    			console.log(subresource);
    			console.log("GET RPOJECT SCB");
    			$$invalidate(4, item = subresource.upgradeModel(project$1[collection].find({ id: params.id })));
    			return console.log(item);
    		};

    		// unless item? 404
    		return resource.selectOne(params.project_id, scb, null, null);
    	};

    	getProject();

    	updateProject = function () {
    		var ecb, scb;

    		scb = function (updated) {
    			
    		};

    		//console.log "updated"
    		ecb = function (err) {
    			console.error(err);
    			return getProject();
    		};

    		return resource.update(project$1, scb, ecb, null);
    	};

    	updateItem = function (e) {
    		//console.log e.detail
    		Object.merge(item, e.detail);

    		updateProject();
    		return $$invalidate(4, item); // force reaction
    	};

    	deferredUpdate = updateProject.debounce(500);

    	destroy = function () {
    		var ecb, scb;
    		project$1[collection].remove({ id: params.id });

    		scb = function (updated) {
    			return push(`/projects/${project$1.id}`); // go back to project page
    		};

    		ecb = function (err) {
    			console.log("udpate err");
    			console.log(err);
    			return getProject();
    		};

    		return resource.update(project$1, scb, ecb, null);
    	};

    	jump = function (anchorName) {
    		var elem, scrollContainer;
    		elem = u(`[name=${anchorName}]`);
    		scrollContainer = u("body > main > section").first();
    		return scrollContainer.scrollTop = elem.first().offsetTop - 40;
    	};

    	expandState = function (expanded) {
    		return ["details", "description", "checklist", "time_entries", "comments", "clips"].forEach(function (section) {
    			return $$invalidate(4, item.settings.sections[section].expanded = expanded, item);
    		});
    	};

    	setTitle = function (val) {
    		if (val != null) {
    			return `${project$1.name} > ${val.name}`;
    		} else {
    			return "";
    		}
    	};

    	setSubtitle = function (val) {
    		switch (val) {
    			case "tasks":
    				return "Task";
    			case "assignments":
    				return "Assignments";
    			case "documents":
    				return "Documents";
    		}
    	};

    	const writable_props = ["params", "project", "collection"];

    	Object_1$f.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$D.warn(`<ProjectChild> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ProjectChild", $$slots, []);

    	function progress_value_binding(value) {
    		item.progress = value;
    		$$invalidate(4, item);
    	}

    	function inlineinput_value_binding(value) {
    		item.name = value;
    		$$invalidate(4, item);
    	}

    	function open_handler(event) {
    		bubble($$self, event);
    	}

    	function close_handler(event) {
    		bubble($$self, event);
    	}

    	function open_handler_1(event) {
    		bubble($$self, event);
    	}

    	function close_handler_1(event) {
    		bubble($$self, event);
    	}

    	function description_item_binding(value) {
    		item = value;
    		$$invalidate(4, item);
    	}

    	function description_open_binding(value) {
    		item.settings.sections.about.expanded = value;
    		$$invalidate(4, item);
    	}

    	function checklist_item_binding(value) {
    		item = value;
    		$$invalidate(4, item);
    	}

    	function checklist_open_binding(value) {
    		item.settings.sections.checklist.expanded = value;
    		$$invalidate(4, item);
    	}

    	function clips_item_binding(value) {
    		item = value;
    		$$invalidate(4, item);
    	}

    	function clips_open_binding(value) {
    		item.settings.sections.clips.expanded = value;
    		$$invalidate(4, item);
    	}

    	function time_item_binding(value) {
    		item = value;
    		$$invalidate(4, item);
    	}

    	function time_open_binding(value) {
    		item.settings.sections.time_entries.expanded = value;
    		$$invalidate(4, item);
    	}

    	function comments_item_binding(value) {
    		item = value;
    		$$invalidate(4, item);
    	}

    	function comments_open_binding(value) {
    		item.settings.sections.comments.expanded = value;
    		$$invalidate(4, item);
    	}

    	function subdocument_settings_item_binding(value) {
    		item = value;
    		$$invalidate(4, item);
    	}

    	$$self.$set = $$props => {
    		if ("params" in $$props) $$invalidate(7, params = $$props.params);
    		if ("project" in $$props) $$invalidate(0, project$1 = $$props.project);
    		if ("collection" in $$props) $$invalidate(1, collection = $$props.collection);
    	};

    	$$self.$capture_state = () => ({
    		deferredUpdate,
    		destroy,
    		expandState,
    		getProject,
    		item,
    		jump,
    		list,
    		resource,
    		setSubtitle,
    		setTitle,
    		subresource,
    		updateItem,
    		updateProject,
    		push,
    		Resource: project,
    		SubDocument: sub_document,
    		InlineInput,
    		DeleteConfirmation,
    		FavoritesMenu: Favorites,
    		PageHeader,
    		Description,
    		Checklist: Checklist$2,
    		Time: Time$1,
    		Comments,
    		Clips: ClipList,
    		SubDocument_Settings,
    		Progress,
    		DueDatePopover: DueDate,
    		EstimatePopover: Time,
    		params,
    		project: project$1,
    		collection,
    		title,
    		subtitle
    	});

    	$$self.$inject_state = $$props => {
    		if ("deferredUpdate" in $$props) $$invalidate(2, deferredUpdate = $$props.deferredUpdate);
    		if ("destroy" in $$props) $$invalidate(3, destroy = $$props.destroy);
    		if ("expandState" in $$props) expandState = $$props.expandState;
    		if ("getProject" in $$props) getProject = $$props.getProject;
    		if ("item" in $$props) $$invalidate(4, item = $$props.item);
    		if ("jump" in $$props) jump = $$props.jump;
    		if ("list" in $$props) list = $$props.list;
    		if ("resource" in $$props) resource = $$props.resource;
    		if ("setSubtitle" in $$props) $$invalidate(13, setSubtitle = $$props.setSubtitle);
    		if ("setTitle" in $$props) $$invalidate(14, setTitle = $$props.setTitle);
    		if ("subresource" in $$props) subresource = $$props.subresource;
    		if ("updateItem" in $$props) $$invalidate(5, updateItem = $$props.updateItem);
    		if ("updateProject" in $$props) updateProject = $$props.updateProject;
    		if ("params" in $$props) $$invalidate(7, params = $$props.params);
    		if ("project" in $$props) $$invalidate(0, project$1 = $$props.project);
    		if ("collection" in $$props) $$invalidate(1, collection = $$props.collection);
    		if ("title" in $$props) $$invalidate(6, title = $$props.title);
    		if ("subtitle" in $$props) subtitle = $$props.subtitle;
    	};

    	let title;
    	let subtitle;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*setTitle, item*/ 16400) {
    			//}
    			 $$invalidate(6, title = setTitle(item));
    		}

    		if ($$self.$$.dirty[0] & /*setSubtitle, collection*/ 8194) {
    			 subtitle = setSubtitle(collection);
    		}
    	};

    	return [
    		project$1,
    		collection,
    		deferredUpdate,
    		destroy,
    		item,
    		updateItem,
    		title,
    		params,
    		expandState,
    		getProject,
    		jump,
    		list,
    		resource,
    		setSubtitle,
    		setTitle,
    		subresource,
    		updateProject,
    		subtitle,
    		progress_value_binding,
    		inlineinput_value_binding,
    		open_handler,
    		close_handler,
    		open_handler_1,
    		close_handler_1,
    		description_item_binding,
    		description_open_binding,
    		checklist_item_binding,
    		checklist_open_binding,
    		clips_item_binding,
    		clips_open_binding,
    		time_item_binding,
    		time_open_binding,
    		comments_item_binding,
    		comments_open_binding,
    		subdocument_settings_item_binding
    	];
    }

    class ProjectChild extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, { params: 7, project: 0, collection: 1 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ProjectChild",
    			options,
    			id: create_fragment$1d.name
    		});
    	}

    	get params() {
    		throw new Error("<ProjectChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<ProjectChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get project() {
    		throw new Error("<ProjectChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set project(value) {
    		throw new Error("<ProjectChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get collection() {
    		throw new Error("<ProjectChild>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set collection(value) {
    		throw new Error("<ProjectChild>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\Documents\Show.svelte generated by Svelte v3.22.2 */

    // (8:0) <PageContent>
    function create_default_slot$A(ctx) {
    	let current;

    	const projectchild = new ProjectChild({
    			props: {
    				collection: "documents",
    				params: /*params*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(projectchild.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(projectchild, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const projectchild_changes = {};
    			if (dirty & /*params*/ 1) projectchild_changes.params = /*params*/ ctx[0];
    			projectchild.$set(projectchild_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(projectchild.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(projectchild.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(projectchild, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$A.name,
    		type: "slot",
    		source: "(8:0) <PageContent>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1e(ctx) {
    	let current;

    	const pagecontent = new PageContent({
    			props: {
    				$$slots: { default: [create_default_slot$A] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pagecontent.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagecontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const pagecontent_changes = {};

    			if (dirty & /*$$scope, params*/ 3) {
    				pagecontent_changes.$$scope = { dirty, ctx };
    			}

    			pagecontent.$set(pagecontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagecontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagecontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagecontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	var { params = {} } = $$props;
    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Show> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Show", $$slots, []);

    	$$self.$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({ ProjectChild, PageContent, params });

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [params];
    }

    class Show$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Show",
    			options,
    			id: create_fragment$1e.name
    		});
    	}

    	get params() {
    		throw new Error("<Show>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Show>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\Tasks\Show.svelte generated by Svelte v3.22.2 */

    // (8:0) <PageContent>
    function create_default_slot$B(ctx) {
    	let current;

    	const projectchild = new ProjectChild({
    			props: {
    				collection: "tasks",
    				params: /*params*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(projectchild.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(projectchild, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const projectchild_changes = {};
    			if (dirty & /*params*/ 1) projectchild_changes.params = /*params*/ ctx[0];
    			projectchild.$set(projectchild_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(projectchild.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(projectchild.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(projectchild, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$B.name,
    		type: "slot",
    		source: "(8:0) <PageContent>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1f(ctx) {
    	let current;

    	const pagecontent = new PageContent({
    			props: {
    				$$slots: { default: [create_default_slot$B] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pagecontent.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagecontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const pagecontent_changes = {};

    			if (dirty & /*$$scope, params*/ 3) {
    				pagecontent_changes.$$scope = { dirty, ctx };
    			}

    			pagecontent.$set(pagecontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagecontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagecontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagecontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	var { params = {} } = $$props;
    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Show> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Show", $$slots, []);

    	$$self.$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({ ProjectChild, PageContent, params });

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [params];
    }

    class Show$2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Show",
    			options,
    			id: create_fragment$1f.name
    		});
    	}

    	get params() {
    		throw new Error("<Show>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Show>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\Assignments\Show.svelte generated by Svelte v3.22.2 */

    // (8:0) <PageContent>
    function create_default_slot$C(ctx) {
    	let current;

    	const projectchild = new ProjectChild({
    			props: {
    				collection: "assignments",
    				params: /*params*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(projectchild.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(projectchild, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const projectchild_changes = {};
    			if (dirty & /*params*/ 1) projectchild_changes.params = /*params*/ ctx[0];
    			projectchild.$set(projectchild_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(projectchild.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(projectchild.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(projectchild, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$C.name,
    		type: "slot",
    		source: "(8:0) <PageContent>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1g(ctx) {
    	let current;

    	const pagecontent = new PageContent({
    			props: {
    				$$slots: { default: [create_default_slot$C] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(pagecontent.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(pagecontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const pagecontent_changes = {};

    			if (dirty & /*$$scope, params*/ 3) {
    				pagecontent_changes.$$scope = { dirty, ctx };
    			}

    			pagecontent.$set(pagecontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagecontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagecontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(pagecontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	var { params = {} } = $$props;
    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Show> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Show", $$slots, []);

    	$$self.$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({ ProjectChild, PageContent, params });

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [params];
    }

    class Show$3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Show",
    			options,
    			id: create_fragment$1g.name
    		});
    	}

    	get params() {
    		throw new Error("<Show>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Show>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\components\Form\InlineInput\InlinePassword.svelte generated by Svelte v3.22.2 */
    const file$16 = "src\\svelte\\components\\Form\\InlineInput\\InlinePassword.svelte";
    const get_default_slot_changes$6 = dirty => ({ label: dirty & /*label*/ 16384 });
    const get_default_slot_context$6 = ctx => ({ label: /*label*/ ctx[14] });

    // (156:0) {:else}
    function create_else_block$n(ctx) {
    	let div;
    	let span;
    	let div_class_value;
    	let current;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[28].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[27], get_default_slot_context$6);
    	const default_slot_or_fallback = default_slot || fallback_block$6(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(span, "ellipsis", "");
    			attr_dev(span, "class", "svelte-1nk72sv");
    			add_location(span, file$16, 160, 4, 2819);
    			attr_dev(div, "id", /*id*/ ctx[8]);
    			attr_dev(div, "class", div_class_value = "" + (null_to_empty(/*labelClasses*/ ctx[6]) + " svelte-1nk72sv"));
    			attr_dev(div, "ellipsis", "");
    			attr_dev(div, "style", /*style*/ ctx[2]);
    			add_location(div, file$16, 156, 2, 2750);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(span, null);
    			}

    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				span,
    				"click",
    				function () {
    					if (is_function(/*click*/ ctx[9])) /*click*/ ctx[9].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, label*/ 134234112) {
    					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[27], get_default_slot_context$6), get_slot_changes(default_slot_template, /*$$scope*/ ctx[27], dirty, get_default_slot_changes$6));
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 16384) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty & /*id*/ 256) {
    				attr_dev(div, "id", /*id*/ ctx[8]);
    			}

    			if (!current || dirty & /*labelClasses*/ 64 && div_class_value !== (div_class_value = "" + (null_to_empty(/*labelClasses*/ ctx[6]) + " svelte-1nk72sv"))) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty & /*style*/ 4) {
    				attr_dev(div, "style", /*style*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$n.name,
    		type: "else",
    		source: "(156:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (144:0) {#if editing && (isText || isNumber)}
    function create_if_block$I(ctx) {
    	let input;
    	let input_class_value;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "class", input_class_value = "" + (null_to_empty(/*inputClasses*/ ctx[7]) + " svelte-1nk72sv"));
    			attr_dev(input, "style", /*inputStyle*/ ctx[3]);
    			attr_dev(input, "type", /*type*/ ctx[4]);
    			input.value = /*value*/ ctx[0];
    			attr_dev(input, "placeholder", /*placeholder*/ ctx[5]);
    			add_location(input, file$16, 144, 2, 2499);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, input, anchor);
    			/*input_binding*/ ctx[30](input);
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(input, "click", stop_propagation(/*click_handler*/ ctx[29]), false, false, true),
    				listen_dev(
    					input,
    					"input",
    					function () {
    						if (is_function(/*handleInput*/ ctx[11])) /*handleInput*/ ctx[11].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					input,
    					"keyup",
    					function () {
    						if (is_function(/*handleKeyup*/ ctx[12])) /*handleKeyup*/ ctx[12].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					input,
    					"blur",
    					function () {
    						if (is_function(/*handleBlur*/ ctx[10])) /*handleBlur*/ ctx[10].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*inputClasses*/ 128 && input_class_value !== (input_class_value = "" + (null_to_empty(/*inputClasses*/ ctx[7]) + " svelte-1nk72sv"))) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if (dirty & /*inputStyle*/ 8) {
    				attr_dev(input, "style", /*inputStyle*/ ctx[3]);
    			}

    			if (dirty & /*type*/ 16) {
    				attr_dev(input, "type", /*type*/ ctx[4]);
    			}

    			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
    				prop_dev(input, "value", /*value*/ ctx[0]);
    			}

    			if (dirty & /*placeholder*/ 32) {
    				attr_dev(input, "placeholder", /*placeholder*/ ctx[5]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding*/ ctx[30](null);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$I.name,
    		type: "if",
    		source: "(144:0) {#if editing && (isText || isNumber)}",
    		ctx
    	});

    	return block;
    }

    // (161:50) <span ellipsis>
    function fallback_block$6(ctx) {
    	let span1;
    	let t;
    	let span0;

    	const block = {
    		c: function create() {
    			span1 = element("span");
    			t = text(/*label*/ ctx[14]);
    			span0 = element("span");
    			attr_dev(span0, "spacer", "");
    			attr_dev(span0, "class", "svelte-1nk72sv");
    			add_location(span0, file$16, 160, 72, 2887);
    			attr_dev(span1, "ellipsis", "");
    			attr_dev(span1, "class", "svelte-1nk72sv");
    			add_location(span1, file$16, 160, 50, 2865);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span1, anchor);
    			append_dev(span1, t);
    			append_dev(span1, span0);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 16384) set_data_dev(t, /*label*/ ctx[14]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$6.name,
    		type: "fallback",
    		source: "(161:50) <span ellipsis>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1h(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$I, create_else_block$n];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*editing*/ ctx[1] && (/*isText*/ ctx[15] || /*isNumber*/ ctx[16])) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	var click,
    		clickCount,
    		clickReset,
    		delayedReset,
    		dispatch,
    		double,
    		handleBlur,
    		handleInput,
    		handleKeyup,
    		inputEl,
    		label,
    		originalValue,
    		single;

    	dispatch = createEventDispatcher();
    	var { value = "" } = $$props;
    	var { style = void 0 } = $$props;
    	var { inputStyle = void 0 } = $$props;
    	var { type = "text" } = $$props;
    	var { placeholder = "" } = $$props;
    	var { labelClasses = "" } = $$props;
    	var { inputClasses = "" } = $$props;
    	var { doubleClick = true } = $$props;
    	var { id = void 0 } = $$props;
    	var { delay = 250 } = $$props;
    	var { editing = false } = $$props;
    	inputEl = void 0;
    	label = void 0;
    	originalValue = void 0;

    	const toggle = async _ => {
    		$$invalidate(1, editing = !editing);
    		originalValue = value;

    		if (editing) {
    			await tick();
    			inputEl.focus();
    		}
    	};

    	handleInput = function (e) {
    		if (isNumber) {
    			$$invalidate(0, value = +e.target.value);
    		}

    		return $$invalidate(0, value = e.target.value);
    	};

    	handleKeyup = function (e) {
    		dispatch("keyup", value);

    		switch (e.keyCode) {
    			case 13:
    				return inputEl.blur();
    			case 27:
    				$$invalidate(0, value = originalValue);
    				return inputEl.blur();
    		}
    	};

    	// }
    	handleBlur = function (_) {
    		var unchanged;
    		unchanged = value === originalValue;
    		toggle();

    		if (!unchanged) {
    			return dispatch("update", value);
    		}
    	};

    	// Click tracking
    	clickCount = 0;

    	clickReset = function () {
    		switch (clickCount) {
    			case 1:
    				return single();
    			case 2:
    				return double();
    			default:
    				return clickCount = 0;
    		}
    	};

    	// }
    	delayedReset = clickReset.debounce(delay);

    	single = function () {
    		clickCount = 0;

    		if (!doubleClick) {
    			toggle();
    		}

    		return dispatch("clicked", id);
    	};

    	double = function () {
    		clickCount = 0;

    		if (doubleClick) {
    			toggle();
    		}

    		return dispatch("doubleclicked", id);
    	};

    	click = function () {
    		clickCount++;
    		return delayedReset();
    	};

    	const writable_props = [
    		"value",
    		"style",
    		"inputStyle",
    		"type",
    		"placeholder",
    		"labelClasses",
    		"inputClasses",
    		"doubleClick",
    		"id",
    		"delay",
    		"editing"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InlinePassword> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("InlinePassword", $$slots, ['default']);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			$$invalidate(13, inputEl = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("style" in $$props) $$invalidate(2, style = $$props.style);
    		if ("inputStyle" in $$props) $$invalidate(3, inputStyle = $$props.inputStyle);
    		if ("type" in $$props) $$invalidate(4, type = $$props.type);
    		if ("placeholder" in $$props) $$invalidate(5, placeholder = $$props.placeholder);
    		if ("labelClasses" in $$props) $$invalidate(6, labelClasses = $$props.labelClasses);
    		if ("inputClasses" in $$props) $$invalidate(7, inputClasses = $$props.inputClasses);
    		if ("doubleClick" in $$props) $$invalidate(17, doubleClick = $$props.doubleClick);
    		if ("id" in $$props) $$invalidate(8, id = $$props.id);
    		if ("delay" in $$props) $$invalidate(18, delay = $$props.delay);
    		if ("editing" in $$props) $$invalidate(1, editing = $$props.editing);
    		if ("$$scope" in $$props) $$invalidate(27, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		click,
    		clickCount,
    		clickReset,
    		delayedReset,
    		dispatch,
    		double,
    		handleBlur,
    		handleInput,
    		handleKeyup,
    		inputEl,
    		label,
    		originalValue,
    		single,
    		tick,
    		createEventDispatcher,
    		value,
    		style,
    		inputStyle,
    		type,
    		placeholder,
    		labelClasses,
    		inputClasses,
    		doubleClick,
    		id,
    		delay,
    		editing,
    		toggle,
    		isText,
    		isNumber
    	});

    	$$self.$inject_state = $$props => {
    		if ("click" in $$props) $$invalidate(9, click = $$props.click);
    		if ("clickCount" in $$props) clickCount = $$props.clickCount;
    		if ("clickReset" in $$props) clickReset = $$props.clickReset;
    		if ("delayedReset" in $$props) delayedReset = $$props.delayedReset;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("double" in $$props) double = $$props.double;
    		if ("handleBlur" in $$props) $$invalidate(10, handleBlur = $$props.handleBlur);
    		if ("handleInput" in $$props) $$invalidate(11, handleInput = $$props.handleInput);
    		if ("handleKeyup" in $$props) $$invalidate(12, handleKeyup = $$props.handleKeyup);
    		if ("inputEl" in $$props) $$invalidate(13, inputEl = $$props.inputEl);
    		if ("label" in $$props) $$invalidate(14, label = $$props.label);
    		if ("originalValue" in $$props) originalValue = $$props.originalValue;
    		if ("single" in $$props) single = $$props.single;
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("style" in $$props) $$invalidate(2, style = $$props.style);
    		if ("inputStyle" in $$props) $$invalidate(3, inputStyle = $$props.inputStyle);
    		if ("type" in $$props) $$invalidate(4, type = $$props.type);
    		if ("placeholder" in $$props) $$invalidate(5, placeholder = $$props.placeholder);
    		if ("labelClasses" in $$props) $$invalidate(6, labelClasses = $$props.labelClasses);
    		if ("inputClasses" in $$props) $$invalidate(7, inputClasses = $$props.inputClasses);
    		if ("doubleClick" in $$props) $$invalidate(17, doubleClick = $$props.doubleClick);
    		if ("id" in $$props) $$invalidate(8, id = $$props.id);
    		if ("delay" in $$props) $$invalidate(18, delay = $$props.delay);
    		if ("editing" in $$props) $$invalidate(1, editing = $$props.editing);
    		if ("isText" in $$props) $$invalidate(15, isText = $$props.isText);
    		if ("isNumber" in $$props) $$invalidate(16, isNumber = $$props.isNumber);
    	};

    	let isText;
    	let isNumber;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*type*/ 16) {
    			// Computed
    			 $$invalidate(15, isText = type === "text");
    		}

    		if ($$self.$$.dirty & /*type*/ 16) {
    			 $$invalidate(16, isNumber = type === "number");
    		}

    		if ($$self.$$.dirty & /*isNumber, value, placeholder, isText*/ 98337) {
    			 if (isNumber) {
    				$$invalidate(14, label = value === "" ? placeholder : value);
    			} else if (isText) {
    				$$invalidate(14, label = value ? value : placeholder);
    			}
    		}
    	};

    	return [
    		value,
    		editing,
    		style,
    		inputStyle,
    		type,
    		placeholder,
    		labelClasses,
    		inputClasses,
    		id,
    		click,
    		handleBlur,
    		handleInput,
    		handleKeyup,
    		inputEl,
    		label,
    		isText,
    		isNumber,
    		doubleClick,
    		delay,
    		clickCount,
    		clickReset,
    		delayedReset,
    		dispatch,
    		double,
    		originalValue,
    		single,
    		toggle,
    		$$scope,
    		$$slots,
    		click_handler,
    		input_binding
    	];
    }

    class InlinePassword extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {
    			value: 0,
    			style: 2,
    			inputStyle: 3,
    			type: 4,
    			placeholder: 5,
    			labelClasses: 6,
    			inputClasses: 7,
    			doubleClick: 17,
    			id: 8,
    			delay: 18,
    			editing: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InlinePassword",
    			options,
    			id: create_fragment$1h.name
    		});
    	}

    	get value() {
    		throw new Error("<InlinePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<InlinePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<InlinePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<InlinePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputStyle() {
    		throw new Error("<InlinePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputStyle(value) {
    		throw new Error("<InlinePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<InlinePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<InlinePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<InlinePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<InlinePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelClasses() {
    		throw new Error("<InlinePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelClasses(value) {
    		throw new Error("<InlinePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputClasses() {
    		throw new Error("<InlinePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputClasses(value) {
    		throw new Error("<InlinePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get doubleClick() {
    		throw new Error("<InlinePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set doubleClick(value) {
    		throw new Error("<InlinePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<InlinePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<InlinePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get delay() {
    		throw new Error("<InlinePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set delay(value) {
    		throw new Error("<InlinePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get editing() {
    		throw new Error("<InlinePassword>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set editing(value) {
    		throw new Error("<InlinePassword>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\svelte\pages\Settings\Settings.svelte generated by Svelte v3.22.2 */

    const { console: console_1$E } = globals;
    const file$17 = "src\\svelte\\pages\\Settings\\Settings.svelte";

    // (132:2) <PageHeader>
    function create_default_slot_1$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Settings");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(132:2) <PageHeader>",
    		ctx
    	});

    	return block;
    }

    // (130:0) <PageContent>
    function create_default_slot$D(ctx) {
    	let a;
    	let t0;
    	let t1;
    	let article;
    	let h20;
    	let t3;
    	let div0;
    	let t5;
    	let h21;
    	let t7;
    	let h22;
    	let t9;
    	let h30;
    	let t11;
    	let p0;
    	let t13;
    	let button0;
    	let t15;
    	let h31;
    	let t17;
    	let p1;
    	let t19;
    	let button1;
    	let button1_disabled_value;
    	let t21;
    	let h32;
    	let t23;
    	let h23;
    	let t25;
    	let p2;
    	let t27;
    	let button2;
    	let button2_disabled_value;
    	let t29;
    	let h24;
    	let t31;
    	let p3;
    	let t32;
    	let b;
    	let t34;
    	let button3;
    	let t36;
    	let h25;
    	let t38;
    	let div1;
    	let t39;
    	let t40;
    	let current;
    	let dispose;

    	const pageheader = new PageHeader({
    			props: {
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			t0 = space();
    			create_component(pageheader.$$.fragment);
    			t1 = space();
    			article = element("article");
    			h20 = element("h2");
    			h20.textContent = "Interface";
    			t3 = space();
    			div0 = element("div");
    			div0.textContent = "Interface tweaks will be going here.";
    			t5 = space();
    			h21 = element("h2");
    			h21.textContent = "Data";
    			t7 = space();
    			h22 = element("h2");
    			h22.textContent = "Warning, Items Below May Not Be Functional";
    			t9 = space();
    			h30 = element("h3");
    			h30.textContent = "Export All Data";
    			t11 = space();
    			p0 = element("p");
    			p0.textContent = "This will save your collections as a JSON file into your downloads folder. This does not export your settings.";
    			t13 = space();
    			button0 = element("button");
    			button0.textContent = "Save to Disk";
    			t15 = space();
    			h31 = element("h3");
    			h31.textContent = "Import";
    			t17 = space();
    			p1 = element("p");
    			p1.textContent = "Import data from a JSON file. This will create new IDs for all incoming items, so if you are importing a backup, you may end up with items having duplicate names.";
    			t19 = space();
    			button1 = element("button");
    			button1.textContent = "Import";
    			t21 = space();
    			h32 = element("h3");
    			h32.textContent = "Danger Zone";
    			t23 = space();
    			h23 = element("h2");
    			h23.textContent = "Restore";
    			t25 = space();
    			p2 = element("p");
    			p2.textContent = "This will clear all existing data (including on any synchronized databases) and load the contents of an export file into your system. Your settings will remain intact.";
    			t27 = space();
    			button2 = element("button");
    			button2.textContent = "Restore";
    			t29 = space();
    			h24 = element("h2");
    			h24.textContent = "Delete All Data";
    			t31 = space();
    			p3 = element("p");
    			t32 = text("This will delete all your data and settings. If you have synchronization enabled, ");
    			b = element("b");
    			b.textContent = "it will delete the data from your synchronized database as well.";
    			t34 = space();
    			button3 = element("button");
    			button3.textContent = "Delete";
    			t36 = space();
    			h25 = element("h2");
    			h25.textContent = "About";
    			t38 = space();
    			div1 = element("div");
    			t39 = text("Edition: ");
    			t40 = text(/*edition*/ ctx[1]);
    			attr_dev(a, "name", "top");
    			add_location(a, file$17, 130, 2, 3620);
    			add_location(h20, file$17, 135, 4, 3713);
    			add_location(div0, file$17, 137, 4, 3739);
    			add_location(h21, file$17, 142, 4, 3808);
    			add_location(h22, file$17, 144, 4, 3829);
    			add_location(h30, file$17, 146, 4, 3889);
    			add_location(p0, file$17, 147, 4, 3919);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "primary", "");
    			add_location(button0, file$17, 148, 4, 4042);
    			add_location(h31, file$17, 150, 4, 4119);
    			add_location(p1, file$17, 151, 4, 4140);
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "primary", "");
    			button1.disabled = button1_disabled_value = true;
    			add_location(button1, file$17, 152, 4, 4315);
    			add_location(h32, file$17, 154, 4, 4406);
    			add_location(h23, file$17, 156, 4, 4434);
    			add_location(p2, file$17, 157, 4, 4456);
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "critical", "");
    			button2.disabled = button2_disabled_value = true;
    			add_location(button2, file$17, 158, 4, 4636);
    			add_location(h24, file$17, 160, 4, 4726);
    			add_location(b, file$17, 161, 89, 4841);
    			add_location(p3, file$17, 161, 4, 4756);
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "critical", "");
    			add_location(button3, file$17, 162, 4, 4922);
    			add_location(h25, file$17, 165, 4, 4997);
    			add_location(div1, file$17, 166, 4, 5017);
    			attr_dev(article, "type", "content");
    			attr_dev(article, "class", "svelte-1gahdu4");
    			add_location(article, file$17, 132, 2, 3679);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, a, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(pageheader, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, article, anchor);
    			append_dev(article, h20);
    			append_dev(article, t3);
    			append_dev(article, div0);
    			append_dev(article, t5);
    			append_dev(article, h21);
    			append_dev(article, t7);
    			append_dev(article, h22);
    			append_dev(article, t9);
    			append_dev(article, h30);
    			append_dev(article, t11);
    			append_dev(article, p0);
    			append_dev(article, t13);
    			append_dev(article, button0);
    			append_dev(article, t15);
    			append_dev(article, h31);
    			append_dev(article, t17);
    			append_dev(article, p1);
    			append_dev(article, t19);
    			append_dev(article, button1);
    			append_dev(article, t21);
    			append_dev(article, h32);
    			append_dev(article, t23);
    			append_dev(article, h23);
    			append_dev(article, t25);
    			append_dev(article, p2);
    			append_dev(article, t27);
    			append_dev(article, button2);
    			append_dev(article, t29);
    			append_dev(article, h24);
    			append_dev(article, t31);
    			append_dev(article, p3);
    			append_dev(p3, t32);
    			append_dev(p3, b);
    			append_dev(article, t34);
    			append_dev(article, button3);
    			append_dev(article, t36);
    			append_dev(article, h25);
    			append_dev(article, t38);
    			append_dev(article, div1);
    			append_dev(div1, t39);
    			append_dev(div1, t40);
    			current = true;
    			if (remount) run_all(dispose);

    			dispose = [
    				listen_dev(
    					button0,
    					"click",
    					function () {
    						if (is_function(/*saveAs*/ ctx[4])) /*saveAs*/ ctx[4].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button1,
    					"click",
    					function () {
    						if (is_function(/*importData*/ ctx[2])) /*importData*/ ctx[2].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button2,
    					"click",
    					function () {
    						if (is_function(/*restore*/ ctx[3])) /*restore*/ ctx[3].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				),
    				listen_dev(
    					button3,
    					"click",
    					function () {
    						if (is_function(/*destroy*/ ctx[0])) /*destroy*/ ctx[0].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				)
    			];
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const pageheader_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				pageheader_changes.$$scope = { dirty, ctx };
    			}

    			pageheader.$set(pageheader_changes);
    			if (!current || dirty & /*edition*/ 2) set_data_dev(t40, /*edition*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pageheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pageheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t0);
    			destroy_component(pageheader, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(article);
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$D.name,
    		type: "slot",
    		source: "(130:0) <PageContent>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1i(ctx) {
    	let t;
    	let current;

    	const pagecontent = new PageContent({
    			props: {
    				$$slots: { default: [create_default_slot$D] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(pagecontent.$$.fragment);
    			document.title = "Settings";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(pagecontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const pagecontent_changes = {};

    			if (dirty & /*$$scope, edition, destroy, restore, importData, saveAs*/ 131103) {
    				pagecontent_changes.$$scope = { dirty, ctx };
    			}

    			pagecontent.$set(pagecontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagecontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagecontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(pagecontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	var destroy,
    		dispatch,
    		edition,
    		forceSync,
    		importData,
    		notificationPermssionRequest,
    		replicationDb,
    		replicationEnabled,
    		replicationRequiresAuthentication,
    		resource,
    		restore,
    		saveAs,
    		toggleSync,
    		updateDb,
    		updatePassword,
    		updateUser;

    	dispatch = createEventDispatcher();
    	resource = new project();
    	replicationEnabled = localStorage.getItem("sync");
    	replicationDb = localStorage.getItem("remote_db");
    	replicationRequiresAuthentication = localStorage.getItem("sync_authentication") || "false";

    	toggleSync = function () {
    		localStorage.setItem("sync", !(replicationEnabled === "true"));
    		return $$invalidate(9, replicationEnabled = localStorage.getItem("sync"));
    	};

    	updateDb = function (e) {
    		return console.log(e);
    	};

    	updateUser = function (e) {
    		return console.log(e);
    	};

    	updatePassword = function (e) {
    		return console.log(e);
    	};

    	saveAs = function () {
    		var projectLoadedScb;

    		projectLoadedScb = function (projects) {
    			var blob, jsonString, list;
    			list = projects;
    			jsonString = JSON.stringify(list, null, 2);
    			blob = new Blob([jsonString], { type: "text/plain;charset=utf-8" });

    			// note - the md5 works on the string loaded in the file, which is not the same as the file''s md5
    			// use a different handler for electron
    			return FileSaver_min.saveAs(blob, `braintapper-archive-${Date.create().toTimestampId()}--${md5(jsonString)}.json`);
    		};

    		return resource.select(projectLoadedScb, null, null);
    	};

    	forceSync = function () {
    		console.log(remoteDb);

    		if (typeof remoteDb !== "undefined" && remoteDb !== null) {
    			console.log("syncing to remote db");

    			return db.sync(remoteDb, { retry: true }).on("complete", function () {
    				return console.log("complete!");
    			}).on("change", function (change) {
    				// yo, something changed!
    				console.log("sync change");

    				return console.log(change);
    			}).on("paused", function (info) {
    				// replication was paused, usually because of a lost connection
    				console.log("sync paused");

    				return console.log(info);
    			}).on("active", function (info) {
    				// replication was resumed
    				console.log("sync active");

    				return console.log(info);
    			}).on("error", function (err) {
    				console.log("sync error");
    				return console.log(err);
    			});
    		}
    	};

    	importData = function () {
    		
    	};

    	restore = function () {
    		
    	};

    	destroy = function () {
    		
    	};

    	notificationPermssionRequest = function () {
    		return Notification.requestPermission().then(function (permission) {
    			var notification;

    			// If the user accepts, let''s create a notification
    			if (permission === "granted") {
    				notification = new Notification("Hi there!");
    			} else {
    				console.log("not granted");
    			}
    		});
    	};

    	if (electron) {
    		edition = "Desktop";
    	} else {
    		edition = "Web";
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$E.warn(`<Settings> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Settings", $$slots, []);

    	$$self.$capture_state = () => ({
    		destroy,
    		dispatch,
    		edition,
    		forceSync,
    		importData,
    		notificationPermssionRequest,
    		replicationDb,
    		replicationEnabled,
    		replicationRequiresAuthentication,
    		resource,
    		restore,
    		saveAs,
    		toggleSync,
    		updateDb,
    		updatePassword,
    		updateUser,
    		PageContent,
    		PageHeader,
    		FileSaver: FileSaver_min,
    		md5,
    		Project: project,
    		Checkbox,
    		InlineInput,
    		InlinePassword,
    		createEventDispatcher,
    		disableReplication
    	});

    	$$self.$inject_state = $$props => {
    		if ("destroy" in $$props) $$invalidate(0, destroy = $$props.destroy);
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("edition" in $$props) $$invalidate(1, edition = $$props.edition);
    		if ("forceSync" in $$props) forceSync = $$props.forceSync;
    		if ("importData" in $$props) $$invalidate(2, importData = $$props.importData);
    		if ("notificationPermssionRequest" in $$props) notificationPermssionRequest = $$props.notificationPermssionRequest;
    		if ("replicationDb" in $$props) replicationDb = $$props.replicationDb;
    		if ("replicationEnabled" in $$props) $$invalidate(9, replicationEnabled = $$props.replicationEnabled);
    		if ("replicationRequiresAuthentication" in $$props) replicationRequiresAuthentication = $$props.replicationRequiresAuthentication;
    		if ("resource" in $$props) resource = $$props.resource;
    		if ("restore" in $$props) $$invalidate(3, restore = $$props.restore);
    		if ("saveAs" in $$props) $$invalidate(4, saveAs = $$props.saveAs);
    		if ("toggleSync" in $$props) toggleSync = $$props.toggleSync;
    		if ("updateDb" in $$props) updateDb = $$props.updateDb;
    		if ("updatePassword" in $$props) updatePassword = $$props.updatePassword;
    		if ("updateUser" in $$props) updateUser = $$props.updateUser;
    		if ("disableReplication" in $$props) disableReplication = $$props.disableReplication;
    	};

    	let disableReplication;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*replicationEnabled*/ 512) {
    			 disableReplication = replicationEnabled != "true";
    		}
    	};

    	return [destroy, edition, importData, restore, saveAs];
    }

    class Settings$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Settings",
    			options,
    			id: create_fragment$1i.name
    		});
    	}
    }

    /* src\svelte\pages\Sync\Sync.svelte generated by Svelte v3.22.2 */

    const { console: console_1$F } = globals;
    const file$18 = "src\\svelte\\pages\\Sync\\Sync.svelte";

    // (117:2) <PageHeader>
    function create_default_slot_2$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Sync");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(117:2) <PageHeader>",
    		ctx
    	});

    	return block;
    }

    // (135:8) <InlineInput bind:value={replicationDb} on:update={updateDb} let:label>
    function create_default_slot_1$e(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*replicationDb*/ ctx[1]);
    			attr_dev(span, "ellipsis", "");
    			add_location(span, file$18, 135, 10, 3633);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*replicationDb*/ 2) set_data_dev(t, /*replicationDb*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(135:8) <InlineInput bind:value={replicationDb} on:update={updateDb} let:label>",
    		ctx
    	});

    	return block;
    }

    // (146:10) {#if web}
    function create_if_block$J(ctx) {
    	let li0;
    	let t1;
    	let li1;

    	const block = {
    		c: function create() {
    			li0 = element("li");
    			li0.textContent = "If you do not wanted to be prompted every time you sync, you need to upgrade to the desktop application.";
    			t1 = space();
    			li1 = element("li");
    			li1.textContent = "If you choose to cheat by embedding your credentials in the URL, you do so at your own peril. The URL is stored in plaintext in your browser's LocalStorage.";
    			add_location(li0, file$18, 146, 10, 3969);
    			add_location(li1, file$18, 149, 10, 4117);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, li1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(li1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$J.name,
    		type: "if",
    		source: "(146:10) {#if web}",
    		ctx
    	});

    	return block;
    }

    // (115:0) <PageContent>
    function create_default_slot$E(ctx) {
    	let a;
    	let t0;
    	let t1;
    	let article;
    	let h20;
    	let t3;
    	let h21;
    	let t5;
    	let h3;
    	let t7;
    	let div0;
    	let t9;
    	let div2;
    	let field0;
    	let t10;
    	let field1;
    	let label;
    	let t12;
    	let updating_value;
    	let t13;
    	let field2;
    	let t14;
    	let div1;
    	let h4;
    	let t16;
    	let ul;
    	let t17;
    	let li;
    	let t18;
    	let code0;
    	let t20;
    	let code1;
    	let t22;
    	let code2;
    	let t24;
    	let t25;
    	let button;
    	let t26;
    	let t27;
    	let div3;
    	let t28;
    	let t29_value = JSON.stringify(/*disableReplication*/ ctx[7]) + "";
    	let t29;
    	let t30;
    	let current;
    	let dispose;

    	const pageheader = new PageHeader({
    			props: {
    				$$slots: { default: [create_default_slot_2$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const checkbox0 = new Checkbox({
    			props: {
    				checked: /*replicationEnabled*/ ctx[2],
    				key: "sync",
    				label: "Enable Synchronization with Remote Database"
    			},
    			$$inline: true
    		});

    	checkbox0.$on("change", function () {
    		if (is_function(/*toggleSync*/ ctx[4])) /*toggleSync*/ ctx[4].apply(this, arguments);
    	});

    	function inlineinput_value_binding(value) {
    		/*inlineinput_value_binding*/ ctx[19].call(null, value);
    	}

    	let inlineinput_props = {
    		$$slots: {
    			default: [
    				create_default_slot_1$e,
    				({ label }) => ({ 20: label }),
    				({ label }) => label ? 1048576 : 0
    			]
    		},
    		$$scope: { ctx }
    	};

    	if (/*replicationDb*/ ctx[1] !== void 0) {
    		inlineinput_props.value = /*replicationDb*/ ctx[1];
    	}

    	const inlineinput = new InlineInput({ props: inlineinput_props, $$inline: true });
    	binding_callbacks.push(() => bind(inlineinput, "value", inlineinput_value_binding));

    	inlineinput.$on("update", function () {
    		if (is_function(/*updateDb*/ ctx[5])) /*updateDb*/ ctx[5].apply(this, arguments);
    	});

    	const checkbox1 = new Checkbox({
    			props: {
    				checked: /*replicationRequiresAuthentication*/ ctx[3],
    				key: "authentication",
    				label: "Database Requires Authentication"
    			},
    			$$inline: true
    		});

    	checkbox1.$on("change", function () {
    		if (is_function(/*toggleSync*/ ctx[4])) /*toggleSync*/ ctx[4].apply(this, arguments);
    	});

    	let if_block = /*web*/ ctx[6] && create_if_block$J(ctx);

    	const block = {
    		c: function create() {
    			a = element("a");
    			t0 = space();
    			create_component(pageheader.$$.fragment);
    			t1 = space();
    			article = element("article");
    			h20 = element("h2");
    			h20.textContent = "Data";
    			t3 = space();
    			h21 = element("h2");
    			h21.textContent = "Warning, Not All Features Below May Not Be Functional";
    			t5 = space();
    			h3 = element("h3");
    			h3.textContent = "Synchronized Database";
    			t7 = space();
    			div0 = element("div");
    			div0.textContent = "This application can sync with any CouchDB compatible database.";
    			t9 = space();
    			div2 = element("div");
    			field0 = element("field");
    			create_component(checkbox0.$$.fragment);
    			t10 = space();
    			field1 = element("field");
    			label = element("label");
    			label.textContent = "Database URL";
    			t12 = space();
    			create_component(inlineinput.$$.fragment);
    			t13 = space();
    			field2 = element("field");
    			create_component(checkbox1.$$.fragment);
    			t14 = space();
    			div1 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Warnings";
    			t16 = space();
    			ul = element("ul");
    			if (if_block) if_block.c();
    			t17 = space();
    			li = element("li");
    			t18 = text("If your URL starts with ");
    			code0 = element("code");
    			code0.textContent = "http://";
    			t20 = text(" and not ");
    			code1 = element("code");
    			code1.textContent = "https://";
    			t22 = text(" your data will be transmitted unencrypted. Do not use ");
    			code2 = element("code");
    			code2.textContent = "http://";
    			t24 = text(" if you can avoid it.");
    			t25 = space();
    			button = element("button");
    			t26 = text("Force Sync");
    			t27 = space();
    			div3 = element("div");
    			t28 = text("!!disableReplication: ");
    			t29 = text(t29_value);
    			t30 = text(" :: disableReplication");
    			attr_dev(a, "name", "top");
    			add_location(a, file$18, 115, 2, 3013);
    			add_location(h20, file$18, 121, 4, 3098);
    			add_location(h21, file$18, 123, 4, 3117);
    			add_location(h3, file$18, 124, 4, 3185);
    			add_location(div0, file$18, 125, 4, 3220);
    			add_location(field0, file$18, 129, 6, 3323);
    			attr_dev(label, "for", "field");
    			add_location(label, file$18, 133, 8, 3503);
    			add_location(field1, file$18, 132, 6, 3487);
    			add_location(field2, file$18, 138, 6, 3715);
    			add_location(h4, file$18, 143, 8, 3908);
    			add_location(code0, file$18, 154, 36, 4374);
    			add_location(code1, file$18, 154, 65, 4403);
    			add_location(code2, file$18, 154, 141, 4479);
    			add_location(li, file$18, 153, 10, 4333);
    			add_location(ul, file$18, 144, 8, 3934);
    			add_location(div1, file$18, 142, 6, 3894);
    			add_location(div2, file$18, 128, 4, 3311);
    			attr_dev(button, "type", "button");
    			attr_dev(button, "primary", "");
    			button.disabled = /*disableReplication*/ ctx[7];
    			add_location(button, file$18, 159, 4, 4579);
    			add_location(div3, file$18, 160, 4, 4684);
    			attr_dev(article, "type", "content");
    			attr_dev(article, "class", "svelte-ie93mi");
    			add_location(article, file$18, 117, 2, 3066);
    		},
    		m: function mount(target, anchor, remount) {
    			insert_dev(target, a, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(pageheader, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, article, anchor);
    			append_dev(article, h20);
    			append_dev(article, t3);
    			append_dev(article, h21);
    			append_dev(article, t5);
    			append_dev(article, h3);
    			append_dev(article, t7);
    			append_dev(article, div0);
    			append_dev(article, t9);
    			append_dev(article, div2);
    			append_dev(div2, field0);
    			mount_component(checkbox0, field0, null);
    			append_dev(div2, t10);
    			append_dev(div2, field1);
    			append_dev(field1, label);
    			append_dev(field1, t12);
    			mount_component(inlineinput, field1, null);
    			append_dev(div2, t13);
    			append_dev(div2, field2);
    			mount_component(checkbox1, field2, null);
    			append_dev(div2, t14);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(div1, t16);
    			append_dev(div1, ul);
    			if (if_block) if_block.m(ul, null);
    			append_dev(ul, t17);
    			append_dev(ul, li);
    			append_dev(li, t18);
    			append_dev(li, code0);
    			append_dev(li, t20);
    			append_dev(li, code1);
    			append_dev(li, t22);
    			append_dev(li, code2);
    			append_dev(li, t24);
    			append_dev(article, t25);
    			append_dev(article, button);
    			append_dev(button, t26);
    			append_dev(article, t27);
    			append_dev(article, div3);
    			append_dev(div3, t28);
    			append_dev(div3, t29);
    			append_dev(div3, t30);
    			current = true;
    			if (remount) dispose();

    			dispose = listen_dev(
    				button,
    				"click",
    				function () {
    					if (is_function(/*forceSync*/ ctx[0])) /*forceSync*/ ctx[0].apply(this, arguments);
    				},
    				false,
    				false,
    				false
    			);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const pageheader_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				pageheader_changes.$$scope = { dirty, ctx };
    			}

    			pageheader.$set(pageheader_changes);
    			const checkbox0_changes = {};
    			if (dirty & /*replicationEnabled*/ 4) checkbox0_changes.checked = /*replicationEnabled*/ ctx[2];
    			checkbox0.$set(checkbox0_changes);
    			const inlineinput_changes = {};

    			if (dirty & /*$$scope, replicationDb*/ 2097154) {
    				inlineinput_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_value && dirty & /*replicationDb*/ 2) {
    				updating_value = true;
    				inlineinput_changes.value = /*replicationDb*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			inlineinput.$set(inlineinput_changes);
    			const checkbox1_changes = {};
    			if (dirty & /*replicationRequiresAuthentication*/ 8) checkbox1_changes.checked = /*replicationRequiresAuthentication*/ ctx[3];
    			checkbox1.$set(checkbox1_changes);

    			if (/*web*/ ctx[6]) {
    				if (if_block) ; else {
    					if_block = create_if_block$J(ctx);
    					if_block.c();
    					if_block.m(ul, t17);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty & /*disableReplication*/ 128) {
    				prop_dev(button, "disabled", /*disableReplication*/ ctx[7]);
    			}

    			if ((!current || dirty & /*disableReplication*/ 128) && t29_value !== (t29_value = JSON.stringify(/*disableReplication*/ ctx[7]) + "")) set_data_dev(t29, t29_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pageheader.$$.fragment, local);
    			transition_in(checkbox0.$$.fragment, local);
    			transition_in(inlineinput.$$.fragment, local);
    			transition_in(checkbox1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pageheader.$$.fragment, local);
    			transition_out(checkbox0.$$.fragment, local);
    			transition_out(inlineinput.$$.fragment, local);
    			transition_out(checkbox1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t0);
    			destroy_component(pageheader, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(article);
    			destroy_component(checkbox0);
    			destroy_component(inlineinput);
    			destroy_component(checkbox1);
    			if (if_block) if_block.d();
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$E.name,
    		type: "slot",
    		source: "(115:0) <PageContent>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1j(ctx) {
    	let t;
    	let current;

    	const pagecontent = new PageContent({
    			props: {
    				$$slots: { default: [create_default_slot$E] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(pagecontent.$$.fragment);
    			document.title = "Sync";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(pagecontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const pagecontent_changes = {};

    			if (dirty & /*$$scope, disableReplication, forceSync, web, replicationRequiresAuthentication, toggleSync, replicationDb, updateDb, replicationEnabled*/ 2097407) {
    				pagecontent_changes.$$scope = { dirty, ctx };
    			}

    			pagecontent.$set(pagecontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pagecontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pagecontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(pagecontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	var destroy,
    		dispatch,
    		forceSync,
    		importData,
    		notificationPermssionRequest,
    		replicationDb,
    		replicationEnabled,
    		replicationRequiresAuthentication,
    		resource,
    		restore,
    		saveAs,
    		subscribe,
    		syncing,
    		toggleSync,
    		updateDb,
    		updatePassword,
    		updateUser,
    		web;

    	dispatch = createEventDispatcher();
    	resource = new project();
    	replicationEnabled = localStorage.getItem("sync");
    	replicationDb = localStorage.getItem("remote_db");
    	replicationRequiresAuthentication = localStorage.getItem("sync_authentication") || "false";
    	syncing = void 0;

    	subscribe = isSyncing.subscribe(function (val) {
    		return syncing = val;
    	});

    	toggleSync = function () {
    		localStorage.setItem("sync", !(replicationEnabled === "true"));
    		return $$invalidate(2, replicationEnabled = localStorage.getItem("sync"));
    	};

    	web = !window.electron;

    	updateDb = function (e) {
    		return console.log(e);
    	};

    	updateUser = function (e) {
    		return console.log(e);
    	};

    	updatePassword = function (e) {
    		return console.log(e);
    	};

    	saveAs = function () {
    		var projectLoadedScb;

    		projectLoadedScb = function (projects) {
    			var blob, jsonString, list;
    			list = projects;
    			jsonString = JSON.stringify(list, null, 2);
    			blob = new Blob([jsonString], { type: "text/plain;charset=utf-8" });

    			// note - the md5 works on the string loaded in the file, which is not the same as the file''s md5
    			// use a different handler for electron
    			return FileSaver_min.saveAs(blob, `braintapper-archive-${Date.create().toTimestampId()}--${md5(jsonString)}.json`);
    		};

    		return resource.select(projectLoadedScb, null, null);
    	};

    	forceSync = function () {
    		console.log("force sync");
    		window.pouch.sync_pending = true;
    		return window.pouch.sync();
    	};

    	importData = function () {
    		
    	};

    	restore = function () {
    		
    	};

    	destroy = function () {
    		
    	};

    	notificationPermssionRequest = function () {
    		return Notification.requestPermission().then(function (permission) {
    			var notification;

    			// If the user accepts, let''s create a notification
    			if (permission === "granted") {
    				notification = new Notification("Hi there!");
    			} else {
    				console.log("not granted");
    			}
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$F.warn(`<Sync> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Sync", $$slots, []);

    	function inlineinput_value_binding(value) {
    		replicationDb = value;
    		$$invalidate(1, replicationDb);
    	}

    	$$self.$capture_state = () => ({
    		destroy,
    		dispatch,
    		forceSync,
    		importData,
    		notificationPermssionRequest,
    		replicationDb,
    		replicationEnabled,
    		replicationRequiresAuthentication,
    		resource,
    		restore,
    		saveAs,
    		subscribe,
    		syncing,
    		toggleSync,
    		updateDb,
    		updatePassword,
    		updateUser,
    		web,
    		isSyncing,
    		PageContent,
    		PageHeader,
    		FileSaver: FileSaver_min,
    		md5,
    		Project: project,
    		Checkbox,
    		InlineInput,
    		InlinePassword,
    		createEventDispatcher,
    		disableReplication
    	});

    	$$self.$inject_state = $$props => {
    		if ("destroy" in $$props) destroy = $$props.destroy;
    		if ("dispatch" in $$props) dispatch = $$props.dispatch;
    		if ("forceSync" in $$props) $$invalidate(0, forceSync = $$props.forceSync);
    		if ("importData" in $$props) importData = $$props.importData;
    		if ("notificationPermssionRequest" in $$props) notificationPermssionRequest = $$props.notificationPermssionRequest;
    		if ("replicationDb" in $$props) $$invalidate(1, replicationDb = $$props.replicationDb);
    		if ("replicationEnabled" in $$props) $$invalidate(2, replicationEnabled = $$props.replicationEnabled);
    		if ("replicationRequiresAuthentication" in $$props) $$invalidate(3, replicationRequiresAuthentication = $$props.replicationRequiresAuthentication);
    		if ("resource" in $$props) resource = $$props.resource;
    		if ("restore" in $$props) restore = $$props.restore;
    		if ("saveAs" in $$props) saveAs = $$props.saveAs;
    		if ("subscribe" in $$props) subscribe = $$props.subscribe;
    		if ("syncing" in $$props) syncing = $$props.syncing;
    		if ("toggleSync" in $$props) $$invalidate(4, toggleSync = $$props.toggleSync);
    		if ("updateDb" in $$props) $$invalidate(5, updateDb = $$props.updateDb);
    		if ("updatePassword" in $$props) updatePassword = $$props.updatePassword;
    		if ("updateUser" in $$props) updateUser = $$props.updateUser;
    		if ("web" in $$props) $$invalidate(6, web = $$props.web);
    		if ("disableReplication" in $$props) $$invalidate(7, disableReplication = $$props.disableReplication);
    	};

    	let disableReplication;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*replicationEnabled*/ 4) {
    			 $$invalidate(7, disableReplication = replicationEnabled != "true");
    		}
    	};

    	return [
    		forceSync,
    		replicationDb,
    		replicationEnabled,
    		replicationRequiresAuthentication,
    		toggleSync,
    		updateDb,
    		web,
    		disableReplication,
    		destroy,
    		dispatch,
    		importData,
    		notificationPermssionRequest,
    		resource,
    		restore,
    		saveAs,
    		subscribe,
    		syncing,
    		updatePassword,
    		updateUser,
    		inlineinput_value_binding
    	];
    }

    class Sync extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sync",
    			options,
    			id: create_fragment$1j.name
    		});
    	}
    }

    /* src\svelte\pages\Help\Help.svelte generated by Svelte v3.22.2 */

    const file$19 = "src\\svelte\\pages\\Help\\Help.svelte";

    function create_fragment$1k(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Help";
    			add_location(h1, file$19, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1k($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Help> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Help", $$slots, []);
    	return [];
    }

    class Help extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Help",
    			options,
    			id: create_fragment$1k.name
    		});
    	}
    }

    /* src\svelte\App.svelte generated by Svelte v3.22.2 */

    const { console: console_1$G } = globals;
    const file$1a = "src\\svelte\\App.svelte";

    // (100:2) <div slot="nav">
    function create_nav_slot(ctx) {
    	let div;
    	let current;
    	const sidenavigator = new SideNavigator({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(sidenavigator.$$.fragment);
    			attr_dev(div, "slot", "nav");
    			add_location(div, file$1a, 99, 2, 2069);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(sidenavigator, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sidenavigator.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sidenavigator.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(sidenavigator);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_nav_slot.name,
    		type: "slot",
    		source: "(100:2) <div slot=\\\"nav\\\">",
    		ctx
    	});

    	return block;
    }

    // (99:0) <LeftSplit headerSize="40px" contentScrollable={true}>
    function create_default_slot$F(ctx) {
    	let t;
    	let div0_1;
    	let current;

    	const router = new Router({
    			props: { routes: /*routes*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			div0_1 = element("div");
    			create_component(router.$$.fragment);
    			attr_dev(div0_1, "slot", "default");
    			attr_dev(div0_1, "class", "svelte-14203ne");
    			add_location(div0_1, file$1a, 102, 2, 2121);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, div0_1, anchor);
    			mount_component(router, div0_1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const router_changes = {};
    			if (dirty & /*routes*/ 2) router_changes.routes = /*routes*/ ctx[1];
    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div0_1);
    			destroy_component(router);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$F.name,
    		type: "slot",
    		source: "(99:0) <LeftSplit headerSize=\\\"40px\\\" contentScrollable={true}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1l(ctx) {
    	let title_value;
    	let t0;
    	let t1;
    	let updating_show;
    	let current;
    	document.title = title_value = /*appName*/ ctx[0];

    	const leftsplit = new LeftSplit({
    			props: {
    				headerSize: "40px",
    				contentScrollable: true,
    				$$slots: {
    					default: [create_default_slot$F],
    					nav: [create_nav_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	function toast_1_show_binding(value) {
    		/*toast_1_show_binding*/ ctx[7].call(null, value);
    	}

    	let toast_1_props = {
    		message: /*toastMessage*/ ctx[3],
    		delay: 2
    	};

    	if (/*showToast*/ ctx[2] !== void 0) {
    		toast_1_props.show = /*showToast*/ ctx[2];
    	}

    	const toast_1 = new Toast({ props: toast_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(toast_1, "show", toast_1_show_binding));

    	const block = {
    		c: function create() {
    			t0 = space();
    			create_component(leftsplit.$$.fragment);
    			t1 = space();
    			create_component(toast_1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			mount_component(leftsplit, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(toast_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*appName*/ 1) && title_value !== (title_value = /*appName*/ ctx[0])) {
    				document.title = title_value;
    			}

    			const leftsplit_changes = {};

    			if (dirty & /*$$scope, routes*/ 258) {
    				leftsplit_changes.$$scope = { dirty, ctx };
    			}

    			leftsplit.$set(leftsplit_changes);
    			const toast_1_changes = {};
    			if (dirty & /*toastMessage*/ 8) toast_1_changes.message = /*toastMessage*/ ctx[3];

    			if (!updating_show && dirty & /*showToast*/ 4) {
    				updating_show = true;
    				toast_1_changes.show = /*showToast*/ ctx[2];
    				add_flush_callback(() => updating_show = false);
    			}

    			toast_1.$set(toast_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(leftsplit.$$.fragment, local);
    			transition_in(toast_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(leftsplit.$$.fragment, local);
    			transition_out(toast_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			destroy_component(leftsplit, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(toast_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	var appName, pdbCallback, routes, showToast, toast, toastMessage;
    	showToast = false;
    	toastMessage = "";

    	routes = {
    		"/": Home,
    		"/projects": Index,
    		"/projects/all": Index,
    		"/projects/:id": Show,
    		"/projects/:project_id/tasks/:id": Show$2,
    		"/projects/:project_id/assignments/:id": Show$3,
    		"/projects/:project_id/documents/:id": Show$1,
    		"/settings": Settings$1,
    		"/help": Help,
    		"/sync": Sync,
    		"*": FourOFour
    	};

    	appName = "Braintapper";

    	pdbCallback = function () {
    		console.log("window.db");
    		console.log(window.db);
    		console.log("remotedb");
    		return console.log(window.remoteDb);
    	};

    	window.db = new PouchDB("braintapper", { auto_compaction: true });
    	window.db.createIndex({ index: { fields: ["type"] } });
    	window.pouch = new pouch_db(window.db);

    	toast = function (message) {
    		$$invalidate(2, showToast = true);
    		return $$invalidate(3, toastMessage = message);
    	};

    	onMount(function () {
    		window.pouch.sync_store = isSyncing;
    		window.pouch.notifier = toast;
    		return window.pouch.sync();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$G.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("App", $$slots, []);

    	function toast_1_show_binding(value) {
    		showToast = value;
    		$$invalidate(2, showToast);
    	}

    	$$self.$capture_state = () => ({
    		appName,
    		pdbCallback,
    		routes,
    		showToast,
    		toast,
    		toastMessage,
    		onMount,
    		Router,
    		isSyncing,
    		Pouch: pouch_db,
    		FourOFour,
    		LeftSplit,
    		Toast,
    		SideNavigator,
    		Home,
    		Projects: Index,
    		Project: Show,
    		Document: Show$1,
    		Task: Show$2,
    		Assignment: Show$3,
    		Settings: Settings$1,
    		Sync,
    		Help,
    		show
    	});

    	$$self.$inject_state = $$props => {
    		if ("appName" in $$props) $$invalidate(0, appName = $$props.appName);
    		if ("pdbCallback" in $$props) pdbCallback = $$props.pdbCallback;
    		if ("routes" in $$props) $$invalidate(1, routes = $$props.routes);
    		if ("showToast" in $$props) $$invalidate(2, showToast = $$props.showToast);
    		if ("toast" in $$props) toast = $$props.toast;
    		if ("toastMessage" in $$props) $$invalidate(3, toastMessage = $$props.toastMessage);
    		if ("show" in $$props) show = $$props.show;
    	};

    	let show;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*showToast*/ 4) {
    			 show = showToast;
    		}
    	};

    	return [
    		appName,
    		routes,
    		showToast,
    		toastMessage,
    		pdbCallback,
    		toast,
    		show,
    		toast_1_show_binding
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$1l.name
    		});
    	}
    }

    var sugarCore = createCommonjsModule(function (module) {
    /*
     *  Sugar v2.0.6
     *
     *  Freely distributable and licensed under the MIT-style license.
     *  Copyright (c) Andrew Plummer
     *  https://sugarjs.com/
     *
     * ---------------------------- */
    (function() {

      /***
       * @module Core
       * @description Core functionality including the ability to define methods and
       *              extend onto natives.
       *
       ***/

      // The global to export.
      var Sugar;

      // The name of Sugar in the global namespace.
      var SUGAR_GLOBAL = 'Sugar';

      // Natives available on initialization. Letting Object go first to ensure its
      // global is set by the time the rest are checking for chainable Object methods.
      var NATIVE_NAMES = 'Object Number String Array Date RegExp Function';

      // Static method flag
      var STATIC   = 0x1;

      // Instance method flag
      var INSTANCE = 0x2;

      // IE8 has a broken defineProperty but no defineProperties so this saves a try/catch.
      var PROPERTY_DESCRIPTOR_SUPPORT = !!(Object.defineProperty && Object.defineProperties);

      var globalContext = getGlobal();

      // Whether object instance methods can be mapped to the prototype.
      var allowObjectPrototype = false;

      // A map from Array to SugarArray.
      var namespacesByName = {};

      // A map from [object Object] to namespace.
      var namespacesByClassString = {};

      // Defining properties.
      // istanbul ignore next
      var defineProperty = PROPERTY_DESCRIPTOR_SUPPORT ?  Object.defineProperty : definePropertyShim;

      // A default chainable class for unknown types.
      var DefaultChainable = getNewChainableClass('Chainable');


      // Global methods

      function getGlobal() {
        // Get global context by keyword here to avoid issues with libraries
        // that can potentially alter this script's context object.
        return testGlobal(typeof commonjsGlobal !== 'undefined' && commonjsGlobal) ||
               testGlobal(typeof window !== 'undefined' && window);
      }

      function testGlobal(obj) {
        // Note that Rhino uses a different "global" keyword so perform an
        // extra check here to ensure that it's actually the global object.
        return obj && obj.Object === Object ? obj : null;
      }

      function setupGlobal() {
        Sugar = globalContext[SUGAR_GLOBAL];
        // istanbul ignore if
        if (Sugar) {
          // Reuse already defined Sugar global object.
          return;
        }
        Sugar = function(arg) {
          forEachProperty(Sugar, function(sugarNamespace, name) {
            // Although only the only enumerable properties on the global
            // object are Sugar namespaces, environments that can't set
            // non-enumerable properties will step through the utility methods
            // as well here, so use this check to only allow true namespaces.
            if (hasOwn(namespacesByName, name)) {
              sugarNamespace.extend(arg);
            }
          });
          return Sugar;
        };
        // istanbul ignore else
        if ( module.exports) {
          // Node or webpack environment
          module.exports = Sugar;
        } else {
          // Unwrapped browser environment
          try {
            globalContext[SUGAR_GLOBAL] = Sugar;
          } catch (e) {
            // Contexts such as QML have a read-only global context.
          }
        }
        forEachProperty(NATIVE_NAMES.split(' '), function(name) {
          createNamespace(name);
        });
        setGlobalProperties();
      }

      /***
       * @method createNamespace(name)
       * @returns SugarNamespace
       * @namespace Sugar
       * @short Creates a new Sugar namespace.
       * @extra This method is for plugin developers who want to define methods to be
       *        used with natives that Sugar does not handle by default. The new
       *        namespace will appear on the `Sugar` global with all the methods of
       *        normal namespaces, including the ability to define new methods. When
       *        extended, any defined methods will be mapped to `name` in the global
       *        context.
       *
       * @example
       *
       *   Sugar.createNamespace('Boolean');
       *
       * @param {string} name - The namespace name.
       *
       ***/
      function createNamespace(name) {

        // Is the current namespace Object?
        var isObject = name === 'Object';

        // A Sugar namespace is also a chainable class: Sugar.Array, etc.
        var sugarNamespace = getNewChainableClass(name);

        /***
         * @method extend([opts])
         * @returns Sugar
         * @namespace Sugar
         * @short Extends Sugar defined methods onto natives.
         * @extra This method can be called on individual namespaces like
         *        `Sugar.Array` or on the `Sugar` global itself, in which case
         *        [opts] will be forwarded to each `extend` call. For more,
         *        see `extending`.
         *
         * @options
         *
         *   methods           An array of method names to explicitly extend.
         *
         *   except            An array of method names or global namespaces (`Array`,
         *                     `String`) to explicitly exclude. Namespaces should be the
         *                     actual global objects, not strings.
         *
         *   namespaces        An array of global namespaces (`Array`, `String`) to
         *                     explicitly extend. Namespaces should be the actual
         *                     global objects, not strings.
         *
         *   enhance           A shortcut to disallow all "enhance" flags at once
         *                     (flags listed below). For more, see `enhanced methods`.
         *                     Default is `true`.
         *
         *   enhanceString     A boolean allowing String enhancements. Default is `true`.
         *
         *   enhanceArray      A boolean allowing Array enhancements. Default is `true`.
         *
         *   objectPrototype   A boolean allowing Sugar to extend Object.prototype
         *                     with instance methods. This option is off by default
         *                     and should generally not be used except with caution.
         *                     For more, see `object methods`.
         *
         * @example
         *
         *   Sugar.Array.extend();
         *   Sugar.extend();
         *
         * @option {Array<string>} [methods]
         * @option {Array<string|NativeConstructor>} [except]
         * @option {Array<NativeConstructor>} [namespaces]
         * @option {boolean} [enhance]
         * @option {boolean} [enhanceString]
         * @option {boolean} [enhanceArray]
         * @option {boolean} [objectPrototype]
         * @param {ExtendOptions} [opts]
         *
         ***
         * @method extend([opts])
         * @returns SugarNamespace
         * @namespace SugarNamespace
         * @short Extends Sugar defined methods for a specific namespace onto natives.
         * @param {ExtendOptions} [opts]
         *
         ***/
        var extend = function (opts) {

          var nativeClass = globalContext[name], nativeProto = nativeClass.prototype;
          var staticMethods = {}, instanceMethods = {}, methodsByName;

          function objectRestricted(name, target) {
            return isObject && target === nativeProto &&
                   (!allowObjectPrototype || name === 'get' || name === 'set');
          }

          function arrayOptionExists(field, val) {
            var arr = opts[field];
            if (arr) {
              for (var i = 0, el; el = arr[i]; i++) {
                if (el === val) {
                  return true;
                }
              }
            }
            return false;
          }

          function arrayOptionExcludes(field, val) {
            return opts[field] && !arrayOptionExists(field, val);
          }

          function disallowedByFlags(methodName, target, flags) {
            // Disallowing methods by flag currently only applies if methods already
            // exist to avoid enhancing native methods, as aliases should still be
            // extended (i.e. Array#all should still be extended even if Array#every
            // is being disallowed by a flag).
            if (!target[methodName] || !flags) {
              return false;
            }
            for (var i = 0; i < flags.length; i++) {
              if (opts[flags[i]] === false) {
                return true;
              }
            }
          }

          function namespaceIsExcepted() {
            return arrayOptionExists('except', nativeClass) ||
                   arrayOptionExcludes('namespaces', nativeClass);
          }

          function methodIsExcepted(methodName) {
            return arrayOptionExists('except', methodName);
          }

          function canExtend(methodName, method, target) {
            return !objectRestricted(methodName, target) &&
                   !disallowedByFlags(methodName, target, method.flags) &&
                   !methodIsExcepted(methodName);
          }

          opts = opts || {};
          methodsByName = opts.methods;

          if (namespaceIsExcepted()) {
            return;
          } else if (isObject && typeof opts.objectPrototype === 'boolean') {
            // Store "objectPrototype" flag for future reference.
            allowObjectPrototype = opts.objectPrototype;
          }

          forEachProperty(methodsByName || sugarNamespace, function(method, methodName) {
            if (methodsByName) {
              // If we have method names passed in an array,
              // then we need to flip the key and value here
              // and find the method in the Sugar namespace.
              methodName = method;
              method = sugarNamespace[methodName];
            }
            if (hasOwn(method, 'instance') && canExtend(methodName, method, nativeProto)) {
              instanceMethods[methodName] = method.instance;
            }
            if(hasOwn(method, 'static') && canExtend(methodName, method, nativeClass)) {
              staticMethods[methodName] = method;
            }
          });

          // Accessing the extend target each time instead of holding a reference as
          // it may have been overwritten (for example Date by Sinon). Also need to
          // access through the global to allow extension of user-defined namespaces.
          extendNative(nativeClass, staticMethods);
          extendNative(nativeProto, instanceMethods);

          if (!methodsByName) {
            // If there are no method names passed, then
            // all methods in the namespace will be extended
            // to the native. This includes all future defined
            // methods, so add a flag here to check later.
            setProperty(sugarNamespace, 'active', true);
          }
          return sugarNamespace;
        };

        function defineWithOptionCollect(methodName, instance, args) {
          setProperty(sugarNamespace, methodName, function(arg1, arg2, arg3) {
            var opts = collectDefineOptions(arg1, arg2, arg3);
            defineMethods(sugarNamespace, opts.methods, instance, args, opts.last);
            return sugarNamespace;
          });
        }

        /***
         * @method defineStatic(methods)
         * @returns SugarNamespace
         * @namespace SugarNamespace
         * @short Defines static methods on the namespace that can later be extended
         *        onto the native globals.
         * @extra Accepts either a single object mapping names to functions, or name
         *        and function as two arguments. If `extend` was previously called
         *        with no arguments, the method will be immediately mapped to its
         *        native when defined.
         *
         * @example
         *
         *   Sugar.Number.defineStatic({
         *     isOdd: function (num) {
         *       return num % 2 === 1;
         *     }
         *   });
         *
         * @signature defineStatic(methodName, methodFn)
         * @param {Object} methods - Methods to be defined.
         * @param {string} methodName - Name of a single method to be defined.
         * @param {Function} methodFn - Function body of a single method to be defined.
         ***/
        defineWithOptionCollect('defineStatic', STATIC);

        /***
         * @method defineInstance(methods)
         * @returns SugarNamespace
         * @namespace SugarNamespace
         * @short Defines methods on the namespace that can later be extended as
         *        instance methods onto the native prototype.
         * @extra Accepts either a single object mapping names to functions, or name
         *        and function as two arguments. All functions should accept the
         *        native for which they are mapped as their first argument, and should
         *        never refer to `this`. If `extend` was previously called with no
         *        arguments, the method will be immediately mapped to its native when
         *        defined.
         *
         *        Methods cannot accept more than 4 arguments in addition to the
         *        native (5 arguments total). Any additional arguments will not be
         *        mapped. If the method needs to accept unlimited arguments, use
         *        `defineInstanceWithArguments`. Otherwise if more options are
         *        required, use an options object instead.
         *
         * @example
         *
         *   Sugar.Number.defineInstance({
         *     square: function (num) {
         *       return num * num;
         *     }
         *   });
         *
         * @signature defineInstance(methodName, methodFn)
         * @param {Object} methods - Methods to be defined.
         * @param {string} methodName - Name of a single method to be defined.
         * @param {Function} methodFn - Function body of a single method to be defined.
         ***/
        defineWithOptionCollect('defineInstance', INSTANCE);

        /***
         * @method defineInstanceAndStatic(methods)
         * @returns SugarNamespace
         * @namespace SugarNamespace
         * @short A shortcut to define both static and instance methods on the namespace.
         * @extra This method is intended for use with `Object` instance methods. Sugar
         *        will not map any methods to `Object.prototype` by default, so defining
         *        instance methods as static helps facilitate their proper use.
         *
         * @example
         *
         *   Sugar.Object.defineInstanceAndStatic({
         *     isAwesome: function (obj) {
         *       // check if obj is awesome!
         *     }
         *   });
         *
         * @signature defineInstanceAndStatic(methodName, methodFn)
         * @param {Object} methods - Methods to be defined.
         * @param {string} methodName - Name of a single method to be defined.
         * @param {Function} methodFn - Function body of a single method to be defined.
         ***/
        defineWithOptionCollect('defineInstanceAndStatic', INSTANCE | STATIC);


        /***
         * @method defineStaticWithArguments(methods)
         * @returns SugarNamespace
         * @namespace SugarNamespace
         * @short Defines static methods that collect arguments.
         * @extra This method is identical to `defineStatic`, except that when defined
         *        methods are called, they will collect any arguments past `n - 1`,
         *        where `n` is the number of arguments that the method accepts.
         *        Collected arguments will be passed to the method in an array
         *        as the last argument defined on the function.
         *
         * @example
         *
         *   Sugar.Number.defineStaticWithArguments({
         *     addAll: function (num, args) {
         *       for (var i = 0; i < args.length; i++) {
         *         num += args[i];
         *       }
         *       return num;
         *     }
         *   });
         *
         * @signature defineStaticWithArguments(methodName, methodFn)
         * @param {Object} methods - Methods to be defined.
         * @param {string} methodName - Name of a single method to be defined.
         * @param {Function} methodFn - Function body of a single method to be defined.
         ***/
        defineWithOptionCollect('defineStaticWithArguments', STATIC, true);

        /***
         * @method defineInstanceWithArguments(methods)
         * @returns SugarNamespace
         * @namespace SugarNamespace
         * @short Defines instance methods that collect arguments.
         * @extra This method is identical to `defineInstance`, except that when
         *        defined methods are called, they will collect any arguments past
         *        `n - 1`, where `n` is the number of arguments that the method
         *        accepts. Collected arguments will be passed to the method as the
         *        last argument defined on the function.
         *
         * @example
         *
         *   Sugar.Number.defineInstanceWithArguments({
         *     addAll: function (num, args) {
         *       for (var i = 0; i < args.length; i++) {
         *         num += args[i];
         *       }
         *       return num;
         *     }
         *   });
         *
         * @signature defineInstanceWithArguments(methodName, methodFn)
         * @param {Object} methods - Methods to be defined.
         * @param {string} methodName - Name of a single method to be defined.
         * @param {Function} methodFn - Function body of a single method to be defined.
         ***/
        defineWithOptionCollect('defineInstanceWithArguments', INSTANCE, true);

        /***
         * @method defineStaticPolyfill(methods)
         * @returns SugarNamespace
         * @namespace SugarNamespace
         * @short Defines static methods that are mapped onto the native if they do
         *        not already exist.
         * @extra Intended only for use creating polyfills that follow the ECMAScript
         *        spec. Accepts either a single object mapping names to functions, or
         *        name and function as two arguments. Note that polyfill methods will
         *        be immediately mapped onto their native prototype regardless of the
         *        use of `extend`.
         *
         * @example
         *
         *   Sugar.Object.defineStaticPolyfill({
         *     keys: function (obj) {
         *       // get keys!
         *     }
         *   });
         *
         * @signature defineStaticPolyfill(methodName, methodFn)
         * @param {Object} methods - Methods to be defined.
         * @param {string} methodName - Name of a single method to be defined.
         * @param {Function} methodFn - Function body of a single method to be defined.
         ***/
        setProperty(sugarNamespace, 'defineStaticPolyfill', function(arg1, arg2, arg3) {
          var opts = collectDefineOptions(arg1, arg2, arg3);
          extendNative(globalContext[name], opts.methods, true, opts.last);
          return sugarNamespace;
        });

        /***
         * @method defineInstancePolyfill(methods)
         * @returns SugarNamespace
         * @namespace SugarNamespace
         * @short Defines instance methods that are mapped onto the native prototype
         *        if they do not already exist.
         * @extra Intended only for use creating polyfills that follow the ECMAScript
         *        spec. Accepts either a single object mapping names to functions, or
         *        name and function as two arguments. This method differs from
         *        `defineInstance` as there is no static signature (as the method
         *        is mapped as-is to the native), so it should refer to its `this`
         *        object. Note that polyfill methods will be immediately mapped onto
         *        their native prototype regardless of the use of `extend`.
         *
         * @example
         *
         *   Sugar.Array.defineInstancePolyfill({
         *     indexOf: function (arr, el) {
         *       // index finding code here!
         *     }
         *   });
         *
         * @signature defineInstancePolyfill(methodName, methodFn)
         * @param {Object} methods - Methods to be defined.
         * @param {string} methodName - Name of a single method to be defined.
         * @param {Function} methodFn - Function body of a single method to be defined.
         ***/
        setProperty(sugarNamespace, 'defineInstancePolyfill', function(arg1, arg2, arg3) {
          var opts = collectDefineOptions(arg1, arg2, arg3);
          extendNative(globalContext[name].prototype, opts.methods, true, opts.last);
          // Map instance polyfills to chainable as well.
          forEachProperty(opts.methods, function(fn, methodName) {
            defineChainableMethod(sugarNamespace, methodName, fn);
          });
          return sugarNamespace;
        });

        /***
         * @method alias(toName, from)
         * @returns SugarNamespace
         * @namespace SugarNamespace
         * @short Aliases one Sugar method to another.
         *
         * @example
         *
         *   Sugar.Array.alias('all', 'every');
         *
         * @signature alias(toName, fn)
         * @param {string} toName - Name for new method.
         * @param {string|Function} from - Method to alias, or string shortcut.
         ***/
        setProperty(sugarNamespace, 'alias', function(name, source) {
          var method = typeof source === 'string' ? sugarNamespace[source] : source;
          setMethod(sugarNamespace, name, method);
          return sugarNamespace;
        });

        // Each namespace can extend only itself through its .extend method.
        setProperty(sugarNamespace, 'extend', extend);

        // Cache the class to namespace relationship for later use.
        namespacesByName[name] = sugarNamespace;
        namespacesByClassString['[object ' + name + ']'] = sugarNamespace;

        mapNativeToChainable(name);
        mapObjectChainablesToNamespace(sugarNamespace);


        // Export
        return Sugar[name] = sugarNamespace;
      }

      function setGlobalProperties() {
        setProperty(Sugar, 'VERSION', '2.0.6');
        setProperty(Sugar, 'extend', Sugar);
        setProperty(Sugar, 'toString', toString);
        setProperty(Sugar, 'createNamespace', createNamespace);

        setProperty(Sugar, 'util', {
          'hasOwn': hasOwn,
          'getOwn': getOwn,
          'setProperty': setProperty,
          'classToString': classToString,
          'defineProperty': defineProperty,
          'forEachProperty': forEachProperty,
          'mapNativeToChainable': mapNativeToChainable
        });
      }

      function toString() {
        return SUGAR_GLOBAL;
      }


      // Defining Methods

      function defineMethods(sugarNamespace, methods, type, args, flags) {
        forEachProperty(methods, function(method, methodName) {
          var instanceMethod, staticMethod = method;
          if (args) {
            staticMethod = wrapMethodWithArguments(method);
          }
          if (flags) {
            staticMethod.flags = flags;
          }

          // A method may define its own custom implementation, so
          // make sure that's not the case before creating one.
          if (type & INSTANCE && !method.instance) {
            instanceMethod = wrapInstanceMethod(method, args);
            setProperty(staticMethod, 'instance', instanceMethod);
          }

          if (type & STATIC) {
            setProperty(staticMethod, 'static', true);
          }

          setMethod(sugarNamespace, methodName, staticMethod);

          if (sugarNamespace.active) {
            // If the namespace has been activated (.extend has been called),
            // then map this method as well.
            sugarNamespace.extend(methodName);
          }
        });
      }

      function collectDefineOptions(arg1, arg2, arg3) {
        var methods, last;
        if (typeof arg1 === 'string') {
          methods = {};
          methods[arg1] = arg2;
          last = arg3;
        } else {
          methods = arg1;
          last = arg2;
        }
        return {
          last: last,
          methods: methods
        };
      }

      function wrapInstanceMethod(fn, args) {
        return args ? wrapMethodWithArguments(fn, true) : wrapInstanceMethodFixed(fn);
      }

      function wrapMethodWithArguments(fn, instance) {
        // Functions accepting enumerated arguments will always have "args" as the
        // last argument, so subtract one from the function length to get the point
        // at which to start collecting arguments. If this is an instance method on
        // a prototype, then "this" will be pushed into the arguments array so start
        // collecting 1 argument earlier.
        var startCollect = fn.length - 1 - (instance ? 1 : 0);
        return function() {
          var args = [], collectedArgs = [], len;
          if (instance) {
            args.push(this);
          }
          len = Math.max(arguments.length, startCollect);
          // Optimized: no leaking arguments
          for (var i = 0; i < len; i++) {
            if (i < startCollect) {
              args.push(arguments[i]);
            } else {
              collectedArgs.push(arguments[i]);
            }
          }
          args.push(collectedArgs);
          return fn.apply(this, args);
        };
      }

      function wrapInstanceMethodFixed(fn) {
        switch(fn.length) {
          // Wrapped instance methods will always be passed the instance
          // as the first argument, but requiring the argument to be defined
          // may cause confusion here, so return the same wrapped function regardless.
          case 0:
          case 1:
            return function() {
              return fn(this);
            };
          case 2:
            return function(a) {
              return fn(this, a);
            };
          case 3:
            return function(a, b) {
              return fn(this, a, b);
            };
          case 4:
            return function(a, b, c) {
              return fn(this, a, b, c);
            };
          case 5:
            return function(a, b, c, d) {
              return fn(this, a, b, c, d);
            };
        }
      }

      // Method helpers

      function extendNative(target, source, polyfill, override) {
        forEachProperty(source, function(method, name) {
          if (polyfill && !override && target[name]) {
            // Method exists, so bail.
            return;
          }
          setProperty(target, name, method);
        });
      }

      function setMethod(sugarNamespace, methodName, method) {
        sugarNamespace[methodName] = method;
        if (method.instance) {
          defineChainableMethod(sugarNamespace, methodName, method.instance);
        }
      }


      // Chainables

      function getNewChainableClass(name) {
        var fn = function SugarChainable(obj, arg) {
          if (!(this instanceof fn)) {
            return new fn(obj, arg);
          }
          if (this.constructor !== fn) {
            // Allow modules to define their own constructors.
            obj = this.constructor.apply(obj, arguments);
          }
          this.raw = obj;
        };
        setProperty(fn, 'toString', function() {
          return SUGAR_GLOBAL + name;
        });
        setProperty(fn.prototype, 'valueOf', function() {
          return this.raw;
        });
        return fn;
      }

      function defineChainableMethod(sugarNamespace, methodName, fn) {
        var wrapped = wrapWithChainableResult(fn), existing, collision, dcp;
        dcp = DefaultChainable.prototype;
        existing = dcp[methodName];

        // If the method was previously defined on the default chainable, then a
        // collision exists, so set the method to a disambiguation function that will
        // lazily evaluate the object and find it's associated chainable. An extra
        // check is required to avoid false positives from Object inherited methods.
        collision = existing && existing !== Object.prototype[methodName];

        // The disambiguation function is only required once.
        if (!existing || !existing.disambiguate) {
          dcp[methodName] = collision ? disambiguateMethod(methodName) : wrapped;
        }

        // The target chainable always receives the wrapped method. Additionally,
        // if the target chainable is Sugar.Object, then map the wrapped method
        // to all other namespaces as well if they do not define their own method
        // of the same name. This way, a Sugar.Number will have methods like
        // isEqual that can be called on any object without having to traverse up
        // the prototype chain and perform disambiguation, which costs cycles.
        // Note that the "if" block below actually does nothing on init as Object
        // goes first and no other namespaces exist yet. However it needs to be
        // here as Object instance methods defined later also need to be mapped
        // back onto existing namespaces.
        sugarNamespace.prototype[methodName] = wrapped;
        if (sugarNamespace === Sugar.Object) {
          mapObjectChainableToAllNamespaces(methodName, wrapped);
        }
      }

      function mapObjectChainablesToNamespace(sugarNamespace) {
        forEachProperty(Sugar.Object && Sugar.Object.prototype, function(val, methodName) {
          if (typeof val === 'function') {
            setObjectChainableOnNamespace(sugarNamespace, methodName, val);
          }
        });
      }

      function mapObjectChainableToAllNamespaces(methodName, fn) {
        forEachProperty(namespacesByName, function(sugarNamespace) {
          setObjectChainableOnNamespace(sugarNamespace, methodName, fn);
        });
      }

      function setObjectChainableOnNamespace(sugarNamespace, methodName, fn) {
        var proto = sugarNamespace.prototype;
        if (!hasOwn(proto, methodName)) {
          proto[methodName] = fn;
        }
      }

      function wrapWithChainableResult(fn) {
        return function() {
          return new DefaultChainable(fn.apply(this.raw, arguments));
        };
      }

      function disambiguateMethod(methodName) {
        var fn = function() {
          var raw = this.raw, sugarNamespace;
          if (raw != null) {
            // Find the Sugar namespace for this unknown.
            sugarNamespace = namespacesByClassString[classToString(raw)];
          }
          if (!sugarNamespace) {
            // If no sugarNamespace can be resolved, then default
            // back to Sugar.Object so that undefined and other
            // non-supported types can still have basic object
            // methods called on them, such as type checks.
            sugarNamespace = Sugar.Object;
          }

          return new sugarNamespace(raw)[methodName].apply(this, arguments);
        };
        fn.disambiguate = true;
        return fn;
      }

      function mapNativeToChainable(name, methodNames) {
        var sugarNamespace = namespacesByName[name],
            nativeProto = globalContext[name].prototype;

        if (!methodNames && ownPropertyNames) {
          methodNames = ownPropertyNames(nativeProto);
        }

        forEachProperty(methodNames, function(methodName) {
          if (nativeMethodProhibited(methodName)) {
            // Sugar chainables have their own constructors as well as "valueOf"
            // methods, so exclude them here. The __proto__ argument should be trapped
            // by the function check below, however simply accessing this property on
            // Object.prototype causes QML to segfault, so pre-emptively excluding it.
            return;
          }
          try {
            var fn = nativeProto[methodName];
            if (typeof fn !== 'function') {
              // Bail on anything not a function.
              return;
            }
          } catch (e) {
            // Function.prototype has properties that
            // will throw errors when accessed.
            return;
          }
          defineChainableMethod(sugarNamespace, methodName, fn);
        });
      }

      function nativeMethodProhibited(methodName) {
        return methodName === 'constructor' ||
               methodName === 'valueOf' ||
               methodName === '__proto__';
      }


      // Util

      // Internal references
      var ownPropertyNames = Object.getOwnPropertyNames,
          internalToString = Object.prototype.toString,
          internalHasOwnProperty = Object.prototype.hasOwnProperty;

      // Defining this as a variable here as the ES5 module
      // overwrites it to patch DONTENUM.
      var forEachProperty = function (obj, fn) {
        for(var key in obj) {
          if (!hasOwn(obj, key)) continue;
          if (fn.call(obj, obj[key], key, obj) === false) break;
        }
      };

      // istanbul ignore next
      function definePropertyShim(obj, prop, descriptor) {
        obj[prop] = descriptor.value;
      }

      function setProperty(target, name, value, enumerable) {
        defineProperty(target, name, {
          value: value,
          enumerable: !!enumerable,
          configurable: true,
          writable: true
        });
      }

      // PERF: Attempts to speed this method up get very Heisenbergy. Quickly
      // returning based on typeof works for primitives, but slows down object
      // types. Even === checks on null and undefined (no typeof) will end up
      // basically breaking even. This seems to be as fast as it can go.
      function classToString(obj) {
        return internalToString.call(obj);
      }

      function hasOwn(obj, prop) {
        return !!obj && internalHasOwnProperty.call(obj, prop);
      }

      function getOwn(obj, prop) {
        if (hasOwn(obj, prop)) {
          return obj[prop];
        }
      }

      setupGlobal();

      // For type checking, etc. Excludes object as this is more nuanced.
      var NATIVE_TYPES = 'Boolean Number String Date RegExp Function Array Error Set Map';

      // Do strings have no keys?
      var NO_KEYS_IN_STRING_OBJECTS = !('0' in Object('a'));

      // WhiteSpace/LineTerminator as defined in ES5.1 plus Unicode characters in the Space, Separator category.
      var TRIM_CHARS = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u2028\u2029\u3000\uFEFF';

      // Common chars
      var HALF_WIDTH_ZERO = 0x30,
          FULL_WIDTH_ZERO = 0xff10,
          HALF_WIDTH_PERIOD   = '.',
          FULL_WIDTH_PERIOD   = '．',
          HALF_WIDTH_COMMA    = ',';

      // Namespace aliases
      var sugarObject   = Sugar.Object,
          sugarArray    = Sugar.Array,
          sugarDate     = Sugar.Date,
          sugarString   = Sugar.String,
          sugarNumber   = Sugar.Number,
          sugarFunction = Sugar.Function,
          sugarRegExp   = Sugar.RegExp;

      // Class checks
      var isBoolean, isNumber, isString,
          isDate, isRegExp, isFunction,
          isArray, isSet, isMap, isError;

      function buildClassChecks() {

        function addCoreTypes() {

          var names = spaceSplit(NATIVE_TYPES);

          isBoolean = buildPrimitiveClassCheck(names[0]);
          isNumber  = buildPrimitiveClassCheck(names[1]);
          isString  = buildPrimitiveClassCheck(names[2]);

          isDate   = buildClassCheck(names[3]);
          isRegExp = buildClassCheck(names[4]);

          // Wanted to enhance performance here by using simply "typeof"
          // but Firefox has two major issues that make this impossible,
          // one fixed, the other not, so perform a full class check here.
          //
          // 1. Regexes can be typeof "function" in FF < 3
          //    https://bugzilla.mozilla.org/show_bug.cgi?id=61911 (fixed)
          //
          // 2. HTMLEmbedElement and HTMLObjectElement are be typeof "function"
          //    https://bugzilla.mozilla.org/show_bug.cgi?id=268945 (won't fix)
          isFunction = buildClassCheck(names[5]);

          // istanbul ignore next
          isArray = Array.isArray || buildClassCheck(names[6]);
          isError = buildClassCheck(names[7]);

          isSet = buildClassCheck(names[8], typeof Set !== 'undefined' && Set);
          isMap = buildClassCheck(names[9], typeof Map !== 'undefined' && Map);
          addKnownType(names[0]);
          addKnownType(names[1]);
          addKnownType(names[2]);
          addKnownType(names[3]);
          addKnownType(names[4]);
          addKnownType(names[6]);

        }

        function addArrayTypes() {
          var types = 'Int8 Uint8 Uint8Clamped Int16 Uint16 Int32 Uint32 Float32 Float64';
          forEach(spaceSplit(types), function(str) {
          });
        }

        function addKnownType(className) {
        }

        function buildClassCheck(className, globalObject) {
          // istanbul ignore if
          if (globalObject && isClass(new globalObject, 'Object')) {
            return getConstructorClassCheck(globalObject);
          } else {
            return getToStringClassCheck(className);
          }
        }

        // Map and Set may be [object Object] in certain IE environments.
        // In this case we need to perform a check using the constructor
        // instead of Object.prototype.toString.
        // istanbul ignore next
        function getConstructorClassCheck(obj) {
          var ctorStr = String(obj);
          return function(obj) {
            return String(obj.constructor) === ctorStr;
          };
        }

        function getToStringClassCheck(className) {
          return function(obj, str) {
            // perf: Returning up front on instanceof appears to be slower.
            return isClass(obj, className, str);
          };
        }

        function buildPrimitiveClassCheck(className) {
          var type = className.toLowerCase();
          return function(obj) {
            var t = typeof obj;
            return t === type || t === 'object' && isClass(obj, className);
          };
        }

        addCoreTypes();
        addArrayTypes();

      }

      function isClass(obj, className, str) {
        if (!str) {
          str = classToString(obj);
        }
        return str === '[object '+ className +']';
      }

      // Wrapping the core's "define" methods to
      // save a few bytes in the minified script.
      function wrapNamespace(method) {
        return function(sugarNamespace, arg1, arg2) {
          sugarNamespace[method](arg1, arg2);
        };
      }

      // Method define aliases
      var defineStaticPolyfill        = wrapNamespace('defineStaticPolyfill'),
          defineInstancePolyfill      = wrapNamespace('defineInstancePolyfill');

      function assertCallable(obj) {
        if (!isFunction(obj)) {
          throw new TypeError('Function is not callable');
        }
      }


      // General helpers

      function isDefined(o) {
        return o !== undefined;
      }

      function isPrimitive(obj, type) {
        type = type || typeof obj;
        return obj == null || type === 'string' || type === 'number' || type === 'boolean';
      }

      // Make primtives types like strings into objects.
      function coercePrimitiveToObject(obj) {
        if (isPrimitive(obj)) {
          obj = Object(obj);
        }
        // istanbul ignore next
        if (NO_KEYS_IN_STRING_OBJECTS && isString(obj)) {
          forceStringCoercion(obj);
        }
        return obj;
      }

      // Force strings to have their indexes set in
      // environments that don't do this automatically.
      // istanbul ignore next
      function forceStringCoercion(obj) {
        var i = 0, chr;
        while (chr = obj.charAt(i)) {
          obj[i++] = chr;
        }
      }


      // Array helpers

      function isArrayIndex(n) {
        return n >>> 0 == n && n != 0xFFFFFFFF;
      }

      function iterateOverSparseArray(arr, fn, fromIndex, loop) {
        var indexes = getSparseArrayIndexes(arr, fromIndex, loop), index;
        for (var i = 0, len = indexes.length; i < len; i++) {
          index = indexes[i];
          fn.call(arr, arr[index], index, arr);
        }
        return arr;
      }

      // It's unclear whether or not sparse arrays qualify as "simple enumerables".
      // If they are not, however, the wrapping function will be deoptimized, so
      // isolate here (also to share between es5 and array modules).
      function getSparseArrayIndexes(arr, fromIndex, loop, fromRight) {
        var indexes = [], i;
        for (i in arr) {
          // istanbul ignore next
          if (isArrayIndex(i) && (loop || (fromRight ? i <= fromIndex : i >= fromIndex))) {
            indexes.push(+i);
          }
        }
        indexes.sort(function(a, b) {
          var aLoop = a > fromIndex;
          var bLoop = b > fromIndex;
          // This block cannot be reached unless ES5 methods are being shimmed.
          // istanbul ignore if
          if (aLoop !== bLoop) {
            return aLoop ? -1 : 1;
          }
          return a - b;
        });
        return indexes;
      }

      function spaceSplit(str) {
        return str.split(' ');
      }

      function forEach(arr, fn) {
        for (var i = 0, len = arr.length; i < len; i++) {
          if (!(i in arr)) {
            return iterateOverSparseArray(arr, fn, i);
          }
          fn(arr[i], i);
        }
      }

      // Number helpers

      // istanbul ignore next
      var trunc = Math.trunc || function(n) {
        if (n === 0 || !isFinite(n)) return n;
        return n < 0 ? ceil(n) : floor(n);
      };

      function padNumber(num, place, sign, base, replacement) {
        var str = abs(num).toString(base || 10);
        str = repeatString(replacement || '0', place - str.replace(/\.\d+/, '').length) + str;
        if (sign || num < 0) {
          str = (num < 0 ? '-' : '+') + str;
        }
        return str;
      }

      // Fullwidth number helpers
      var fullWidthNumberMap;

      function buildFullWidthNumber() {
        var fwp = FULL_WIDTH_PERIOD, hwp = HALF_WIDTH_PERIOD, hwc = HALF_WIDTH_COMMA;
        fullWidthNumberMap = {};
        for (var i = 0, digit; i <= 9; i++) {
          digit = chr(i + FULL_WIDTH_ZERO);
          fullWidthNumberMap[digit] = chr(i + HALF_WIDTH_ZERO);
        }
        fullWidthNumberMap[hwc] = '';
        fullWidthNumberMap[fwp] = hwp;
        // Mapping this to itself to capture it easily
        // in stringToNumber to detect decimals later.
        fullWidthNumberMap[hwp] = hwp;
      }

      // Math aliases
      var abs   = Math.abs,
          ceil  = Math.ceil,
          floor = Math.floor;


      // String helpers

      var chr = String.fromCharCode;

      function repeatString(str, num) {
        var result = '';
        str = str.toString();
        while (num > 0) {
          if (num & 1) {
            result += str;
          }
          if (num >>= 1) {
            str += str;
          }
        }
        return result;
      }

      buildClassChecks();
      buildFullWidthNumber();

      /***
       * @module ES5
       * @description Functions and polyfill methods that fix ES5 functionality. This
       *              module is excluded from default builds, and can be included if
       *              you need legacy browser support (IE8 and below).
       *
       ***/

      // Non-enumerable properties on Object.prototype. In early JScript implementations
      // (< IE9) these will shadow object properties and break for..in loops.
      var DONT_ENUM_PROPS = [
        'valueOf',
        'toString',
        'constructor',
        'isPrototypeOf',
        'hasOwnProperty',
        'toLocaleString',
        'propertyIsEnumerable'
      ];

      /***
       * @fix
       * @short Fixes DontEnum bug for iteration methods in < IE9.
       ***/
      function buildDontEnumFix() {
        if (!({toString:1}).propertyIsEnumerable('toString')) {
          var forEachEnumerableProperty = forEachProperty;
          forEachProperty = function(obj, fn) {
            forEachEnumerableProperty(obj, fn);
            for (var i = 0, key; key = DONT_ENUM_PROPS[i]; i++) {
              if (hasOwn(obj, key)) {
                if(fn.call(obj, obj[key], key, obj) === false) break;
              }
            }
          };
        }
      }

      /***
       * @fix
       * @short Adds native methods to chainables in < IE9.
       ***/
      function buildChainableNativeMethodsFix() {
        if (!Object.getOwnPropertyNames) {
          defineNativeMethodsOnChainable();
        }
      }

      // Polyfilled methods will automatically be added to the chainable prototype.
      // However, Object.getOwnPropertyNames cannot be shimmed for non-enumerable
      // properties, so if it does not exist, then the only way to access native
      // methods previous to ES5 is to provide them as a list of tokens here.
      function defineNativeMethodsOnChainable() {

        var nativeTokens = {
          'Function': 'apply,call',
          'RegExp':   'compile,exec,test',
          'Number':   'toExponential,toFixed,toLocaleString,toPrecision',
          'Object':   'hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString',
          'Array':    'concat,join,pop,push,reverse,shift,slice,sort,splice,toLocaleString,unshift',
          'Date':     'getTime,getTimezoneOffset,setTime,toDateString,toGMTString,toLocaleDateString,toLocaleString,toLocaleTimeString,toTimeString,toUTCString',
          'String':   'anchor,big,blink,bold,charAt,charCodeAt,concat,fixed,fontcolor,fontsize,indexOf,italics,lastIndexOf,link,localeCompare,match,replace,search,slice,small,split,strike,sub,substr,substring,sup,toLocaleLowerCase,toLocaleUpperCase,toLowerCase,toUpperCase'
        };

        var dateTokens = 'FullYear,Month,Date,Hours,Minutes,Seconds,Milliseconds'.split(',');

        function addDateTokens(prefix, arr) {
          for (var i = 0; i < dateTokens.length; i++) {
            arr.push(prefix + dateTokens[i]);
          }
        }

        forEachProperty(nativeTokens, function(str, name) {
          var tokens = str.split(',');
          if (name === 'Date') {
            addDateTokens('get', tokens);
            addDateTokens('set', tokens);
            addDateTokens('getUTC', tokens);
            addDateTokens('setUTC', tokens);
          }
          tokens.push('toString');
          mapNativeToChainable(name, tokens);
        });

      }


      buildDontEnumFix();
      buildChainableNativeMethodsFix();


      /*** @namespace Object ***/

      function assertNonNull(obj) {
        if (obj == null) {
          throw new TypeError('Object required');
        }
      }

      defineStaticPolyfill(sugarObject, {

        'keys': function(obj) {
          var keys = [];
          assertNonNull(obj);
          forEachProperty(coercePrimitiveToObject(obj), function(val, key) {
            keys.push(key);
          });
          return keys;
        }

      });


      /*** @namespace Array ***/

      function arrayIndexOf(arr, search, fromIndex, fromRight) {
        var length = arr.length, defaultFromIndex, index, increment;

        increment = fromRight ? -1 : 1;
        defaultFromIndex = fromRight ? length - 1 : 0;
        fromIndex = trunc(fromIndex);
        if (!fromIndex && fromIndex !== 0) {
          fromIndex = defaultFromIndex;
        }
        if (fromIndex < 0) {
          fromIndex = length + fromIndex;
        }
        if ((!fromRight && fromIndex < 0) || (fromRight && fromIndex >= length)) {
          fromIndex = defaultFromIndex;
        }

        index = fromIndex;

        while((fromRight && index >= 0) || (!fromRight && index < length)) {
          if (!(index in arr)) {
            return sparseIndexOf(arr, search, fromIndex, fromRight);
          }
          if (isArrayIndex(index) && arr[index] === search) {
            return index;
          }
          index += increment;
        }
        return -1;
      }

      function sparseIndexOf(arr, search, fromIndex, fromRight) {
        var indexes = getSparseArrayIndexes(arr, fromIndex, false, fromRight), index;
        indexes.sort(function(a, b) {
          return fromRight ? b - a : a - b;
        });
        while ((index = indexes.shift()) !== undefined) {
          if (arr[index] === search) {
            return +index;
          }
        }
        return -1;
      }

      function arrayReduce(arr, fn, initialValue, fromRight) {
        var length = arr.length, count = 0, defined = isDefined(initialValue), result, index;
        assertCallable(fn);
        if (length == 0 && !defined) {
          throw new TypeError('Reduce called on empty array with no initial value');
        } else if (defined) {
          result = initialValue;
        } else {
          result = arr[fromRight ? length - 1 : count];
          count++;
        }
        while(count < length) {
          index = fromRight ? length - count - 1 : count;
          if (index in arr) {
            result = fn(result, arr[index], index, arr);
          }
          count++;
        }
        return result;
      }

      defineStaticPolyfill(sugarArray, {

        /***
         *
         * @method isArray(obj)
         * @returns Boolean
         * @polyfill ES5
         * @static
         * @short Returns true if `obj` is an Array.
         *
         * @example
         *
         *   Array.isArray(3)        -> false
         *   Array.isArray(true)     -> false
         *   Array.isArray('wasabi') -> false
         *   Array.isArray([1,2,3])  -> true
         *
         ***/
        'isArray': function(obj) {
          return isArray(obj);
        }

      });

      defineInstancePolyfill(sugarArray, {

        'every': function(fn) {
          // Force compiler to respect argument length.
          var context = arguments[1];
          var length = this.length, index = 0;
          assertCallable(fn);
          while(index < length) {
            if (index in this && !fn.call(context, this[index], index, this)) {
              return false;
            }
            index++;
          }
          return true;
        },

        'some': function(fn) {
          // Force compiler to respect argument length.
          var context = arguments[1];
          var length = this.length, index = 0;
          assertCallable(fn);
          while(index < length) {
            if (index in this && fn.call(context, this[index], index, this)) {
              return true;
            }
            index++;
          }
          return false;
        },

        'map': function(fn) {
          // Force compiler to respect argument length.
          var context = arguments[1];
          var length = this.length, index = 0, result = new Array(length);
          assertCallable(fn);
          while(index < length) {
            if (index in this) {
              result[index] = fn.call(context, this[index], index, this);
            }
            index++;
          }
          return result;
        },

        'filter': function(fn) {
          // Force compiler to respect argument length.
          var context = arguments[1];
          var length = this.length, index = 0, result = [];
          assertCallable(fn);
          while(index < length) {
            if (index in this && fn.call(context, this[index], index, this)) {
              result.push(this[index]);
            }
            index++;
          }
          return result;
        },

        /***
         * @method indexOf(search, [fromIndex] = 0)
         * @returns Number
         * @polyfill ES5
         * @short Searches the array and returns the first index where `search` occurs,
         *        or `-1` if the element is not found.
         * @extra [fromIndex] is the index from which to begin the search. This
         *        method performs a simple strict equality comparison on `search`.
         *        Sugar does not enhance this method to support `enhanced matching`.
         *        For such functionality, use the `findIndex` method instead.
         *
         * @example
         *
         *   [1,2,3].indexOf(3) -> 1
         *   [1,2,3].indexOf(7) -> -1
         *
         ***/
        'indexOf': function(search) {
          // Force compiler to respect argument length.
          var fromIndex = arguments[1];
          if (isString(this)) return this.indexOf(search, fromIndex);
          return arrayIndexOf(this, search, fromIndex);
        },

        /***
         * @method lastIndexOf(search, [fromIndex] = array.length - 1)
         * @returns Number
         * @polyfill ES5
         * @short Searches the array from the end and returns the first index where
         *        `search` occurs, or `-1` if the element is not found.
         * @extra [fromIndex] is the index from which to begin the search. This method
         *        performs a simple strict equality comparison on `search`.
         *        Sugar does not enhance this method to support `enhanced matching`.
         *
         * @example
         *
         *   [1,2,1].lastIndexOf(1) -> 2
         *   [1,2,1].lastIndexOf(7) -> -1
         *
         ***/
        'lastIndexOf': function(search) {
          // Force compiler to respect argument length.
          var fromIndex = arguments[1];
          if (isString(this)) return this.lastIndexOf(search, fromIndex);
          return arrayIndexOf(this, search, fromIndex, true);
        },

        /***
         * @method forEach([eachFn], [context])
         * @polyfill ES5
         * @short Iterates over the array, calling [eachFn] on each loop.
         * @extra [context] becomes the `this` object.
         *
         * @callback eachFn
         *
         *   el   The element of the current iteration.
         *   i    The index of the current iteration.
         *   arr  A reference to the array.
         *
         * @example
         *
         *   ['a','b','c'].forEach(function(a) {
         *     // Called 3 times: 'a','b','c'
         *   });
         *
         ***/
        'forEach': function(eachFn) {
          // Force compiler to respect argument length.
          var context = arguments[1];
          var length = this.length, index = 0;
          assertCallable(eachFn);
          while(index < length) {
            if (index in this) {
              eachFn.call(context, this[index], index, this);
            }
            index++;
          }
        },

        /***
         * @method reduce(reduceFn, [init])
         * @returns Mixed
         * @polyfill ES5
         * @short Reduces the array to a single result.
         * @extra This operation is sometimes called "accumulation", as it takes the
         *        result of the last iteration of `reduceFn` and passes it as the first
         *        argument to the next iteration, "accumulating" that value as it goes.
         *        The return value of this method will be the return value of the final
         *        iteration of `reduceFn`. If [init] is passed, it will be the initial
         *        "accumulator" (the first argument). If [init] is not passed, then it
         *        will take the first element in the array, and `reduceFn` will not be
         *        called for that element.
         *
         * @callback reduceFn
         *
         *   acc  The "accumulator". Either [init], the result of the last iteration
         *        of `reduceFn`, or the first element of the array.
         *   el   The current element for this iteration.
         *   idx  The current index for this iteration.
         *   arr  A reference to the array.
         *
         * @example
         *
         *   [1,2,3].reduce(function(a, b) {
         *     return a - b; // 1 - 2 - 3
         *   });
         *
         *   [1,2,3].reduce(function(a, b) {
         *     return a - b; // 100 - 1 - 2 - 3
         *   }, 100);
         *
         ***/
        'reduce': function(reduceFn) {
          // Force compiler to respect argument length.
          var context = arguments[1];
          return arrayReduce(this, reduceFn, context);
        },

        /***
         * @method reduceRight([reduceFn], [init])
         * @returns Mixed
         * @polyfill ES5
         * @short Similar to `Array#reduce`, but operates on the elements in reverse.
         *
         * @callback reduceFn
         *
         *   acc  The "accumulator", either [init], the result of the last iteration
         *        of `reduceFn`, or the last element of the array.
         *   el   The current element for this iteration.
         *   idx  The current index for this iteration.
         *   arr  A reference to the array.
         *
         * @example
         *
         *   [1,2,3].reduceRight(function(a, b) {
         *     return a - b; // 3 - 2 - 1
         *   });
         *
         *   [1,2,3].reduceRight(function(a, b) {
         *     return a - b; // 100 - 3 - 2 - 1
         *   }, 100);
         *
         *
         ***/
        'reduceRight': function(reduceFn) {
          // Force compiler to respect argument length.
          var context = arguments[1];
          return arrayReduce(this, reduceFn, context, true);
        }

      });


      /*** @namespace String ***/

      var TRIM_REG = RegExp('^[' + TRIM_CHARS + ']+|['+ TRIM_CHARS +']+$', 'g');

      defineInstancePolyfill(sugarString, {
        /***
         * @method trim()
         * @returns String
         * @polyfill ES5
         * @short Removes leading and trailing whitespace from the string.
         * @extra Whitespace is defined as line breaks, tabs, and any character in the
         *        "Space, Separator" Unicode category, conforming to the the ES5 spec.
         *
         * @example
         *
         *   '   wasabi   '.trim()      -> 'wasabi'
         *   '   wasabi   '.trimLeft()  -> 'wasabi   '
         *   '   wasabi   '.trimRight() -> '   wasabi'
         *
         ***/
        'trim': function() {
          return this.toString().replace(TRIM_REG, '');
        }
      });


      /*** @namespace Function ***/

      defineInstancePolyfill(sugarFunction, {

         /***
         * @method bind(context, [arg1], ...)
         * @returns Function
         * @polyfill ES5
         * @short Binds `context` as the `this` object for the function when it is
         *        called. Also allows currying an unlimited number of parameters.
         * @extra "currying" means setting parameters ([arg1], [arg2], etc.) ahead of
         *        time so that they are passed when the function is called later. If
         *        you pass additional parameters when the function is actually called,
         *        they will be added to the end of the curried parameters.
         *
         * @example
         *
         *   logThis.bind('woof')()   -> logs 'woof' as its this object
         *   addArgs.bind(1, 2, 3)()  -> returns 5 with 1 as the this object
         *   addArgs.bind(1)(2, 3, 4) -> returns 9
         *
         ***/
        'bind': function(context) {
          // Optimized: no leaking arguments
          var boundArgs = []; for(var $i = 1, $len = arguments.length; $i < $len; $i++) boundArgs.push(arguments[$i]);
          var fn = this, bound;
          assertCallable(this);
          bound = function() {
            // Optimized: no leaking arguments
            var args = []; for(var $i = 0, $len = arguments.length; $i < $len; $i++) args.push(arguments[$i]);
            return fn.apply(fn.prototype && this instanceof fn ? this : context, boundArgs.concat(args));
          };
          bound.prototype = this.prototype;
          return bound;
        }

      });


      /*** @namespace Date ***/

      defineStaticPolyfill(sugarDate, {

         /***
         * @method now()
         * @returns String
         * @polyfill ES5
         * @static
         * @short Returns the current time as a Unix timestamp.
         * @extra The number of milliseconds since January 1st, 1970 00:00:00 (UTC).
         *
         * @example
         *
         *   Date.now() -> ex. 1311938296231
         *
         ***/
        'now': function() {
          return new Date().getTime();
        }

      });

      function hasISOSupport() {
        var d = new Date(Date.UTC(2000, 0));
        return !!d.toISOString && d.toISOString() === '2000-01-01T00:00:00.000Z';
      }

      defineInstancePolyfill(sugarDate, {

         /***
         * @method toISOString()
         * @returns String
         * @polyfill ES5
         * @short Formats the string to ISO8601 format.
         * @extra This will always format as UTC time.
         *
         * @example
         *
         *   Date.create().toISOString() -> ex. 2011-07-05 12:24:55.528Z
         *
         ***/
        'toISOString': function() {
          return padNumber(this.getUTCFullYear(), 4) + '-' +
                 padNumber(this.getUTCMonth() + 1, 2) + '-' +
                 padNumber(this.getUTCDate(), 2) + 'T' +
                 padNumber(this.getUTCHours(), 2) + ':' +
                 padNumber(this.getUTCMinutes(), 2) + ':' +
                 padNumber(this.getUTCSeconds(), 2) + '.' +
                 padNumber(this.getUTCMilliseconds(), 3) + 'Z';
        },

         /***
         * @method toJSON([key])
         * @returns String
         * @polyfill ES5
         * @short Returns a JSON representation of the date.
         * @extra This is effectively an alias for `toISOString`. Will always return
         *        the date in UTC time. [key] is ignored.
         *
         * @example
         *
         *   Date.create().toJSON() -> ex. 2011-07-05 12:24:55.528Z
         *
         ***/
        'toJSON': function(key) {
          return this.toISOString(key);
        }

      }, !hasISOSupport());

    }).call(commonjsGlobal);
    });

    function isArrayIndex(n) {
      return n >>> 0 == n && n != 0xFFFFFFFF;
    }

    var isArrayIndex_1 = isArrayIndex;

    function getSparseArrayIndexes(arr, fromIndex, loop, fromRight) {
      var indexes = [], i;
      for (i in arr) {
        // istanbul ignore next
        if (isArrayIndex_1(i) && (loop || (fromRight ? i <= fromIndex : i >= fromIndex))) {
          indexes.push(+i);
        }
      }
      indexes.sort(function(a, b) {
        var aLoop = a > fromIndex;
        var bLoop = b > fromIndex;
        // This block cannot be reached unless ES5 methods are being shimmed.
        // istanbul ignore if
        if (aLoop !== bLoop) {
          return aLoop ? -1 : 1;
        }
        return a - b;
      });
      return indexes;
    }

    var getSparseArrayIndexes_1 = getSparseArrayIndexes;

    function iterateOverSparseArray(arr, fn, fromIndex, loop) {
      var indexes = getSparseArrayIndexes_1(arr, fromIndex, loop), index;
      for (var i = 0, len = indexes.length; i < len; i++) {
        index = indexes[i];
        fn.call(arr, arr[index], index, arr);
      }
      return arr;
    }

    var iterateOverSparseArray_1 = iterateOverSparseArray;

    function forEach(arr, fn) {
      for (var i = 0, len = arr.length; i < len; i++) {
        if (!(i in arr)) {
          return iterateOverSparseArray_1(arr, fn, i);
        }
        fn(arr[i], i);
      }
    }

    var forEach_1 = forEach;

    var NATIVE_TYPES = 'Boolean Number String Date RegExp Function Array Error Set Map';

    var coreUtilityAliases = {
      hasOwn: sugarCore.util.hasOwn,
      getOwn: sugarCore.util.getOwn,
      setProperty: sugarCore.util.setProperty,
      classToString: sugarCore.util.classToString,
      defineProperty: sugarCore.util.defineProperty,
      forEachProperty: sugarCore.util.forEachProperty,
      mapNativeToChainable: sugarCore.util.mapNativeToChainable
    };

    var classToString = coreUtilityAliases.classToString;

    function isClass(obj, className, str) {
      if (!str) {
        str = classToString(obj);
      }
      return str === '[object '+ className +']';
    }

    var isClass_1 = isClass;

    function spaceSplit(str) {
      return str.split(' ');
    }

    var spaceSplit_1 = spaceSplit;

    function isObjectType(obj, type) {
      return !!obj && (type || typeof obj) === 'object';
    }

    var isObjectType_1 = isObjectType;

    var hasOwn = coreUtilityAliases.hasOwn;

    function hasOwnEnumeratedProperties(obj) {
      // Plain objects are generally defined as having enumerated properties
      // all their own, however in early IE environments without defineProperty,
      // there may also be enumerated methods in the prototype chain, so check
      // for both of these cases.
      var objectProto = Object.prototype;
      for (var key in obj) {
        var val = obj[key];
        if (!hasOwn(obj, key) && val !== objectProto[key]) {
          return false;
        }
      }
      return true;
    }

    var hasOwnEnumeratedProperties_1 = hasOwnEnumeratedProperties;

    var hasOwn$1 = coreUtilityAliases.hasOwn;

    function hasValidPlainObjectPrototype(obj) {
      var hasToString = 'toString' in obj;
      var hasConstructor = 'constructor' in obj;
      // An object created with Object.create(null) has no methods in the
      // prototype chain, so check if any are missing. The additional hasToString
      // check is for false positives on some host objects in old IE which have
      // toString but no constructor. If the object has an inherited constructor,
      // then check if it is Object (the "isPrototypeOf" tapdance here is a more
      // robust way of ensuring this if the global has been hijacked). Note that
      // accessing the constructor directly (without "in" or "hasOwnProperty")
      // will throw a permissions error in IE8 on cross-domain windows.
      return (!hasConstructor && !hasToString) ||
              (hasConstructor && !hasOwn$1(obj, 'constructor') &&
               hasOwn$1(obj.constructor.prototype, 'isPrototypeOf'));
    }

    var hasValidPlainObjectPrototype_1 = hasValidPlainObjectPrototype;

    function isPlainObject(obj, className) {
      return isObjectType_1(obj) &&
             isClass_1(obj, 'Object', className) &&
             hasValidPlainObjectPrototype_1(obj) &&
             hasOwnEnumeratedProperties_1(obj);
    }

    var isPlainObject_1 = isPlainObject;

    var isSerializable,
        isBoolean, isNumber, isString,
        isDate, isRegExp, isFunction,
        isArray, isSet, isMap, isError;

    function buildClassChecks() {

      var knownTypes = {};

      function addCoreTypes() {

        var names = spaceSplit_1(NATIVE_TYPES);

        isBoolean = buildPrimitiveClassCheck(names[0]);
        isNumber  = buildPrimitiveClassCheck(names[1]);
        isString  = buildPrimitiveClassCheck(names[2]);

        isDate   = buildClassCheck(names[3]);
        isRegExp = buildClassCheck(names[4]);

        // Wanted to enhance performance here by using simply "typeof"
        // but Firefox has two major issues that make this impossible,
        // one fixed, the other not, so perform a full class check here.
        //
        // 1. Regexes can be typeof "function" in FF < 3
        //    https://bugzilla.mozilla.org/show_bug.cgi?id=61911 (fixed)
        //
        // 2. HTMLEmbedElement and HTMLObjectElement are be typeof "function"
        //    https://bugzilla.mozilla.org/show_bug.cgi?id=268945 (won't fix)
        isFunction = buildClassCheck(names[5]);

        // istanbul ignore next
        isArray = Array.isArray || buildClassCheck(names[6]);
        isError = buildClassCheck(names[7]);

        isSet = buildClassCheck(names[8], typeof Set !== 'undefined' && Set);
        isMap = buildClassCheck(names[9], typeof Map !== 'undefined' && Map);

        // Add core types as known so that they can be checked by value below,
        // notably excluding Functions and adding Arguments and Error.
        addKnownType('Arguments');
        addKnownType(names[0]);
        addKnownType(names[1]);
        addKnownType(names[2]);
        addKnownType(names[3]);
        addKnownType(names[4]);
        addKnownType(names[6]);

      }

      function addArrayTypes() {
        var types = 'Int8 Uint8 Uint8Clamped Int16 Uint16 Int32 Uint32 Float32 Float64';
        forEach_1(spaceSplit_1(types), function(str) {
          addKnownType(str + 'Array');
        });
      }

      function addKnownType(className) {
        var str = '[object '+ className +']';
        knownTypes[str] = true;
      }

      function isKnownType(className) {
        return knownTypes[className];
      }

      function buildClassCheck(className, globalObject) {
        // istanbul ignore if
        if (globalObject && isClass_1(new globalObject, 'Object')) {
          return getConstructorClassCheck(globalObject);
        } else {
          return getToStringClassCheck(className);
        }
      }

      // Map and Set may be [object Object] in certain IE environments.
      // In this case we need to perform a check using the constructor
      // instead of Object.prototype.toString.
      // istanbul ignore next
      function getConstructorClassCheck(obj) {
        var ctorStr = String(obj);
        return function(obj) {
          return String(obj.constructor) === ctorStr;
        };
      }

      function getToStringClassCheck(className) {
        return function(obj, str) {
          // perf: Returning up front on instanceof appears to be slower.
          return isClass_1(obj, className, str);
        };
      }

      function buildPrimitiveClassCheck(className) {
        var type = className.toLowerCase();
        return function(obj) {
          var t = typeof obj;
          return t === type || t === 'object' && isClass_1(obj, className);
        };
      }

      addCoreTypes();
      addArrayTypes();

      isSerializable = function(obj, className) {
        // Only known objects can be serialized. This notably excludes functions,
        // host objects, Symbols (which are matched by reference), and instances
        // of classes. The latter can arguably be matched by value, but
        // distinguishing between these and host objects -- which should never be
        // compared by value -- is very tricky so not dealing with it here.
        return isKnownType(className) || isPlainObject_1(obj, className);
      };

    }

    buildClassChecks();

    var classChecks = {
      isSerializable: isSerializable,
      isBoolean: isBoolean,
      isNumber: isNumber,
      isString: isString,
      isDate: isDate,
      isRegExp: isRegExp,
      isFunction: isFunction,
      isArray: isArray,
      isSet: isSet,
      isMap: isMap,
      isError: isError
    };

    function getNormalizedIndex(index, length, loop) {
      if (index && loop) {
        index = index % length;
      }
      if (index < 0) index = length + index;
      return index;
    }

    var getNormalizedIndex_1 = getNormalizedIndex;

    function entryAtIndex(obj, index, length, loop, isString) {
      index = getNormalizedIndex_1(index, length, loop);
      return isString ? obj.charAt(index) : obj[index];
    }

    var entryAtIndex_1 = entryAtIndex;

    var isArray$1 = classChecks.isArray;

    function getEntriesForIndexes(obj, find, loop, isString) {
      var result, length = obj.length;
      if (!isArray$1(find)) {
        return entryAtIndex_1(obj, find, length, loop, isString);
      }
      result = new Array(find.length);
      forEach_1(find, function(index, i) {
        result[i] = entryAtIndex_1(obj, index, length, loop, isString);
      });
      return result;
    }

    var getEntriesForIndexes_1 = getEntriesForIndexes;

    sugarCore.String.defineInstance({

      'at': function(str, index, loop) {
        return getEntriesForIndexes_1(str, index, loop, true);
      }

    });

    var at = sugarCore.String.at;

    var CAMELIZE_REG = /(^|_)([^_]+)/g;

    var Inflections = {};

    function getAcronym(str) {
      // istanbul ignore next
      return Inflections.acronyms ;
    }

    var getAcronym_1 = getAcronym;

    function stringUnderscore(str) {
      return str
        .replace(/[-\s]+/g, '_')
        .replace(/([A-Z\d]+)([A-Z][a-z])/g,'$1_$2')
        .replace(/([a-z\d])([A-Z])/g,'$1_$2')
        .toLowerCase();
    }

    var stringUnderscore_1 = stringUnderscore;

    var CAPITALIZE_REG = /[^\u0000-\u0040\u005B-\u0060\u007B-\u007F]+('s)?/g;

    function simpleCapitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    var simpleCapitalize_1 = simpleCapitalize;

    function stringCapitalize(str, downcase, all) {
      if (downcase) {
        str = str.toLowerCase();
      }
      return all ? str.replace(CAPITALIZE_REG, simpleCapitalize_1) : simpleCapitalize_1(str);
    }

    var stringCapitalize_1 = stringCapitalize;

    function stringCamelize(str, upper) {
      str = stringUnderscore_1(str);
      return str.replace(CAMELIZE_REG, function(match, pre, word, index) {
        var cap = upper !== false || index > 0, acronym;
        acronym = getAcronym_1();
        // istanbul ignore if
        if (acronym && cap) {
          return acronym;
        }
        return cap ? stringCapitalize_1(word, true) : word;
      });
    }

    var stringCamelize_1 = stringCamelize;

    sugarCore.String.defineInstance({

      'camelize': function(str, upper) {
        return stringCamelize_1(str, upper);
      }

    });

    var camelize = sugarCore.String.camelize;

    sugarCore.String.defineInstance({

      'capitalize': function(str, lower, all) {
        return stringCapitalize_1(str, lower, all);
      }

    });

    var capitalize = sugarCore.String.capitalize;

    function isDefined(o) {
      return o !== undefined;
    }

    var isDefined_1 = isDefined;

    var isString$1 = classChecks.isString;

    function escapeRegExp(str) {
      if (!isString$1(str)) str = String(str);
      return str.replace(/([\\/'*+?|()[\]{}.^$-])/g,'\\$1');
    }

    var escapeRegExp_1 = escapeRegExp;

    function getRegExpFlags(reg, add) {
      var flags = '';
      add = add || '';
      function checkFlag(prop, flag) {
        if (prop || add.indexOf(flag) > -1) {
          flags += flag;
        }
      }
      checkFlag(reg.global, 'g');
      checkFlag(reg.ignoreCase, 'i');
      checkFlag(reg.multiline, 'm');
      checkFlag(reg.sticky, 'y');
      return flags;
    }

    var getRegExpFlags_1 = getRegExpFlags;

    function runGlobalMatch(str, reg) {
      var result = [], match, lastLastIndex;
      while ((match = reg.exec(str)) != null) {
        if (reg.lastIndex === lastLastIndex) {
          reg.lastIndex += 1;
        } else {
          result.push(match[0]);
        }
        lastLastIndex = reg.lastIndex;
      }
      return result;
    }

    var runGlobalMatch_1 = runGlobalMatch;

    var isString$2 = classChecks.isString,
        isRegExp$1 = classChecks.isRegExp,
        isFunction$1 = classChecks.isFunction;

    function stringEach(str, search, fn) {
      var chunks, chunk, reg, result = [];
      if (isFunction$1(search)) {
        fn = search;
        reg = /[\s\S]/g;
      } else if (!search) {
        reg = /[\s\S]/g;
      } else if (isString$2(search)) {
        reg = RegExp(escapeRegExp_1(search), 'gi');
      } else if (isRegExp$1(search)) {
        reg = RegExp(search.source, getRegExpFlags_1(search, 'g'));
      }
      // Getting the entire array of chunks up front as we need to
      // pass this into the callback function as an argument.
      chunks = runGlobalMatch_1(str, reg);

      if (chunks) {
        for(var i = 0, len = chunks.length, r; i < len; i++) {
          chunk = chunks[i];
          result[i] = chunk;
          if (fn) {
            r = fn.call(str, chunk, i, chunks);
            if (r === false) {
              break;
            } else if (isDefined_1(r)) {
              result[i] = r;
            }
          }
        }
      }
      return result;
    }

    var stringEach_1 = stringEach;

    sugarCore.String.defineInstance({

      'chars': function(str, search, eachCharFn) {
        return stringEach_1(str, search, eachCharFn);
      }

    });

    var chars = sugarCore.String.chars;

    function stringCodes(str, fn) {
      var codes = new Array(str.length), i, len;
      for(i = 0, len = str.length; i < len; i++) {
        var code = str.charCodeAt(i);
        codes[i] = code;
        if (fn) {
          fn.call(str, code, i, str);
        }
      }
      return codes;
    }

    var stringCodes_1 = stringCodes;

    sugarCore.String.defineInstance({

      'codes': function(str, eachCodeFn) {
        return stringCodes_1(str, eachCodeFn);
      }

    });

    var codes = sugarCore.String.codes;

    function trim(str) {
      return str.trim();
    }

    var trim_1 = trim;

    sugarCore.String.defineInstance({

      'compact': function(str) {
        return trim_1(str).replace(/([\r\n\s　])+/g, function(match, whitespace) {
          return whitespace === '　' ? whitespace : ' ';
        });
      }

    });

    var compact = sugarCore.String.compact;

    sugarCore.String.defineInstance({

      'dasherize': function(str) {
        return stringUnderscore_1(str).replace(/_/g, '-');
      }

    });

    var dasherize = sugarCore.String.dasherize;

    var chr = String.fromCharCode;

    var encodeBase64, decodeBase64;

    function buildBase64() {
      var encodeAscii, decodeAscii;

      // istanbul ignore next
      function catchEncodingError(fn) {
        return function(str) {
          try {
            return fn(str);
          } catch(e) {
            return '';
          }
        };
      }

      // istanbul ignore if
      if (typeof Buffer !== 'undefined') {
        encodeBase64 = function(str) {
          return Buffer.from(str).toString('base64');
        };
        decodeBase64 = function(str) {
          return Buffer.from(str, 'base64').toString('utf8');
        };
        return;
      }

      // istanbul ignore if
      if (typeof btoa !== 'undefined') {
        encodeAscii = catchEncodingError(btoa);
        decodeAscii = catchEncodingError(atob);
      } else {
        var key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var base64reg = /[^A-Za-z0-9\+\/\=]/g;
        encodeAscii = function(str) {
          var output = '';
          var chr1, chr2, chr3;
          var enc1, enc2, enc3, enc4;
          var i = 0;
          do {
            chr1 = str.charCodeAt(i++);
            chr2 = str.charCodeAt(i++);
            chr3 = str.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
              enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
              enc4 = 64;
            }
            output += key.charAt(enc1);
            output += key.charAt(enc2);
            output += key.charAt(enc3);
            output += key.charAt(enc4);
            chr1 = chr2 = chr3 = '';
            enc1 = enc2 = enc3 = enc4 = '';
          } while (i < str.length);
          return output;
        };
        decodeAscii = function(input) {
          var output = '';
          var chr1, chr2, chr3;
          var enc1, enc2, enc3, enc4;
          var i = 0;
          if (input.match(base64reg)) {
            return '';
          }
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
          do {
            enc1 = key.indexOf(input.charAt(i++));
            enc2 = key.indexOf(input.charAt(i++));
            enc3 = key.indexOf(input.charAt(i++));
            enc4 = key.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output = output + chr(chr1);
            if (enc3 != 64) {
              output = output + chr(chr2);
            }
            if (enc4 != 64) {
              output = output + chr(chr3);
            }
            chr1 = chr2 = chr3 = '';
            enc1 = enc2 = enc3 = enc4 = '';
          } while (i < input.length);
          return output;
        };
      }
      encodeBase64 = function(str) {
        return encodeAscii(unescape(encodeURIComponent(str)));
      };
      decodeBase64 = function(str) {
        return decodeURIComponent(escape(decodeAscii(str)));
      };
    }

    buildBase64();

    var base64 = {
      encodeBase64: encodeBase64,
      decodeBase64: decodeBase64
    };

    var decodeBase64$1 = base64.decodeBase64;

    sugarCore.String.defineInstance({

      'decodeBase64': function(str) {
        return decodeBase64$1(str);
      }

    });

    var decodeBase64_1 = sugarCore.String.decodeBase64;

    var encodeBase64$1 = base64.encodeBase64;

    sugarCore.String.defineInstance({

      'encodeBase64': function(str) {
        return encodeBase64$1(str);
      }

    });

    var encodeBase64_1 = sugarCore.String.encodeBase64;

    var HTML_ESCAPE_REG = /[&<>]/g;

    var HTMLFromEntityMap = {
      'lt':    '<',
      'gt':    '>',
      'amp':   '&',
      'nbsp':  ' ',
      'quot':  '"',
      'apos':  "'"
    };

    var HTMLFromEntityMap_1 = HTMLFromEntityMap;

    var forEachProperty = coreUtilityAliases.forEachProperty;

    var HTMLToEntityMap;

    function buildEntities() {
      HTMLToEntityMap = {};
      forEachProperty(HTMLFromEntityMap_1, function(val, key) {
        HTMLToEntityMap[val] = '&' + key + ';';
      });
    }

    buildEntities();

    var HTMLToEntityMap_1 = HTMLToEntityMap;

    var getOwn = coreUtilityAliases.getOwn;

    sugarCore.String.defineInstance({

      'escapeHTML': function(str) {
        return str.replace(HTML_ESCAPE_REG, function(chr) {
          return getOwn(HTMLToEntityMap_1, chr);
        });
      }

    });

    var escapeHTML = sugarCore.String.escapeHTML;

    sugarCore.String.defineInstance({

      'escapeURL': function(str, param) {
        return param ? encodeURIComponent(str) : encodeURI(str);
      }

    });

    var escapeURL = sugarCore.String.escapeURL;

    function isUndefined(o) {
      return o === undefined;
    }

    var isUndefined_1 = isUndefined;

    sugarCore.String.defineInstance({

      'first': function(str, num) {
        if (isUndefined_1(num)) num = 1;
        return str.substr(0, num);
      }

    });

    var first = sugarCore.String.first;

    sugarCore.String.defineInstance({

      'forEach': function(str, search, eachFn) {
        return stringEach_1(str, search, eachFn);
      }

    });

    var forEach$1 = sugarCore.String.forEach;

    var PROPERTY_RANGE_REG = /^(.*?)\[([-\d]*)\.\.([-\d]*)\](.*)$/;

    var CommonChars = {
      HALF_WIDTH_ZERO: 0x30,
      FULL_WIDTH_ZERO: 0xff10,
      HALF_WIDTH_PERIOD: '.',
      FULL_WIDTH_PERIOD: '．',
      HALF_WIDTH_COMMA: ',',
      OPEN_BRACE: '{',
      CLOSE_BRACE: '}'
    };

    function map(arr, fn) {
      // perf: Not using fixed array len here as it may be sparse.
      var result = [];
      for (var i = 0, len = arr.length; i < len; i++) {
        if (i in arr) {
          result.push(fn(arr[i], i));
        }
      }
      return result;
    }

    var map_1 = map;

    var HALF_WIDTH_PERIOD = CommonChars.HALF_WIDTH_PERIOD;

    function periodSplit(str) {
      return str.split(HALF_WIDTH_PERIOD);
    }

    var periodSplit_1 = periodSplit;

    var isArray$2 = classChecks.isArray;

    function assertArray(obj) {
      if (!isArray$2(obj)) {
        throw new TypeError('Array required');
      }
    }

    var assertArray_1 = assertArray;

    function isPrimitive(obj, type) {
      type = type || typeof obj;
      return obj == null || type === 'string' || type === 'number' || type === 'boolean';
    }

    var isPrimitive_1 = isPrimitive;

    function assertWritable(obj) {
      if (isPrimitive_1(obj)) {
        // If strict mode is active then primitives will throw an
        // error when attempting to write properties. We can't be
        // sure if strict mode is available, so pre-emptively
        // throw an error here to ensure consistent behavior.
        throw new TypeError('Property cannot be written');
      }
    }

    var assertWritable_1 = assertWritable;

    var isString$3 = classChecks.isString,
        hasOwn$2 = coreUtilityAliases.hasOwn,
        HALF_WIDTH_PERIOD$1 = CommonChars.HALF_WIDTH_PERIOD;

    function handleDeepProperty(obj, key, any, has, fill, fillLast, val) {
      var ns, bs, ps, cbi, set, isLast, isPush, isIndex, nextIsIndex, exists;
      ns = obj;
      if (key == null) return;

      if (isObjectType_1(key)) {
        // Allow array and array-like accessors
        bs = [key];
      } else {
        key = String(key);
        if (key.indexOf('..') !== -1) {
          return handleArrayIndexRange(obj, key, any, val);
        }
        bs = key.split('[');
      }

      set = isDefined_1(val);

      for (var i = 0, blen = bs.length; i < blen; i++) {
        ps = bs[i];

        if (isString$3(ps)) {
          ps = periodSplit_1(ps);
        }

        for (var j = 0, plen = ps.length; j < plen; j++) {
          key = ps[j];

          // Is this the last key?
          isLast = i === blen - 1 && j === plen - 1;

          // Index of the closing ]
          cbi = key.indexOf(']');

          // Is the key an array index?
          isIndex = cbi !== -1;

          // Is this array push syntax "[]"?
          isPush = set && cbi === 0;

          // If the bracket split was successful and this is the last element
          // in the dot split, then we know the next key will be an array index.
          nextIsIndex = blen > 1 && j === plen - 1;

          if (isPush) {
            // Set the index to the end of the array
            key = ns.length;
          } else if (isIndex) {
            // Remove the closing ]
            key = key.slice(0, -1);
          }

          // If the array index is less than 0, then
          // add its length to allow negative indexes.
          if (isIndex && key < 0) {
            key = +key + ns.length;
          }

          // Bracket keys may look like users[5] or just [5], so the leading
          // characters are optional. We can enter the namespace if this is the
          // 2nd part, if there is only 1 part, or if there is an explicit key.
          if (i || key || blen === 1) {

            // TODO: need to be sure this check handles ''.length when
            // we refactor.
            exists = any ? key in Object(ns) : hasOwn$2(ns, key);

            // Non-existent namespaces are only filled if they are intermediate
            // (not at the end) or explicitly filling the last.
            if (fill && (!isLast || fillLast) && !exists) {
              // For our purposes, last only needs to be an array.
              ns = ns[key] = nextIsIndex || (fillLast && isLast) ? [] : {};
              continue;
            }

            if (has) {
              if (isLast || !exists) {
                return exists;
              }
            } else if (set && isLast) {
              assertWritable_1(ns);
              ns[key] = val;
            }

            ns = exists ? ns[key] : undefined;
          }

        }
      }
      return ns;
    }

    function handleArrayIndexRange(obj, key, any, val) {
      var match, start, end, leading, trailing, arr, set;
      match = key.match(PROPERTY_RANGE_REG);
      if (!match) {
        return;
      }

      set = isDefined_1(val);
      leading = match[1];

      if (leading) {
        arr = handleDeepProperty(obj, leading, any, false, set ? true : false, true);
      } else {
        arr = obj;
      }

      assertArray_1(arr);

      trailing = match[4];
      start    = match[2] ? +match[2] : 0;
      end      = match[3] ? +match[3] : arr.length;

      // A range of 0..1 is inclusive, so we need to add 1 to the end. If this
      // pushes the index from -1 to 0, then set it to the full length of the
      // array, otherwise it will return nothing.
      end = end === -1 ? arr.length : end + 1;

      if (set) {
        for (var i = start; i < end; i++) {
          handleDeepProperty(arr, i + trailing, any, false, true, false, val);
        }
      } else {
        arr = arr.slice(start, end);

        // If there are trailing properties, then they need to be mapped for each
        // element in the array.
        if (trailing) {
          if (trailing.charAt(0) === HALF_WIDTH_PERIOD$1) {
            // Need to chomp the period if one is trailing after the range. We
            // can't do this at the regex level because it will be required if
            // we're setting the value as it needs to be concatentated together
            // with the array index to be set.
            trailing = trailing.slice(1);
          }
          return map_1(arr, function(el) {
            return handleDeepProperty(el, trailing);
          });
        }
      }
      return arr;
    }

    var handleDeepProperty_1 = handleDeepProperty;

    function deepGetProperty(obj, key, any) {
      return handleDeepProperty_1(obj, key, any, false);
    }

    var deepGetProperty_1 = deepGetProperty;

    var STRING_FORMAT_REG = /([{}])\1|{([^}]*)}|(%)%|(%(\w*))/g;

    var INTERNAL_MEMOIZE_LIMIT = 1000;

    var hasOwn$3 = coreUtilityAliases.hasOwn;

    function memoizeFunction(fn) {
      var memo = {}, counter = 0;

      return function(key) {
        if (hasOwn$3(memo, key)) {
          return memo[key];
        }
        // istanbul ignore if
        if (counter === INTERNAL_MEMOIZE_LIMIT) {
          memo = {};
          counter = 0;
        }
        counter++;
        return memo[key] = fn(key);
      };
    }

    var memoizeFunction_1 = memoizeFunction;

    var OPEN_BRACE = CommonChars.OPEN_BRACE,
        CLOSE_BRACE = CommonChars.CLOSE_BRACE;

    function createFormatMatcher(bracketMatcher, percentMatcher, precheck) {

      var reg = STRING_FORMAT_REG;
      var compileMemoized = memoizeFunction_1(compile);

      function getToken(format, match) {
        var get, token, literal, fn;
        var bKey = match[2];
        var pLit = match[3];
        var pKey = match[5];
        if (match[4] && percentMatcher) {
          token = pKey;
          get = percentMatcher;
        } else if (bKey) {
          token = bKey;
          get = bracketMatcher;
        } else if (pLit && percentMatcher) {
          literal = pLit;
        } else {
          literal = match[1] || match[0];
        }
        if (get) {
          assertPassesPrecheck(precheck, bKey, pKey);
          fn = function(obj, opt) {
            return get(obj, token, opt);
          };
        }
        format.push(fn || getLiteral(literal));
      }

      function getSubstring(format, str, start, end) {
        if (end > start) {
          var sub = str.slice(start, end);
          assertNoUnmatched(sub, OPEN_BRACE);
          assertNoUnmatched(sub, CLOSE_BRACE);
          format.push(function() {
            return sub;
          });
        }
      }

      function getLiteral(str) {
        return function() {
          return str;
        };
      }

      function assertPassesPrecheck(precheck, bt, pt) {
        if (precheck && !precheck(bt, pt)) {
          throw new TypeError('Invalid token '+ (bt || pt) +' in format string');
        }
      }

      function assertNoUnmatched(str, chr) {
        if (str.indexOf(chr) !== -1) {
          throw new TypeError('Unmatched '+ chr +' in format string');
        }
      }

      function compile(str) {
        var format = [], lastIndex = 0, match;
        reg.lastIndex = 0;
        while(match = reg.exec(str)) {
          getSubstring(format, str, lastIndex, match.index);
          getToken(format, match);
          lastIndex = reg.lastIndex;
        }
        getSubstring(format, str, lastIndex, str.length);
        return format;
      }

      return function(str, obj, opt) {
        var format = compileMemoized(str), result = '';
        for (var i = 0; i < format.length; i++) {
          result += format[i](obj, opt);
        }
        return result;
      };
    }

    var createFormatMatcher_1 = createFormatMatcher;

    var stringFormatMatcher = createFormatMatcher_1(deepGetProperty_1);

    sugarCore.String.defineInstanceWithArguments({

      'format': function(str, args) {
        var arg1 = args[0] && args[0].valueOf();
        // Unwrap if a single object is passed in.
        if (args.length === 1 && isObjectType_1(arg1)) {
          args = arg1;
        }
        return stringFormatMatcher(str, args);
      }

    });

    var format$1 = sugarCore.String.format;

    var isString$4 = classChecks.isString;

    function numberOrIndex(str, n, from) {
      if (isString$4(n)) {
        n = str.indexOf(n);
        if (n === -1) {
          n = from ? str.length : 0;
        }
      }
      return n;
    }

    var numberOrIndex_1 = numberOrIndex;

    sugarCore.String.defineInstance({

      'from': function(str, from) {
        return str.slice(numberOrIndex_1(str, from, true));
      }

    });

    var from_1 = sugarCore.String.from;

    var ENHANCEMENTS_FLAG = 'enhance';

    var STRING_ENHANCEMENTS_FLAG = 'enhanceString';

    function fixArgumentLength(fn) {
      var staticFn = function(a) {
        var args = arguments;
        return fn(a, args[1], args[2], args.length - 1);
      };
      staticFn.instance = function(b) {
        var args = arguments;
        return fn(this, b, args[1], args.length);
      };
      return staticFn;
    }

    var fixArgumentLength_1 = fixArgumentLength;

    var nativeIncludes = String.prototype.includes;

    var isRegExp$2 = classChecks.isRegExp;

    function callIncludesWithRegexSupport(str, search, position) {
      if (!isRegExp$2(search)) {
        return nativeIncludes.call(str, search, position);
      }
      if (position) {
        str = str.slice(position);
      }
      return search.test(str);
    }

    var callIncludesWithRegexSupport_1 = callIncludesWithRegexSupport;

    sugarCore.String.defineInstance({

      'includes': fixArgumentLength_1(callIncludesWithRegexSupport_1)

    }, [ENHANCEMENTS_FLAG, STRING_ENHANCEMENTS_FLAG]);

    var includes = sugarCore.String.includes;

    sugarCore.String.defineInstance({

      'insert': function(str, substr, index) {
        index = isUndefined_1(index) ? str.length : index;
        return str.slice(0, index) + substr + str.slice(index);
      }

    });

    var insert$1 = sugarCore.String.insert;

    sugarCore.String.defineInstance({

      'isBlank': function(str) {
        return trim_1(str).length === 0;
      }

    });

    var isBlank = sugarCore.String.isBlank;

    sugarCore.String.defineInstance({

      'isEmpty': function(str) {
        return str.length === 0;
      }

    });

    var isEmpty = sugarCore.String.isEmpty;

    sugarCore.String.defineInstance({

      'last': function(str, num) {
        if (isUndefined_1(num)) num = 1;
        var start = str.length - num < 0 ? 0 : str.length - num;
        return str.substr(start);
      }

    });

    var last = sugarCore.String.last;

    sugarCore.String.defineInstance({

      'lines': function(str, eachLineFn) {
        return stringEach_1(trim_1(str), /^.*$/gm, eachLineFn);
      }

    });

    var lines = sugarCore.String.lines;

    function repeatString(str, num) {
      var result = '';
      str = str.toString();
      while (num > 0) {
        if (num & 1) {
          result += str;
        }
        if (num >>= 1) {
          str += str;
        }
      }
      return result;
    }

    var repeatString_1 = repeatString;

    function padString(num, padding) {
      return repeatString_1(isDefined_1(padding) ? padding : ' ', num);
    }

    var padString_1 = padString;

    var mathAliases = {
      abs: Math.abs,
      pow: Math.pow,
      min: Math.min,
      max: Math.max,
      ceil: Math.ceil,
      floor: Math.floor,
      round: Math.round
    };

    var ceil = mathAliases.ceil,
        floor = mathAliases.floor;

    var trunc = Math.trunc || function(n) {
      if (n === 0 || !isFinite(n)) return n;
      return n < 0 ? ceil(n) : floor(n);
    };

    var trunc_1 = trunc;

    var isNumber$1 = classChecks.isNumber;

    function coercePositiveInteger(n) {
      n = +n || 0;
      if (n < 0 || !isNumber$1(n) || !isFinite(n)) {
        throw new RangeError('Invalid number');
      }
      return trunc_1(n);
    }

    var coercePositiveInteger_1 = coercePositiveInteger;

    var max = mathAliases.max,
        ceil$1 = mathAliases.ceil,
        floor$1 = mathAliases.floor;

    sugarCore.String.defineInstance({

      'pad': function(str, num, padding) {
        var half, front, back;
        num   = coercePositiveInteger_1(num);
        half  = max(0, num - str.length) / 2;
        front = floor$1(half);
        back  = ceil$1(half);
        return padString_1(front, padding) + str + padString_1(back, padding);
      }

    });

    var pad = sugarCore.String.pad;

    var max$1 = mathAliases.max;

    sugarCore.String.defineInstance({

      'padLeft': function(str, num, padding) {
        num = coercePositiveInteger_1(num);
        return padString_1(max$1(0, num - str.length), padding) + str;
      }

    });

    var padLeft = sugarCore.String.padLeft;

    var max$2 = mathAliases.max;

    sugarCore.String.defineInstance({

      'padRight': function(str, num, padding) {
        num = coercePositiveInteger_1(num);
        return str + padString_1(max$2(0, num - str.length), padding);
      }

    });

    var padRight = sugarCore.String.padRight;

    function stringParameterize(str, separator) {
      if (separator === undefined) separator = '-';
      str = str.replace(/[^a-z0-9\-_]+/gi, separator);
      if (separator) {
        var reg = RegExp('^{s}+|{s}+$|({s}){s}+'.split('{s}').join(escapeRegExp_1(separator)), 'g');
        str = str.replace(reg, '$1');
      }
      return encodeURI(str.toLowerCase());
    }

    var stringParameterize_1 = stringParameterize;

    sugarCore.String.defineInstance({

      'parameterize': function(str, separator) {
        return stringParameterize_1(str, separator);
      }

    });

    var parameterize = sugarCore.String.parameterize;

    sugarCore.String.defineInstance({

      'remove': function(str, f) {
        return str.replace(f, '');
      }

    });

    var remove = sugarCore.String.remove;

    var isString$5 = classChecks.isString;

    function stringReplaceAll(str, f, replace) {
      var i = 0, tokens;
      if (isString$5(f)) {
        f = RegExp(escapeRegExp_1(f), 'g');
      } else if (f && !f.global) {
        f = RegExp(f.source, getRegExpFlags_1(f, 'g'));
      }
      if (!replace) {
        replace = '';
      } else {
        tokens = replace;
        replace = function() {
          var t = tokens[i++];
          return t != null ? t : '';
        };
      }
      return str.replace(f, replace);
    }

    var stringReplaceAll_1 = stringReplaceAll;

    sugarCore.String.defineInstance({

      'removeAll': function(str, f) {
        return stringReplaceAll_1(str, f);
      }

    });

    var removeAll = sugarCore.String.removeAll;

    var HTML_VOID_ELEMENTS = [
      'area','base','br','col','command','embed','hr','img',
      'input','keygen','link','meta','param','source','track','wbr'
    ];

    var HTML_VOID_ELEMENTS_1 = HTML_VOID_ELEMENTS;

    function indexOf(arr, el) {
      for (var i = 0, len = arr.length; i < len; i++) {
        if (i in arr && arr[i] === el) return i;
      }
      return -1;
    }

    var indexOf_1 = indexOf;

    function tagIsVoid(tag) {
      return indexOf_1(HTML_VOID_ELEMENTS_1, tag.toLowerCase()) !== -1;
    }

    var tagIsVoid_1 = tagIsVoid;

    var isString$6 = classChecks.isString;

    function runTagReplacements(str, reg, strip, replacement, fullString) {

      var match;
      var result = '';
      var currentIndex = 0;
      var openTagName;
      var openTagAttributes;
      var openTagCount = 0;

      function processTag(index, tagName, attributes, tagLength, isVoid) {
        var content = str.slice(currentIndex, index), s = '', r = '';
        if (isString$6(replacement)) {
          r = replacement;
        } else if (replacement) {
          r = replacement.call(fullString, tagName, content, attributes, fullString) || '';
        }
        if (strip) {
          s = r;
        } else {
          content = r;
        }
        if (content) {
          content = runTagReplacements(content, reg, strip, replacement, fullString);
        }
        result += s + content + (isVoid ? '' : s);
        currentIndex = index + (tagLength || 0);
      }

      fullString = fullString || str;
      reg = RegExp(reg.source, 'gi');

      while(match = reg.exec(str)) {

        var tagName         = match[2];
        var attributes      = (match[3]|| '').slice(1);
        var isClosingTag    = !!match[1];
        var isSelfClosing   = !!match[4];
        var tagLength       = match[0].length;
        var isVoid          = tagIsVoid_1(tagName);
        var isOpeningTag    = !isClosingTag && !isSelfClosing && !isVoid;
        var isSameAsCurrent = tagName === openTagName;

        if (!openTagName) {
          result += str.slice(currentIndex, match.index);
          currentIndex = match.index;
        }

        if (isOpeningTag) {
          if (!openTagName) {
            openTagName = tagName;
            openTagAttributes = attributes;
            openTagCount++;
            currentIndex += tagLength;
          } else if (isSameAsCurrent) {
            openTagCount++;
          }
        } else if (isClosingTag && isSameAsCurrent) {
          openTagCount--;
          if (openTagCount === 0) {
            processTag(match.index, openTagName, openTagAttributes, tagLength, isVoid);
            openTagName       = null;
            openTagAttributes = null;
          }
        } else if (!openTagName) {
          processTag(match.index, tagName, attributes, tagLength, isVoid);
        }
      }
      if (openTagName) {
        processTag(str.length, openTagName, openTagAttributes);
      }
      result += str.slice(currentIndex);
      return result;
    }

    var runTagReplacements_1 = runTagReplacements;

    var isString$7 = classChecks.isString;

    function replaceTags(str, find, replacement, strip) {
      var tags = isString$7(find) ? [find] : find, reg, src;
      tags = map_1(tags || [], function(t) {
        return escapeRegExp_1(t);
      }).join('|');
      src = tags.replace('all', '') || '[^\\s>]+';
      src = '<(\\/)?(' + src + ')(\\s+[^<>]*?)?\\s*(\\/)?>';
      reg = RegExp(src, 'gi');
      return runTagReplacements_1(str.toString(), reg, strip, replacement);
    }

    var replaceTags_1 = replaceTags;

    sugarCore.String.defineInstance({

      'removeTags': function(str, tag, replace) {
        return replaceTags_1(str, tag, replace, false);
      }

    });

    var removeTags = sugarCore.String.removeTags;

    sugarCore.String.defineInstanceWithArguments({

      'replaceAll': function(str, f, args) {
        return stringReplaceAll_1(str, f, args);
      }

    });

    var replaceAll = sugarCore.String.replaceAll;

    function reverseString(str) {
      return str.split('').reverse().join('');
    }

    var reverseString_1 = reverseString;

    sugarCore.String.defineInstance({

      'reverse': function(str) {
        return reverseString_1(str);
      }

    });

    var reverse = sugarCore.String.reverse;

    sugarCore.String.defineInstance({

      'shift': function(str, n) {
        var result = '';
        n = n || 0;
        stringCodes_1(str, function(c) {
          result += chr(c + n);
        });
        return result;
      }

    });

    var shift = sugarCore.String.shift;

    function stringSpacify(str) {
      return stringUnderscore_1(str).replace(/_/g, ' ');
    }

    var stringSpacify_1 = stringSpacify;

    sugarCore.String.defineInstance({

      'spacify': function(str) {
        return stringSpacify_1(str);
      }

    });

    var spacify = sugarCore.String.spacify;

    sugarCore.String.defineInstance({

      'stripTags': function(str, tag, replace) {
        return replaceTags_1(str, tag, replace, true);
      }

    });

    var stripTags = sugarCore.String.stripTags;

    var DOWNCASED_WORDS = [
      'and', 'or', 'nor', 'a', 'an', 'the', 'so', 'but', 'to', 'of', 'at',
      'by', 'from', 'into', 'on', 'onto', 'off', 'out', 'in', 'over',
      'with', 'for'
    ];

    var DOWNCASED_WORDS_1 = DOWNCASED_WORDS;

    function eachWord(str, fn) {
      return stringEach_1(trim_1(str), /\S+/g, fn);
    }

    var eachWord_1 = eachWord;

    function runHumanRules(str) {
      // istanbul ignore next
      return  str;
    }

    var runHumanRules_1 = runHumanRules;

    function stringTitleize(str) {
      var fullStopPunctuation = /[.:;!]$/, lastHadPunctuation;
      str = runHumanRules_1(str);
      str = stringSpacify_1(str);
      return eachWord_1(str, function(word, index, words) {
        word =  word;
        word =  word;
        var hasPunctuation, isFirstOrLast;
        var first = index == 0, last = index == words.length - 1;
        hasPunctuation = fullStopPunctuation.test(word);
        isFirstOrLast = first || last || hasPunctuation || lastHadPunctuation;
        lastHadPunctuation = hasPunctuation;
        if (isFirstOrLast || indexOf_1(DOWNCASED_WORDS_1, word) === -1) {
          return stringCapitalize_1(word, false, true);
        } else {
          return word;
        }
      }).join(' ');
    }

    var stringTitleize_1 = stringTitleize;

    sugarCore.String.defineInstance({

      'titleize': function(str) {
        return stringTitleize_1(str);
      }

    });

    var titleize = sugarCore.String.titleize;

    sugarCore.String.defineInstance({

      'to': function(str, to) {
        if (isUndefined_1(to)) to = str.length;
        return str.slice(0, numberOrIndex_1(str, to));
      }

    });

    var to = sugarCore.String.to;

    function allCharsReg(src) {
      return RegExp('[' + src + ']', 'g');
    }

    var allCharsReg_1 = allCharsReg;

    var HALF_WIDTH_ZERO = CommonChars.HALF_WIDTH_ZERO,
        FULL_WIDTH_ZERO = CommonChars.FULL_WIDTH_ZERO,
        HALF_WIDTH_PERIOD$2 = CommonChars.HALF_WIDTH_PERIOD,
        FULL_WIDTH_PERIOD = CommonChars.FULL_WIDTH_PERIOD,
        HALF_WIDTH_COMMA = CommonChars.HALF_WIDTH_COMMA;

    var fullWidthNumberReg, fullWidthNumberMap, fullWidthNumbers;

    function buildFullWidthNumber() {
      var fwp = FULL_WIDTH_PERIOD, hwp = HALF_WIDTH_PERIOD$2, hwc = HALF_WIDTH_COMMA, fwn = '';
      fullWidthNumberMap = {};
      for (var i = 0, digit; i <= 9; i++) {
        digit = chr(i + FULL_WIDTH_ZERO);
        fwn += digit;
        fullWidthNumberMap[digit] = chr(i + HALF_WIDTH_ZERO);
      }
      fullWidthNumberMap[hwc] = '';
      fullWidthNumberMap[fwp] = hwp;
      // Mapping this to itself to capture it easily
      // in stringToNumber to detect decimals later.
      fullWidthNumberMap[hwp] = hwp;
      fullWidthNumberReg = allCharsReg_1(fwn + fwp + hwc + hwp);
      fullWidthNumbers = fwn;
    }

    buildFullWidthNumber();

    var fullwidthNumberHelpers = {
      fullWidthNumberReg: fullWidthNumberReg,
      fullWidthNumberMap: fullWidthNumberMap,
      fullWidthNumbers: fullWidthNumbers
    };

    var fullWidthNumberReg$1 = fullwidthNumberHelpers.fullWidthNumberReg,
        fullWidthNumberMap$1 = fullwidthNumberHelpers.fullWidthNumberMap,
        getOwn$1 = coreUtilityAliases.getOwn,
        HALF_WIDTH_PERIOD$3 = CommonChars.HALF_WIDTH_PERIOD;

    function stringToNumber(str, base) {
      var sanitized, isDecimal;
      sanitized = str.replace(fullWidthNumberReg$1, function(chr) {
        var replacement = getOwn$1(fullWidthNumberMap$1, chr);
        if (replacement === HALF_WIDTH_PERIOD$3) {
          isDecimal = true;
        }
        return replacement;
      });
      return isDecimal ? parseFloat(sanitized) : parseInt(sanitized, base || 10);
    }

    var stringToNumber_1 = stringToNumber;

    sugarCore.String.defineInstance({

      'toNumber': function(str, base) {
        return stringToNumber_1(str, base);
      }

    });

    var toNumber = sugarCore.String.toNumber;

    var TRIM_CHARS = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u2028\u2029\u3000\uFEFF';

    var LEFT_TRIM_REG = RegExp('^['+ TRIM_CHARS +']+');

    sugarCore.String.defineInstance({

      'trimLeft': function(str) {
        return str.replace(LEFT_TRIM_REG, '');
      }

    });

    var trimLeft = sugarCore.String.trimLeft;

    var RIGHT_TRIM_REG = RegExp('['+ TRIM_CHARS +']+$');

    sugarCore.String.defineInstance({

      'trimRight': function(str) {
        return str.replace(RIGHT_TRIM_REG, '');
      }

    });

    var trimRight = sugarCore.String.trimRight;

    var TRUNC_REG = RegExp('(?=[' + TRIM_CHARS + '])');

    function filter(arr, fn) {
      var result = [];
      for (var i = 0, len = arr.length; i < len; i++) {
        var el = arr[i];
        if (i in arr && fn(el, i)) {
          result.push(el);
        }
      }
      return result;
    }

    var filter_1 = filter;

    function truncateOnWord(str, limit, fromLeft) {
      if (fromLeft) {
        return reverseString_1(truncateOnWord(reverseString_1(str), limit));
      }
      var words = str.split(TRUNC_REG);
      var count = 0;
      return filter_1(words, function(word) {
        count += word.length;
        return count <= limit;
      }).join('');
    }

    var truncateOnWord_1 = truncateOnWord;

    var ceil$2 = mathAliases.ceil,
        floor$2 = mathAliases.floor;

    function truncateString(str, length, from, ellipsis, split) {
      var str1, str2, len1, len2;
      if (str.length <= length) {
        return str.toString();
      }
      ellipsis = isUndefined_1(ellipsis) ? '...' : ellipsis;
      switch(from) {
        case 'left':
          str2 = split ? truncateOnWord_1(str, length, true) : str.slice(str.length - length);
          return ellipsis + str2;
        case 'middle':
          len1 = ceil$2(length / 2);
          len2 = floor$2(length / 2);
          str1 = split ? truncateOnWord_1(str, len1) : str.slice(0, len1);
          str2 = split ? truncateOnWord_1(str, len2, true) : str.slice(str.length - len2);
          return str1 + ellipsis + str2;
        default:
          str1 = split ? truncateOnWord_1(str, length) : str.slice(0, length);
          return str1 + ellipsis;
      }
    }

    var truncateString_1 = truncateString;

    sugarCore.String.defineInstance({

      'truncate': function(str, length, from, ellipsis) {
        return truncateString_1(str, length, from, ellipsis);
      }

    });

    var truncate = sugarCore.String.truncate;

    sugarCore.String.defineInstance({

      'truncateOnWord': function(str, length, from, ellipsis) {
        return truncateString_1(str, length, from, ellipsis, true);
      }

    });

    var truncateOnWord$1 = sugarCore.String.truncateOnWord;

    sugarCore.String.defineInstance({

      'underscore': function(str) {
        return stringUnderscore_1(str);
      }

    });

    var underscore = sugarCore.String.underscore;

    var HTML_ENTITY_REG = /&#?(x)?([\w\d]{0,5});/gi;

    function unescapeHTML(str) {
      return str.replace(HTML_ENTITY_REG, function(full, hex, code) {
        var special = HTMLFromEntityMap_1[code];
        return special || chr(hex ? parseInt(code, 16) : +code);
      });
    }

    var unescapeHTML_1 = unescapeHTML;

    sugarCore.String.defineInstance({

      'unescapeHTML': function(str) {
        return unescapeHTML_1(str);
      }

    });

    var unescapeHTML_1$1 = sugarCore.String.unescapeHTML;

    sugarCore.String.defineInstance({

      'unescapeURL': function(str, param) {
        return param ? decodeURI(str) : decodeURIComponent(str);
      }

    });

    var unescapeURL = sugarCore.String.unescapeURL;

    sugarCore.String.defineInstance({

      'words': function(str, eachWordFn) {
        return stringEach_1(trim_1(str), /\S+/g, eachWordFn);
      }

    });

    var words = sugarCore.String.words;

    var min = mathAliases.min,
        max$3 = mathAliases.max;

    sugarCore.Number.defineStatic({

      'random': function(n1, n2) {
        var minNum, maxNum;
        if (arguments.length == 1) n2 = n1, n1 = 0;
        minNum = min(n1 || 0, isUndefined_1(n2) ? 1 : n2);
        maxNum = max$3(n1 || 0, isUndefined_1(n2) ? 1 : n2) + 1;
        return trunc_1((Math.random() * (maxNum - minNum)) + minNum);
      }

    });

    var random = sugarCore.Number.random;

    var AbbreviationUnits = {
      BASIC_UNITS: '|kmbt',
      MEMORY_UNITS: '|KMGTPE',
      MEMORY_BINARY_UNITS: '|,Ki,Mi,Gi,Ti,Pi,Ei',
      METRIC_UNITS_SHORT: 'nμm|k',
      METRIC_UNITS_FULL: 'yzafpnμm|KMGTPEZY'
    };

    var HALF_WIDTH_COMMA$1 = CommonChars.HALF_WIDTH_COMMA;

    function commaSplit(str) {
      return str.split(HALF_WIDTH_COMMA$1);
    }

    var commaSplit_1 = commaSplit;

    var abs = mathAliases.abs,
        pow = mathAliases.pow,
        round = mathAliases.round;

    function withPrecision(val, precision, fn) {
      var multiplier = pow(10, abs(precision || 0));
      fn = fn || round;
      if (precision < 0) multiplier = 1 / multiplier;
      return fn(val * multiplier) / multiplier;
    }

    var withPrecision_1 = withPrecision;

    var HALF_WIDTH_PERIOD$4 = CommonChars.HALF_WIDTH_PERIOD,
        HALF_WIDTH_COMMA$2 = CommonChars.HALF_WIDTH_COMMA;

    var NUMBER_OPTIONS = {
      'decimal': HALF_WIDTH_PERIOD$4,
      'thousands': HALF_WIDTH_COMMA$2
    };

    var NUMBER_OPTIONS_1 = NUMBER_OPTIONS;

    var namespaceAliases = {
      sugarObject: sugarCore.Object,
      sugarArray: sugarCore.Array,
      sugarDate: sugarCore.Date,
      sugarString: sugarCore.String,
      sugarNumber: sugarCore.Number,
      sugarFunction: sugarCore.Function,
      sugarRegExp: sugarCore.RegExp
    };

    var forEachProperty$1 = coreUtilityAliases.forEachProperty;

    function simpleMerge(target, source) {
      forEachProperty$1(source, function(val, key) {
        target[key] = val;
      });
      return target;
    }

    var simpleMerge_1 = simpleMerge;

    function simpleClone(obj) {
      return simpleMerge_1({}, obj);
    }

    var simpleClone_1 = simpleClone;

    var setProperty = coreUtilityAliases.setProperty;

    function defineAccessor(namespace, name, fn) {
      setProperty(namespace, name, fn);
    }

    var defineAccessor_1 = defineAccessor;

    var forEachProperty$2 = coreUtilityAliases.forEachProperty;

    function defineOptionsAccessor(namespace, defaults) {
      var obj = simpleClone_1(defaults);

      function getOption(name) {
        return obj[name];
      }

      function setOption(arg1, arg2) {
        var options;
        if (arguments.length === 1) {
          options = arg1;
        } else {
          options = {};
          options[arg1] = arg2;
        }
        forEachProperty$2(options, function(val, name) {
          if (val === null) {
            val = defaults[name];
          }
          obj[name] = val;
        });
      }

      defineAccessor_1(namespace, 'getOption', getOption);
      defineAccessor_1(namespace, 'setOption', setOption);
      return getOption;
    }

    var defineOptionsAccessor_1 = defineOptionsAccessor;

    var sugarNumber = namespaceAliases.sugarNumber;

    var _numberOptions = defineOptionsAccessor_1(sugarNumber, NUMBER_OPTIONS_1);

    var isNumber$2 = classChecks.isNumber,
        max$4 = mathAliases.max;

    function numberFormat(num, place) {
      var result = '', thousands, decimal, fraction, integer, split, str;

      decimal   = _numberOptions('decimal');
      thousands = _numberOptions('thousands');

      if (isNumber$2(place)) {
        str = withPrecision_1(num, place || 0).toFixed(max$4(place, 0));
      } else {
        str = num.toString();
      }

      str = str.replace(/^-/, '');
      split    = periodSplit_1(str);
      integer  = split[0];
      fraction = split[1];
      if (/e/.test(str)) {
        result = str;
      } else {
        for(var i = integer.length; i > 0; i -= 3) {
          if (i < integer.length) {
            result = thousands + result;
          }
          result = integer.slice(max$4(0, i - 3), i) + result;
        }
      }
      if (fraction) {
        result += decimal + repeatString_1('0', (place || 0) - fraction.length) + fraction;
      }
      return (num < 0 ? '-' : '') + result;
    }

    var numberFormat_1 = numberFormat;

    var abs$1 = mathAliases.abs,
        pow$1 = mathAliases.pow,
        min$1 = mathAliases.min,
        max$5 = mathAliases.max,
        floor$3 = mathAliases.floor;

    function abbreviateNumber(num, precision, ustr, bytes) {
      var fixed        = num.toFixed(20),
          decimalPlace = fixed.search(/\./),
          numeralPlace = fixed.search(/[1-9]/),
          significant  = decimalPlace - numeralPlace,
          units, unit, mid, i, divisor;
      if (significant > 0) {
        significant -= 1;
      }
      units = commaSplit_1(ustr);
      if (units.length === 1) {
        units = ustr.split('');
      }
      mid = units.indexOf('|');
      if (mid === -1) {
        // Skipping the placeholder means the units should start from zero,
        // otherwise assume they end at zero.
        mid = units[0] === '_' ? 0 : units.length;
      }
      i = max$5(min$1(floor$3(significant / 3), units.length - mid - 1), -mid);
      unit = units[i + mid];
      while (unit === '_') {
        i += i < 0 ? -1 : 1;
        unit = units[i + mid];
      }
      if (unit === '|') {
        unit = '';
      }
      if (significant < -9) {
        precision = abs$1(significant) - 9;
      }
      divisor = bytes ? pow$1(2, 10 * i) : pow$1(10, i * 3);
      return numberFormat_1(withPrecision_1(num / divisor, precision || 0)) + unit;
    }

    var abbreviateNumber_1 = abbreviateNumber;

    var BASIC_UNITS = AbbreviationUnits.BASIC_UNITS;

    sugarCore.Number.defineInstance({

      'abbr': function(n, precision) {
        return abbreviateNumber_1(n, precision, BASIC_UNITS);
      }

    });

    var abbr = sugarCore.Number.abbr;

    function wrapNamespace(method) {
      return function(sugarNamespace, arg1, arg2) {
        sugarNamespace[method](arg1, arg2);
      };
    }

    var wrapNamespace_1 = wrapNamespace;

    var methodDefineAliases = {
      alias: wrapNamespace_1('alias'),
      defineStatic: wrapNamespace_1('defineStatic'),
      defineInstance: wrapNamespace_1('defineInstance'),
      defineStaticPolyfill: wrapNamespace_1('defineStaticPolyfill'),
      defineInstancePolyfill: wrapNamespace_1('defineInstancePolyfill'),
      defineInstanceAndStatic: wrapNamespace_1('defineInstanceAndStatic'),
      defineInstanceWithArguments: wrapNamespace_1('defineInstanceWithArguments')
    };

    var isString$8 = classChecks.isString;

    function collectSimilarMethods(set, fn) {
      var methods = {};
      if (isString$8(set)) {
        set = spaceSplit_1(set);
      }
      forEach_1(set, function(el, i) {
        fn(methods, el, i);
      });
      return methods;
    }

    var collectSimilarMethods_1 = collectSimilarMethods;

    var defineInstance = methodDefineAliases.defineInstance;

    function defineInstanceSimilar(sugarNamespace, set, fn, flags) {
      defineInstance(sugarNamespace, collectSimilarMethods_1(set, fn), flags);
    }

    var defineInstanceSimilar_1 = defineInstanceSimilar;

    var sugarNumber$1 = namespaceAliases.sugarNumber;

    function buildMathAliases() {
      defineInstanceSimilar_1(sugarNumber$1, 'abs pow sin asin cos acos tan atan exp pow sqrt', function(methods, name) {
        methods[name] = function(n, arg) {
          // Note that .valueOf() here is only required due to a
          // very strange bug in iOS7 that only occurs occasionally
          // in which Math.abs() called on non-primitive numbers
          // returns a completely different number (Issue #400)
          return Math[name](n.valueOf(), arg);
        };
      });
    }

    var buildMathAliases_1 = buildMathAliases;

    buildMathAliases_1();

    var abs$2 = sugarCore.Number.abs;

    var acos = sugarCore.Number.acos;

    var asin = sugarCore.Number.asin;

    var atan = sugarCore.Number.atan;

    var MEMORY_UNITS = AbbreviationUnits.MEMORY_UNITS,
        MEMORY_BINARY_UNITS = AbbreviationUnits.MEMORY_BINARY_UNITS;

    sugarCore.Number.defineInstance({

      'bytes': function(n, precision, binary, units) {
        if (units === 'binary' || (!units && binary)) {
          units = MEMORY_BINARY_UNITS;
        } else if(units === 'si' || !units) {
          units = MEMORY_UNITS;
        }
        return abbreviateNumber_1(n, precision, units, binary) + 'B';
      }

    });

    var bytes = sugarCore.Number.bytes;

    function createRoundingFunction(fn) {
      return function(n, precision) {
        return precision ? withPrecision_1(n, precision, fn) : fn(n);
      };
    }

    var createRoundingFunction_1 = createRoundingFunction;

    var ceil$3 = mathAliases.ceil;

    sugarCore.Number.defineInstance({

      'ceil': createRoundingFunction_1(ceil$3)

    });

    var ceil_1 = sugarCore.Number.ceil;

    sugarCore.Number.defineInstance({

      'chr': function(n) {
        return chr(n);
      }

    });

    var chr_1 = sugarCore.Number.chr;

    var cos = sugarCore.Number.cos;

    var exp = sugarCore.Number.exp;

    var floor$4 = mathAliases.floor;

    sugarCore.Number.defineInstance({

      'floor': createRoundingFunction_1(floor$4)

    });

    var floor_1 = sugarCore.Number.floor;

    sugarCore.Number.defineInstance({

      'format': function(n, place) {
        return numberFormat_1(n, place);
      }

    });

    var format$2 = sugarCore.Number.format;

    var abs$3 = mathAliases.abs;

    function padNumber(num, place, sign, base, replacement) {
      var str = abs$3(num).toString(base || 10);
      str = repeatString_1(replacement || '0', place - str.replace(/\.\d+/, '').length) + str;
      if (sign || num < 0) {
        str = (num < 0 ? '-' : '+') + str;
      }
      return str;
    }

    var padNumber_1 = padNumber;

    sugarCore.Number.defineInstance({

      'hex': function(n, pad) {
        return padNumber_1(n, pad || 1, false, 16);
      }

    });

    var hex = sugarCore.Number.hex;

    function isMultipleOf(n1, n2) {
      return n1 % n2 === 0;
    }

    var isMultipleOf_1 = isMultipleOf;

    sugarCore.Number.defineInstance({

      'isEven': function(n) {
        return isMultipleOf_1(n, 2);
      }

    });

    var isEven = sugarCore.Number.isEven;

    function isInteger(n) {
      return n % 1 === 0;
    }

    var isInteger_1 = isInteger;

    sugarCore.Number.defineInstance({

      'isInteger': function(n) {
        return isInteger_1(n);
      }

    });

    var isInteger_1$1 = sugarCore.Number.isInteger;

    sugarCore.Number.defineInstance({

      'isMultipleOf': function(n, num) {
        return isMultipleOf_1(n, num);
      }

    });

    var isMultipleOf_1$1 = sugarCore.Number.isMultipleOf;

    sugarCore.Number.defineInstance({

      'isOdd': function(n) {
        return isInteger_1(n) && !isMultipleOf_1(n, 2);
      }

    });

    var isOdd = sugarCore.Number.isOdd;

    sugarCore.Number.defineInstance({

      'log': function(n, base) {
        return Math.log(n) / (base ? Math.log(base) : 1);
      }

    });

    var log = sugarCore.Number.log;

    var METRIC_UNITS_SHORT = AbbreviationUnits.METRIC_UNITS_SHORT,
        METRIC_UNITS_FULL = AbbreviationUnits.METRIC_UNITS_FULL;

    sugarCore.Number.defineInstance({

      'metric': function(n, precision, units) {
        if (units === 'all') {
          units = METRIC_UNITS_FULL;
        } else if (!units) {
          units = METRIC_UNITS_SHORT;
        }
        return abbreviateNumber_1(n, precision, units);
      }

    });

    var metric = sugarCore.Number.metric;

    function getOrdinalSuffix(num) {
      if (num >= 11 && num <= 13) {
        return 'th';
      } else {
        switch(num % 10) {
          case 1:  return 'st';
          case 2:  return 'nd';
          case 3:  return 'rd';
          default: return 'th';
        }
      }
    }

    var getOrdinalSuffix_1 = getOrdinalSuffix;

    var abs$4 = mathAliases.abs;

    sugarCore.Number.defineInstance({

      'ordinalize': function(n) {
        var num = abs$4(n), last = +num.toString().slice(-2);
        return n + getOrdinalSuffix_1(last);
      }

    });

    var ordinalize = sugarCore.Number.ordinalize;

    sugarCore.Number.defineInstance({

      'pad': function(n, place, sign, base) {
        return padNumber_1(n, place, sign, base);
      }

    });

    var pad$1 = sugarCore.Number.pad;

    var pow$2 = sugarCore.Number.pow;

    var round$1 = mathAliases.round;

    sugarCore.Number.defineInstance({

      'round': createRoundingFunction_1(round$1)

    });

    var round_1 = sugarCore.Number.round;

    var sin = sugarCore.Number.sin;

    var sqrt = sugarCore.Number.sqrt;

    var tan = sugarCore.Number.tan;

    sugarCore.Number.defineInstance({

      'times': function(n, indexMapFn) {
        var arr, result;
        for(var i = 0; i < n; i++) {
          result = indexMapFn.call(n, i);
          if (isDefined_1(result)) {
            if (!arr) {
              arr = [];
            }
            arr.push(result);
          }
        }
        return arr;
      }

    });

    var times = sugarCore.Number.times;

    sugarCore.Number.defineInstance({

      'toNumber': function(n) {
        return n.valueOf();
      }

    });

    var toNumber$1 = sugarCore.Number.toNumber;

    var getOption = sugarCore.Number.getOption;

    var setOption = sugarCore.Number.setOption;

    sugarCore.Array.defineStatic({

      'construct': function(n, indexMapFn) {
        n = coercePositiveInteger_1(n);
        return Array.from(new Array(n), function(el, i) {
          return indexMapFn && indexMapFn(i);
        });
      }

    });

    var construct = sugarCore.Array.construct;

    function arrayClone(arr) {
      var clone = new Array(arr.length);
      forEach_1(arr, function(el, i) {
        clone[i] = el;
      });
      return clone;
    }

    var arrayClone_1 = arrayClone;

    var isArray$3 = classChecks.isArray;

    function isArrayOrInherited(obj) {
      return obj && obj.constructor && isArray$3(obj.constructor.prototype);
    }

    var isArrayOrInherited_1 = isArrayOrInherited;

    var isString$9 = classChecks.isString;

    function arrayCreate(obj, clone) {
      var arr;
      if (isArrayOrInherited_1(obj)) {
        arr = clone ? arrayClone_1(obj) : obj;
      } else if (isObjectType_1(obj) || isString$9(obj)) {
        arr = Array.from(obj);
      } else if (isDefined_1(obj)) {
        arr = [obj];
      }
      return arr || [];
    }

    var arrayCreate_1 = arrayCreate;

    function setChainableConstructor(sugarNamespace, createFn) {
      sugarNamespace.prototype.constructor = function() {
        return createFn.apply(this, arguments);
      };
    }

    var setChainableConstructor_1 = setChainableConstructor;

    var sugarArray = namespaceAliases.sugarArray;

    function setArrayChainableConstructor() {
      setChainableConstructor_1(sugarArray, arrayCreate_1);
    }

    var setArrayChainableConstructor_1 = setArrayChainableConstructor;

    setArrayChainableConstructor_1();

    sugarCore.Array.defineStatic({

      'create': function(obj, clone) {
        return arrayCreate_1(obj, clone);
      }

    });

    var create = sugarCore.Array.create;

    function arrayAppend(arr, el, index) {
      var spliceArgs;
      index = +index;
      if (isNaN(index)) {
        index = arr.length;
      }
      spliceArgs = [index, 0];
      if (isDefined_1(el)) {
        spliceArgs = spliceArgs.concat(el);
      }
      arr.splice.apply(arr, spliceArgs);
      return arr;
    }

    var arrayAppend_1 = arrayAppend;

    sugarCore.Array.defineInstance({

      'add': function(arr, item, index) {
        return arrayAppend_1(arrayClone_1(arr), item, index);
      }

    });

    var add = sugarCore.Array.add;

    sugarCore.Array.defineInstance({

      'append': function(arr, item, index) {
        return arrayAppend_1(arr, item, index);
      }

    });

    var append$1 = sugarCore.Array.append;

    sugarCore.Array.defineInstance({

      'at': function(arr, index, loop) {
        return getEntriesForIndexes_1(arr, index, loop);
      }

    });

    var at$1 = sugarCore.Array.at;

    sugarCore.Array.defineInstance({

      'clone': function(arr) {
        return arrayClone_1(arr);
      }

    });

    var clone = sugarCore.Array.clone;

    function arrayCompact(arr, all) {
      return filter_1(arr, function(el) {
        return el || (!all && el != null && el.valueOf() === el.valueOf());
      });
    }

    var arrayCompact_1 = arrayCompact;

    sugarCore.Array.defineInstance({

      'compact': function(arr, all) {
        return arrayCompact_1(arr, all);
      }

    });

    var compact$1 = sugarCore.Array.compact;

    function dateMatcher(d) {
      var ms = d.getTime();
      return function(el) {
        return !!(el && el.getTime) && el.getTime() === ms;
      };
    }

    var dateMatcher_1 = dateMatcher;

    function regexMatcher(reg) {
      reg = RegExp(reg);
      return function(el) {
        return reg.test(el);
      };
    }

    var regexMatcher_1 = regexMatcher;

    function getKeys(obj) {
      return Object.keys(obj);
    }

    var getKeys_1 = getKeys;

    function setToArray(set) {
      var arr = new Array(set.size), i = 0;
      set.forEach(function(val) {
        arr[i++] = val;
      });
      return arr;
    }

    var setToArray_1 = setToArray;

    function mapToArray(map) {
      var arr = new Array(map.size), i = 0;
      map.forEach(function(val, key) {
        arr[i++] = [key, val];
      });
      return arr;
    }

    var mapToArray_1 = mapToArray;

    var forEachProperty$3 = coreUtilityAliases.forEachProperty;

    function iterateWithCyclicCheck(obj, sortedKeys, stack, fn) {

      function next(val, key) {
        var cyc = false;

        // Allowing a step into the structure before triggering this check to save
        // cycles on standard JSON structures and also to try as hard as possible to
        // catch basic properties that may have been modified.
        if (stack.length > 1) {
          var i = stack.length;
          while (i--) {
            if (stack[i] === val) {
              cyc = true;
            }
          }
        }

        stack.push(val);
        fn(key, val, cyc, stack);
        stack.pop();
      }

      function iterateWithSortedKeys() {
        // Sorted keys is required for serialization, where object order
        // does not matter but stringified order does.
        var arr = getKeys_1(obj).sort(), key;
        for (var i = 0; i < arr.length; i++) {
          key = arr[i];
          next(obj[key], arr[i]);
        }
      }

      // This method for checking for cyclic structures was egregiously stolen from
      // the ingenious method by @kitcambridge from the Underscore script:
      // https://github.com/documentcloud/underscore/issues/240
      if (!stack) {
        stack = [];
      }

      if (sortedKeys) {
        iterateWithSortedKeys();
      } else {
        forEachProperty$3(obj, next);
      }
    }

    var iterateWithCyclicCheck_1 = iterateWithCyclicCheck;

    var classToString$1 = coreUtilityAliases.classToString,
        isSerializable$1 = classChecks.isSerializable,
        isSet$1 = classChecks.isSet,
        isMap$1 = classChecks.isMap,
        isError$1 = classChecks.isError;

    function isEqual(a, b, stack) {
      var aClass, bClass;
      if (a === b) {
        // Return quickly up front when matched by reference,
        // but be careful about 0 !== -0.
        return a !== 0 || 1 / a === 1 / b;
      }
      aClass = classToString$1(a);
      bClass = classToString$1(b);
      if (aClass !== bClass) {
        return false;
      }

      if (isSerializable$1(a, aClass) && isSerializable$1(b, bClass)) {
        return objectIsEqual(a, b, aClass, stack);
      } else if (isSet$1(a, aClass) && isSet$1(b, bClass)) {
        return a.size === b.size && isEqual(setToArray_1(a), setToArray_1(b), stack);
      } else if (isMap$1(a, aClass) && isMap$1(b, bClass)) {
        return a.size === b.size && isEqual(mapToArray_1(a), mapToArray_1(b), stack);
      } else if (isError$1(a, aClass) && isError$1(b, bClass)) {
        return a.toString() === b.toString();
      }

      return false;
    }

    function objectIsEqual(a, b, aClass, stack) {
      var aType = typeof a, bType = typeof b, propsEqual, count;
      if (aType !== bType) {
        return false;
      }
      if (isObjectType_1(a.valueOf())) {
        if (a.length !== b.length) {
          // perf: Quickly returning up front for arrays.
          return false;
        }
        count = 0;
        propsEqual = true;
        iterateWithCyclicCheck_1(a, false, stack, function(key, val, cyc, stack) {
          if (!cyc && (!(key in b) || !isEqual(val, b[key], stack))) {
            propsEqual = false;
          }
          count++;
          return propsEqual;
        });
        if (!propsEqual || count !== getKeys_1(b).length) {
          return false;
        }
      }
      // Stringifying the value handles NaN, wrapped primitives, dates, and errors in one go.
      return a.valueOf().toString() === b.valueOf().toString();
    }

    var isEqual_1 = isEqual;

    function defaultMatcher(f) {
      return function(el) {
        return isEqual_1(el, f);
      };
    }

    var defaultMatcher_1 = defaultMatcher;

    function functionMatcher(fn) {
      return function(el, i, arr) {
        // Return true up front if match by reference
        return el === fn || fn.call(arr, el, i, arr);
      };
    }

    var functionMatcher_1 = functionMatcher;

    var getOwn$2 = coreUtilityAliases.getOwn,
        classToString$2 = coreUtilityAliases.classToString,
        forEachProperty$4 = coreUtilityAliases.forEachProperty,
        isDate$1 = classChecks.isDate,
        isRegExp$3 = classChecks.isRegExp,
        isFunction$2 = classChecks.isFunction;

    function getMatcher(f) {
      if (!isPrimitive_1(f)) {
        var className = classToString$2(f);
        if (isRegExp$3(f, className)) {
          return regexMatcher_1(f);
        } else if (isDate$1(f, className)) {
          return dateMatcher_1(f);
        } else if (isFunction$2(f, className)) {
          return functionMatcher_1(f);
        } else if (isPlainObject_1(f, className)) {
          return fuzzyMatcher(f);
        }
      }
      // Default is standard isEqual
      return defaultMatcher_1(f);
    }

    function fuzzyMatcher(obj) {
      var matchers = {};
      return function(el, i, arr) {
        var matched = true;
        if (!isObjectType_1(el)) {
          return false;
        }
        forEachProperty$4(obj, function(val, key) {
          matchers[key] = getOwn$2(matchers, key) || getMatcher(val);
          if (matchers[key].call(arr, el[key], i, arr) === false) {
            matched = false;
          }
          return matched;
        });
        return matched;
      };
    }

    var getMatcher_1 = getMatcher;

    function arrayExclude(arr, f) {
      var result = [], matcher = getMatcher_1(f);
      for (var i = 0; i < arr.length; i++) {
        if (!matcher(arr[i], i, arr)) {
          result.push(arr[i]);
        }
      }
      return result;
    }

    var arrayExclude_1 = arrayExclude;

    sugarCore.Array.defineInstance({

      'exclude': function(arr, f) {
        return arrayExclude_1(arr, f);
      }

    });

    var exclude = sugarCore.Array.exclude;

    sugarCore.Array.defineInstance({

      'first': function(arr, num) {
        if (isUndefined_1(num)) return arr[0];
        if (num < 0) num = 0;
        return arr.slice(0, num);
      }

    });

    var first$1 = sugarCore.Array.first;

    var isArray$4 = classChecks.isArray;

    function arrayFlatten(arr, level, current) {
      var result = [];
      level = level || Infinity;
      current = current || 0;
      forEach_1(arr, function(el) {
        if (isArray$4(el) && current < level) {
          result = result.concat(arrayFlatten(el, level, current + 1));
        } else {
          result.push(el);
        }
      });
      return result;
    }

    var arrayFlatten_1 = arrayFlatten;

    sugarCore.Array.defineInstance({

      'flatten': function(arr, limit) {
        return arrayFlatten_1(arr, limit);
      }

    });

    var flatten = sugarCore.Array.flatten;

    sugarCore.Array.defineInstance({

      'from': function(arr, num) {
        return arr.slice(num);
      }

    });

    var from_1$1 = sugarCore.Array.from;

    var isFunction$3 = classChecks.isFunction,
        isArray$5 = classChecks.isArray;

    function mapWithShortcuts(el, f, context, mapArgs) {
      if (!f) {
        return el;
      } else if (f.apply) {
        return f.apply(context, mapArgs);
      } else if (isArray$5(f)) {
        return map_1(f, function(m) {
          return mapWithShortcuts(el, m, context, mapArgs);
        });
      } else if (isFunction$3(el[f])) {
        return el[f].call(el);
      } else {
        return deepGetProperty_1(el, f, true);
      }
    }

    var mapWithShortcuts_1 = mapWithShortcuts;

    var hasOwn$4 = coreUtilityAliases.hasOwn,
        forEachProperty$5 = coreUtilityAliases.forEachProperty;

    function arrayGroupBy(arr, map, fn) {
      var result = {}, key;
      forEach_1(arr, function(el, i) {
        key = mapWithShortcuts_1(el, map, arr, [el, i, arr]);
        if (!hasOwn$4(result, key)) {
          result[key] = [];
        }
        result[key].push(el);
      });
      if (fn) {
        forEachProperty$5(result, fn);
      }
      return result;
    }

    var arrayGroupBy_1 = arrayGroupBy;

    sugarCore.Array.defineInstance({

      'groupBy': function(arr, map, groupFn) {
        return arrayGroupBy_1(arr, map, groupFn);
      }

    });

    var groupBy = sugarCore.Array.groupBy;

    function simpleRepeat(n, fn) {
      for (var i = 0; i < n; i++) {
        fn(i);
      }
    }

    var simpleRepeat_1 = simpleRepeat;

    var ceil$4 = mathAliases.ceil;

    sugarCore.Array.defineInstance({

      'inGroups': function(arr, num, padding) {
        var pad = isDefined_1(padding);
        var result = new Array(num);
        var divisor = ceil$4(arr.length / num);
        simpleRepeat_1(num, function(i) {
          var index = i * divisor;
          var group = arr.slice(index, index + divisor);
          if (pad && group.length < divisor) {
            simpleRepeat_1(divisor - group.length, function() {
              group.push(padding);
            });
          }
          result[i] = group;
        });
        return result;
      }

    });

    var inGroups = sugarCore.Array.inGroups;

    var ceil$5 = mathAliases.ceil;

    sugarCore.Array.defineInstance({

      'inGroupsOf': function(arr, num, padding) {
        var result = [], len = arr.length, group;
        if (len === 0 || num === 0) return arr;
        if (isUndefined_1(num)) num = 1;
        if (isUndefined_1(padding)) padding = null;
        simpleRepeat_1(ceil$5(len / num), function(i) {
          group = arr.slice(num * i, num * i + num);
          while(group.length < num) {
            group.push(padding);
          }
          result.push(group);
        });
        return result;
      }

    });

    var inGroupsOf = sugarCore.Array.inGroupsOf;

    function arrayWrap(obj) {
      var arr = [];
      arr.push(obj);
      return arr;
    }

    var arrayWrap_1 = arrayWrap;

    function isRealNaN(obj) {
      // This is only true of NaN
      return obj != null && obj !== obj;
    }

    var isRealNaN_1 = isRealNaN;

    var classToString$3 = coreUtilityAliases.classToString,
        isSerializable$2 = classChecks.isSerializable;

    function serializeInternal(obj, refs, stack) {
      var type = typeof obj, sign = '', className, value, ref;

      // Return up front on
      if (1 / obj === -Infinity) {
        sign = '-';
      }

      // Return quickly for primitives to save cycles
      if (isPrimitive_1(obj, type) && !isRealNaN_1(obj)) {
        return type + sign + obj;
      }

      className = classToString$3(obj);

      if (!isSerializable$2(obj, className)) {
        ref = indexOf_1(refs, obj);
        if (ref === -1) {
          ref = refs.length;
          refs.push(obj);
        }
        return ref;
      } else if (isObjectType_1(obj)) {
        value = serializeDeep(obj, refs, stack) + obj.toString();
      } else if (obj.valueOf) {
        value = obj.valueOf();
      }
      return type + className + sign + value;
    }

    function serializeDeep(obj, refs, stack) {
      var result = '';
      iterateWithCyclicCheck_1(obj, true, stack, function(key, val, cyc, stack) {
        result += cyc ? 'CYC' : key + serializeInternal(val, refs, stack);
      });
      return result;
    }

    var serializeInternal_1 = serializeInternal;

    var isArray$6 = classChecks.isArray,
        hasOwn$5 = coreUtilityAliases.hasOwn;

    function arrayIntersectOrSubtract(arr1, arr2, subtract) {
      var result = [], obj = {}, refs = [];
      if (!isArray$6(arr2)) {
        arr2 = arrayWrap_1(arr2);
      }
      forEach_1(arr2, function(el) {
        obj[serializeInternal_1(el, refs)] = true;
      });
      forEach_1(arr1, function(el) {
        var key = serializeInternal_1(el, refs);
        if (hasOwn$5(obj, key) !== subtract) {
          delete obj[key];
          result.push(el);
        }
      });
      return result;
    }

    var arrayIntersectOrSubtract_1 = arrayIntersectOrSubtract;

    sugarCore.Array.defineInstance({

      'intersect': function(arr1, arr2) {
        return arrayIntersectOrSubtract_1(arr1, arr2, false);
      }

    });

    var intersect = sugarCore.Array.intersect;

    sugarCore.Array.defineInstance({

      'isEmpty': function(arr) {
        return arr.length === 0;
      }

    });

    var isEmpty$1 = sugarCore.Array.isEmpty;

    sugarCore.Array.defineInstance({

      'isEqual': function(a, b) {
        return isEqual_1(a, b);
      }

    });

    var isEqual_1$1 = sugarCore.Array.isEqual;

    sugarCore.Array.defineInstance({

      'last': function(arr, num) {
        if (isUndefined_1(num)) return arr[arr.length - 1];
        var start = arr.length - num < 0 ? 0 : arr.length - num;
        return arr.slice(start);
      }

    });

    var last$1 = sugarCore.Array.last;

    function arrayRemove(arr, f) {
      var matcher = getMatcher_1(f), i = 0;
      while(i < arr.length) {
        if (matcher(arr[i], i, arr)) {
          arr.splice(i, 1);
        } else {
          i++;
        }
      }
      return arr;
    }

    var arrayRemove_1 = arrayRemove;

    sugarCore.Array.defineInstance({

      'remove': function(arr, f) {
        return arrayRemove_1(arr, f);
      }

    });

    var remove$1 = sugarCore.Array.remove;

    sugarCore.Array.defineInstance({

      'removeAt': function(arr, start, end) {
        if (isUndefined_1(start)) return arr;
        if (isUndefined_1(end))   end = start;
        arr.splice(start, end - start + 1);
        return arr;
      }

    });

    var removeAt = sugarCore.Array.removeAt;

    var isBoolean$1 = classChecks.isBoolean,
        min$2 = mathAliases.min;

    sugarCore.Array.defineInstance({

      'sample': function(arr, arg1, arg2) {
        var result = [], num, remove, single;
        if (isBoolean$1(arg1)) {
          remove = arg1;
        } else {
          num = arg1;
          remove = arg2;
        }
        if (isUndefined_1(num)) {
          num = 1;
          single = true;
        }
        if (!remove) {
          arr = arrayClone_1(arr);
        }
        num = min$2(num, arr.length);
        for (var i = 0, index; i < num; i++) {
          index = trunc_1(Math.random() * arr.length);
          result.push(arr[index]);
          arr.splice(index, 1);
        }
        return single ? result[0] : result;
      }

    });

    var sample = sugarCore.Array.sample;

    function arrayShuffle(arr) {
      arr = arrayClone_1(arr);
      var i = arr.length, j, x;
      while(i) {
        j = (Math.random() * i) | 0;
        x = arr[--i];
        arr[i] = arr[j];
        arr[j] = x;
      }
      return arr;
    }

    var arrayShuffle_1 = arrayShuffle;

    sugarCore.Array.defineInstance({

      'shuffle': function(arr) {
        return arrayShuffle_1(arr);
      }

    });

    var shuffle = sugarCore.Array.shuffle;

    function getSortOrder() {
      var order = 'AÁÀÂÃĄBCĆČÇDĎÐEÉÈĚÊËĘFGĞHıIÍÌİÎÏJKLŁMNŃŇÑOÓÒÔPQRŘSŚŠŞTŤUÚÙŮÛÜVWXYÝZŹŻŽÞÆŒØÕÅÄÖ';
      return map_1(order.split(''), function(str) {
        return str + str.toLowerCase();
      }).join('');
    }

    var getSortOrder_1 = getSortOrder;

    var HALF_WIDTH_NINE = 0x39;

    var FULL_WIDTH_NINE = 0xff19;

    var HALF_WIDTH_ZERO$1 = CommonChars.HALF_WIDTH_ZERO,
        FULL_WIDTH_ZERO$1 = CommonChars.FULL_WIDTH_ZERO;

    function codeIsNumeral(code) {
      return (code >= HALF_WIDTH_ZERO$1 && code <= HALF_WIDTH_NINE) ||
             (code >= FULL_WIDTH_ZERO$1 && code <= FULL_WIDTH_NINE);
    }

    var codeIsNumeral_1 = codeIsNumeral;

    function getSortOrderIndex(chr, sortOrder) {
      if (!chr) {
        return null;
      } else {
        return sortOrder.indexOf(chr);
      }
    }

    var getSortOrderIndex_1 = getSortOrderIndex;

    function getSortEquivalents() {
      var equivalents = {};
      forEach_1(spaceSplit_1('AÁÀÂÃÄ CÇ EÉÈÊË IÍÌİÎÏ OÓÒÔÕÖ Sß UÚÙÛÜ'), function(set) {
        var first = set.charAt(0);
        forEach_1(set.slice(1).split(''), function(chr) {
          equivalents[chr] = first;
          equivalents[chr.toLowerCase()] = first.toLowerCase();
        });
      });
      return equivalents;
    }

    var getSortEquivalents_1 = getSortEquivalents;

    var getOwn$3 = coreUtilityAliases.getOwn;

    function getCollationCharacter(str, index, sortEquivalents) {
      var chr = str.charAt(index);
      return getOwn$3(sortEquivalents, chr) || chr;
    }

    var getCollationCharacter_1 = getCollationCharacter;

    function getCollationReadyString(str, sortIgnore, sortIgnoreCase) {
      if (sortIgnoreCase) {
        str = str.toLowerCase();
      }
      if (sortIgnore) {
        str = str.replace(sortIgnore, '');
      }
      return str;
    }

    var getCollationReadyString_1 = getCollationReadyString;

    var sugarArray$1 = namespaceAliases.sugarArray;

    var ARRAY_OPTIONS = {
      'sortIgnore':      null,
      'sortNatural':     true,
      'sortIgnoreCase':  true,
      'sortOrder':       getSortOrder_1(),
      'sortCollate':     collateStrings,
      'sortEquivalents': getSortEquivalents_1()
    };

    var _arrayOptions = defineOptionsAccessor_1(sugarArray$1, ARRAY_OPTIONS);

    function collateStrings(a, b) {
      var aValue, bValue, aChar, bChar, aEquiv, bEquiv, index = 0, tiebreaker = 0;

      var sortOrder       = _arrayOptions('sortOrder');
      var sortIgnore      = _arrayOptions('sortIgnore');
      var sortNatural     = _arrayOptions('sortNatural');
      var sortIgnoreCase  = _arrayOptions('sortIgnoreCase');
      var sortEquivalents = _arrayOptions('sortEquivalents');

      a = getCollationReadyString_1(a, sortIgnore, sortIgnoreCase);
      b = getCollationReadyString_1(b, sortIgnore, sortIgnoreCase);

      do {

        aChar  = getCollationCharacter_1(a, index, sortEquivalents);
        bChar  = getCollationCharacter_1(b, index, sortEquivalents);
        aValue = getSortOrderIndex_1(aChar, sortOrder);
        bValue = getSortOrderIndex_1(bChar, sortOrder);

        if (aValue === -1 || bValue === -1) {
          aValue = a.charCodeAt(index) || null;
          bValue = b.charCodeAt(index) || null;
          if (sortNatural && codeIsNumeral_1(aValue) && codeIsNumeral_1(bValue)) {
            aValue = stringToNumber_1(a.slice(index));
            bValue = stringToNumber_1(b.slice(index));
          }
        } else {
          aEquiv = aChar !== a.charAt(index);
          bEquiv = bChar !== b.charAt(index);
          if (aEquiv !== bEquiv && tiebreaker === 0) {
            tiebreaker = aEquiv - bEquiv;
          }
        }
        index += 1;
      } while(aValue != null && bValue != null && aValue === bValue);
      if (aValue === bValue) return tiebreaker;
      return aValue - bValue;
    }

    var ARRAY_OPTIONS_1 = {
      ARRAY_OPTIONS: ARRAY_OPTIONS,
      _arrayOptions: _arrayOptions
    };

    var isString$a = classChecks.isString,
        isArray$7 = classChecks.isArray,
        _arrayOptions$1 = ARRAY_OPTIONS_1._arrayOptions;

    function compareValue(aVal, bVal) {
      var cmp, i, collate;
      if (isString$a(aVal) && isString$a(bVal)) {
        collate = _arrayOptions$1('sortCollate');
        return collate(aVal, bVal);
      } else if (isArray$7(aVal) && isArray$7(bVal)) {
        if (aVal.length < bVal.length) {
          return -1;
        } else if (aVal.length > bVal.length) {
          return 1;
        } else {
          for(i = 0; i < aVal.length; i++) {
            cmp = compareValue(aVal[i], bVal[i]);
            if (cmp !== 0) {
              return cmp;
            }
          }
          return 0;
        }
      }
      return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
    }

    var compareValue_1 = compareValue;

    sugarCore.Array.defineInstance({

      'sortBy': function(arr, map, desc) {
        arr.sort(function(a, b) {
          var aProperty = mapWithShortcuts_1(a, map, arr, [a]);
          var bProperty = mapWithShortcuts_1(b, map, arr, [b]);
          return compareValue_1(aProperty, bProperty) * (desc ? -1 : 1);
        });
        return arr;
      }

    });

    var sortBy = sugarCore.Array.sortBy;

    sugarCore.Array.defineInstance({

      'subtract': function(arr, item) {
        return arrayIntersectOrSubtract_1(arr, item, true);
      }

    });

    var subtract = sugarCore.Array.subtract;

    sugarCore.Array.defineInstance({

      'to': function(arr, num) {
        if (isUndefined_1(num)) num = arr.length;
        return arr.slice(0, num);
      }

    });

    var to$1 = sugarCore.Array.to;

    var hasOwn$6 = coreUtilityAliases.hasOwn;

    function arrayUnique(arr, map) {
      var result = [], obj = {}, refs = [];
      forEach_1(arr, function(el, i) {
        var transformed = map ? mapWithShortcuts_1(el, map, arr, [el, i, arr]) : el;
        var key = serializeInternal_1(transformed, refs);
        if (!hasOwn$6(obj, key)) {
          result.push(el);
          obj[key] = true;
        }
      });
      return result;
    }

    var arrayUnique_1 = arrayUnique;

    var HAS_CONCAT_BUG = !('0' in [].concat(undefined).concat());

    var isArray$8 = classChecks.isArray;

    function arraySafeConcat(arr, arg) {
      var result = arrayClone_1(arr), len = result.length, arr2;
      arr2 = isArray$8(arg) ? arg : [arg];
      result.length += arr2.length;
      forEach_1(arr2, function(el, i) {
        result[len + i] = el;
      });
      return result;
    }

    var arraySafeConcat_1 = arraySafeConcat;

    function arrayConcat(arr1, arr2) {
      // istanbul ignore if
      if (HAS_CONCAT_BUG) {
        return arraySafeConcat_1(arr1, arr2);
      }
      return arr1.concat(arr2);
    }

    var arrayConcat_1 = arrayConcat;

    sugarCore.Array.defineInstance({

      'union': function(arr1, arr2) {
        return arrayUnique_1(arrayConcat_1(arr1, arr2));
      }

    });

    var union = sugarCore.Array.union;

    sugarCore.Array.defineInstance({

      'unique': function(arr, map) {
        return arrayUnique_1(arr, map);
      }

    });

    var unique$1 = sugarCore.Array.unique;

    sugarCore.Array.defineInstanceWithArguments({

      'zip': function(arr, args) {
        return map_1(arr, function(el, i) {
          return [el].concat(map_1(args, function(k) {
            return (i in k) ? k[i] : null;
          }));
        });
      }

    });

    var zip = sugarCore.Array.zip;

    sugarCore.Array.alias('insert', 'append');

    var insert$2 = sugarCore.Array.insert;

    var getOption$1 = sugarCore.Array.getOption;

    var setOption$1 = sugarCore.Array.setOption;

    var isArray$9 = classChecks.isArray,
        forEachProperty$6 = coreUtilityAliases.forEachProperty;

    function enumerateWithMapping(obj, map, fn) {
      var arrayIndexes = isArray$9(obj);
      forEachProperty$6(obj, function(val, key) {
        if (arrayIndexes) {
          if (!isArrayIndex_1(key)) {
            return;
          }
          key = +key;
        }
        var mapped = mapWithShortcuts_1(val, map, obj, [val, key, obj]);
        fn(mapped, key);
      });
    }

    var enumerateWithMapping_1 = enumerateWithMapping;

    function average(obj, map) {
      var sum = 0, count = 0;
      enumerateWithMapping_1(obj, map, function(val) {
        sum += val;
        count++;
      });
      // Prevent divide by 0
      return sum / (count || 1);
    }

    var average_1 = average;

    sugarCore.Object.defineInstanceAndStatic({

      'average': function(obj, map) {
        return average_1(obj, map);
      }

    });

    var average_1$1 = sugarCore.Object.average;

    var forEachProperty$7 = coreUtilityAliases.forEachProperty;

    function objectCount(obj, f) {
      var matcher = getMatcher_1(f), count = 0;
      forEachProperty$7(obj, function(val, key) {
        if (matcher(val, key, obj)) {
          count++;
        }
      });
      return count;
    }

    var objectCount_1 = objectCount;

    sugarCore.Object.defineInstanceAndStatic({

      'count': function(obj, f) {
        return objectCount_1(obj, f);
      }

    });

    var count = sugarCore.Object.count;

    function wrapObjectMatcher(name) {
      var nativeFn = Array.prototype[name];
      return function(obj, f) {
        var matcher = getMatcher_1(f);
        return nativeFn.call(getKeys_1(obj), function(key) {
          return matcher(obj[key], key, obj);
        });
      };
    }

    var wrapObjectMatcher_1 = wrapObjectMatcher;

    var objectMatchers = {
      objectSome: wrapObjectMatcher_1('some'),
      objectFind: wrapObjectMatcher_1('find'),
      objectEvery: wrapObjectMatcher_1('every')
    };

    var objectEvery = objectMatchers.objectEvery;

    sugarCore.Object.defineInstanceAndStatic({

      'every': objectEvery

    });

    var every = sugarCore.Object.every;

    var forEachProperty$8 = coreUtilityAliases.forEachProperty;

    function objectFilter(obj, f) {
      var matcher = getMatcher_1(f), result = {};
      forEachProperty$8(obj, function(val, key) {
        if (matcher(val, key, obj)) {
          result[key] = val;
        }
      });
      return result;
    }

    var objectFilter_1 = objectFilter;

    sugarCore.Object.defineInstanceAndStatic({

      'filter': function(obj, f) {
        return objectFilter_1(obj, f);
      }

    });

    var filter$1 = sugarCore.Object.filter;

    var objectFind = objectMatchers.objectFind;

    sugarCore.Object.defineInstanceAndStatic({

      'find': objectFind

    });

    var find = sugarCore.Object.find;

    var isFunction$4 = classChecks.isFunction;

    function assertCallable(obj) {
      if (!isFunction$4(obj)) {
        throw new TypeError('Function is not callable');
      }
    }

    var assertCallable_1 = assertCallable;

    var forEachProperty$9 = coreUtilityAliases.forEachProperty;

    function objectForEach(obj, fn) {
      assertCallable_1(fn);
      forEachProperty$9(obj, function(val, key) {
        fn(val, key, obj);
      });
      return obj;
    }

    var objectForEach_1 = objectForEach;

    sugarCore.Object.defineInstanceAndStatic({

      'forEach': function(obj, eachFn) {
        return objectForEach_1(obj, eachFn);
      }

    });

    var forEach$2 = sugarCore.Object.forEach;

    function getReducedMinMaxResult(result, obj, all, asObject) {
      if (asObject && all) {
        // The method has returned an array of keys so use this array
        // to build up the resulting object in the form we want it in.
        return result.reduce(function(o, key) {
          o[key] = obj[key];
          return o;
        }, {});
      } else if (result && !all) {
        result = result[0];
      }
      return result;
    }

    var getReducedMinMaxResult_1 = getReducedMinMaxResult;

    var isBoolean$2 = classChecks.isBoolean;

    function getMinOrMax(obj, arg1, arg2, max, asObject) {
      var result = [], pushVal, edge, all, map;
      if (isBoolean$2(arg1)) {
        all = arg1;
        map = arg2;
      } else {
        map = arg1;
      }
      enumerateWithMapping_1(obj, map, function(val, key) {
        if (isUndefined_1(val)) {
          throw new TypeError('Cannot compare with undefined');
        }
        pushVal = asObject ? key : obj[key];
        if (val === edge) {
          result.push(pushVal);
        } else if (isUndefined_1(edge) || (max && val > edge) || (!max && val < edge)) {
          result = [pushVal];
          edge = val;
        }
      });
      return getReducedMinMaxResult_1(result, obj, all, asObject);
    }

    var getMinOrMax_1 = getMinOrMax;

    var isBoolean$3 = classChecks.isBoolean,
        getOwn$4 = coreUtilityAliases.getOwn,
        forEachProperty$a = coreUtilityAliases.forEachProperty;

    function getLeastOrMost(obj, arg1, arg2, most, asObject) {
      var group = {}, refs = [], minMaxResult, result, all, map;
      if (isBoolean$3(arg1)) {
        all = arg1;
        map = arg2;
      } else {
        map = arg1;
      }
      enumerateWithMapping_1(obj, map, function(val, key) {
        var groupKey = serializeInternal_1(val, refs);
        var arr = getOwn$4(group, groupKey) || [];
        arr.push(asObject ? key : obj[key]);
        group[groupKey] = arr;
      });
      minMaxResult = getMinOrMax_1(group, !!all, 'length', most, true);
      if (all) {
        result = [];
        // Flatten result
        forEachProperty$a(minMaxResult, function(val) {
          result = result.concat(val);
        });
      } else {
        result = getOwn$4(group, minMaxResult);
      }
      return getReducedMinMaxResult_1(result, obj, all, asObject);
    }

    var getLeastOrMost_1 = getLeastOrMost;

    sugarCore.Object.defineInstanceAndStatic({

      'least': function(obj, all, map) {
        return getLeastOrMost_1(obj, all, map, false, true);
      }

    });

    var least = sugarCore.Object.least;

    var forEachProperty$b = coreUtilityAliases.forEachProperty;

    function objectMap(obj, map) {
      var result = {};
      forEachProperty$b(obj, function(val, key) {
        result[key] = mapWithShortcuts_1(val, map, obj, [val, key, obj]);
      });
      return result;
    }

    var objectMap_1 = objectMap;

    sugarCore.Object.defineInstanceAndStatic({

      'map': function(obj, map) {
        return objectMap_1(obj, map);
      }

    });

    var map$1 = sugarCore.Object.map;

    sugarCore.Object.defineInstanceAndStatic({

      'max': function(obj, all, map) {
        return getMinOrMax_1(obj, all, map, true, true);
      }

    });

    var max$6 = sugarCore.Object.max;

    function median(obj, map) {
      var result = [], middle, len;
      enumerateWithMapping_1(obj, map, function(val) {
        result.push(val);
      });
      len = result.length;
      if (!len) return 0;
      result.sort(function(a, b) {
        // IE7 will throw errors on non-numbers!
        return (a || 0) - (b || 0);
      });
      middle = trunc_1(len / 2);
      return len % 2 ? result[middle] : (result[middle - 1] + result[middle]) / 2;
    }

    var median_1 = median;

    sugarCore.Object.defineInstanceAndStatic({

      'median': function(obj, map) {
        return median_1(obj, map);
      }

    });

    var median_1$1 = sugarCore.Object.median;

    sugarCore.Object.defineInstanceAndStatic({

      'min': function(obj, all, map) {
        return getMinOrMax_1(obj, all, map, false, true);
      }

    });

    var min$3 = sugarCore.Object.min;

    sugarCore.Object.defineInstanceAndStatic({

      'most': function(obj, all, map) {
        return getLeastOrMost_1(obj, all, map, true, true);
      }

    });

    var most = sugarCore.Object.most;

    var objectSome = objectMatchers.objectSome;

    function objectNone(obj, f) {
      return !objectSome(obj, f);
    }

    var objectNone_1 = objectNone;

    sugarCore.Object.defineInstanceAndStatic({

      'none': function(obj, f) {
        return objectNone_1(obj, f);
      }

    });

    var none = sugarCore.Object.none;

    var forEachProperty$c = coreUtilityAliases.forEachProperty;

    function objectReduce(obj, fn, acc) {
      var init = isDefined_1(acc);
      forEachProperty$c(obj, function(val, key) {
        if (!init) {
          acc = val;
          init = true;
          return;
        }
        acc = fn(acc, val, key, obj);
      });
      return acc;
    }

    var objectReduce_1 = objectReduce;

    sugarCore.Object.defineInstanceAndStatic({

      'reduce': function(obj, fn, init) {
        return objectReduce_1(obj, fn, init);
      }

    });

    var reduce = sugarCore.Object.reduce;

    var objectSome$1 = objectMatchers.objectSome;

    sugarCore.Object.defineInstanceAndStatic({

      'some': objectSome$1

    });

    var some = sugarCore.Object.some;

    function sum(obj, map) {
      var sum = 0;
      enumerateWithMapping_1(obj, map, function(val) {
        sum += val;
      });
      return sum;
    }

    var sum_1 = sum;

    sugarCore.Object.defineInstanceAndStatic({

      'sum': function(obj, map) {
        return sum_1(obj, map);
      }

    });

    var sum_1$1 = sugarCore.Object.sum;

    sugarCore.Array.defineInstance({

      'average': function(arr, map) {
        return average_1(arr, map);
      }

    });

    var average_1$2 = sugarCore.Array.average;

    var isFunction$5 = classChecks.isFunction;

    function enhancedMatching(f) {
      var matcher;
      if (isFunction$5(f)) {
        return f;
      }
      matcher = getMatcher_1(f);
      return function(el, i, arr) {
        return matcher(el, i, arr);
      };
    }

    var enhancedMatching_1 = enhancedMatching;

    function assertArgument(exists) {
      if (!exists) {
        throw new TypeError('Argument required');
      }
    }

    var assertArgument_1 = assertArgument;

    function wrapNativeArrayMethod(methodName, wrapper) {
      var nativeFn = Array.prototype[methodName];
      return function(arr, f, context, argsLen) {
        var args = new Array(2);
        assertArgument_1(argsLen > 0);
        args[0] = wrapper(f, context);
        args[1] = context;
        return nativeFn.apply(arr, args);
      };
    }

    var wrapNativeArrayMethod_1 = wrapNativeArrayMethod;

    function buildEnhancedMatching(name) {
      return wrapNativeArrayMethod_1(name, enhancedMatching_1);
    }

    var buildEnhancedMatching_1 = buildEnhancedMatching;

    var enhancedMatcherMethods = {
      enhancedFind: buildEnhancedMatching_1('find'),
      enhancedSome: buildEnhancedMatching_1('some'),
      enhancedEvery: buildEnhancedMatching_1('every'),
      enhancedFilter: buildEnhancedMatching_1('filter'),
      enhancedFindIndex: buildEnhancedMatching_1('findIndex')
    };

    var enhancedFilter = enhancedMatcherMethods.enhancedFilter;

    function arrayCount(arr, f) {
      if (isUndefined_1(f)) {
        return arr.length;
      }
      return enhancedFilter.apply(this, arguments).length;
    }

    var arrayCount_1 = arrayCount;

    sugarCore.Array.defineInstance({

      'count': fixArgumentLength_1(arrayCount_1)

    });

    var count$1 = sugarCore.Array.count;

    var ARRAY_ENHANCEMENTS_FLAG = 'enhanceArray';

    var enhancedEvery = enhancedMatcherMethods.enhancedEvery;

    sugarCore.Array.defineInstance({

      'every': fixArgumentLength_1(enhancedEvery)

    }, [ENHANCEMENTS_FLAG, ARRAY_ENHANCEMENTS_FLAG]);

    var every$1 = sugarCore.Array.every;

    var isFunction$6 = classChecks.isFunction;

    function enhancedMapping(map, context) {
      if (isFunction$6(map)) {
        return map;
      } else if (map) {
        return function(el, i, arr) {
          return mapWithShortcuts_1(el, map, context, [el, i, arr]);
        };
      }
    }

    var enhancedMapping_1 = enhancedMapping;

    var forEachProperty$d = coreUtilityAliases.forEachProperty,
        defineInstanceWithArguments = methodDefineAliases.defineInstanceWithArguments,
        sugarArray$2 = namespaceAliases.sugarArray,
        min$4 = mathAliases.min,
        max$7 = mathAliases.max,
        isBoolean$4 = classChecks.isBoolean;

    function buildFromIndexMethods() {

      var methods = {
        'forEach': {
          base: forEachAsNative
        },
        'map': {
          wrapper: enhancedMapping_1
        },
        'some every': {
          wrapper: enhancedMatching_1
        },
        'findIndex': {
          wrapper: enhancedMatching_1,
          result: indexResult
        },
        'reduce': {
          apply: applyReduce
        },
        'filter find': {
          wrapper: enhancedMatching_1
        },
        'reduceRight': {
          apply: applyReduce,
          slice: sliceArrayFromRight,
          clamp: clampStartIndexFromRight
        }
      };

      forEachProperty$d(methods, function(opts, key) {
        forEach_1(spaceSplit_1(key), function(baseName) {
          var methodName = baseName + 'FromIndex';
          var fn = createFromIndexWithOptions(baseName, opts);
          defineInstanceWithArguments(sugarArray$2, methodName, fn);
        });
      });

      function forEachAsNative(fn) {
        forEach_1(this, fn);
      }

      // Methods like filter and find have a direct association between the value
      // returned by the callback and the element of the current iteration. This
      // means that when looping, array elements must match the actual index for
      // which they are being called, so the array must be sliced. This is not the
      // case for methods like forEach and map, which either do not use return
      // values or use them in a way that simply getting the element at a shifted
      // index will not affect the final return value. However, these methods will
      // still fail on sparse arrays, so always slicing them here. For example, if
      // "forEachFromIndex" were to be called on [1,,2] from index 1, although the
      // actual index 1 would itself would be skipped, when the array loops back to
      // index 0, shifting it by adding 1 would result in the element for that
      // iteration being undefined. For shifting to work, all gaps in the array
      // between the actual index and the shifted index would have to be accounted
      // for. This is infeasible and is easily solved by simply slicing the actual
      // array instead so that gaps align. Note also that in the case of forEach,
      // we are using the internal function which handles sparse arrays in a way
      // that does not increment the index, and so is highly optimized compared to
      // the others here, which are simply going through the native implementation.
      function sliceArrayFromLeft(arr, startIndex, loop) {
        var result = arr;
        if (startIndex) {
          result = arr.slice(startIndex);
          if (loop) {
            result = result.concat(arr.slice(0, startIndex));
          }
        }
        return result;
      }

      // When iterating from the right, indexes are effectively shifted by 1.
      // For example, iterating from the right from index 2 in an array of 3
      // should also include the last element in the array. This matches the
      // "lastIndexOf" method which also iterates from the right.
      function sliceArrayFromRight(arr, startIndex, loop) {
        if (!loop) {
          startIndex += 1;
          arr = arr.slice(0, max$7(0, startIndex));
        }
        return arr;
      }

      function clampStartIndex(startIndex, len) {
        return min$4(len, max$7(0, startIndex));
      }

      // As indexes are shifted by 1 when starting from the right, clamping has to
      // go down to -1 to accommodate the full range of the sliced array.
      function clampStartIndexFromRight(startIndex, len) {
        return min$4(len, max$7(-1, startIndex));
      }

      function applyReduce(arr, startIndex, fn, context, len, loop) {
        return function(acc, val, i) {
          i = getNormalizedIndex_1(i + startIndex, len, loop);
          return fn.call(arr, acc, val, i, arr);
        };
      }

      function applyEach(arr, startIndex, fn, context, len, loop) {
        return function(el, i) {
          i = getNormalizedIndex_1(i + startIndex, len, loop);
          return fn.call(context, arr[i], i, arr);
        };
      }

      function indexResult(result, startIndex, len) {
        if (result !== -1) {
          result = (result + startIndex) % len;
        }
        return result;
      }

      function createFromIndexWithOptions(methodName, opts) {

        var baseFn = opts.base || Array.prototype[methodName],
            applyCallback = opts.apply || applyEach,
            sliceArray = opts.slice || sliceArrayFromLeft,
            clampIndex = opts.clamp || clampStartIndex,
            getResult = opts.result,
            wrapper = opts.wrapper;

        return function(arr, startIndex, args) {
          var callArgs = [], argIndex = 0, lastArg, result, len, loop, fn;
          len = arr.length;
          if (isBoolean$4(args[0])) {
            loop = args[argIndex++];
          }
          fn = args[argIndex++];
          lastArg = args[argIndex];
          if (startIndex < 0) {
            startIndex += len;
          }
          startIndex = clampIndex(startIndex, len);
          assertArgument_1(args.length);
          fn = wrapper ? wrapper(fn, lastArg) : fn;
          callArgs.push(applyCallback(arr, startIndex, fn, lastArg, len, loop));
          if (lastArg) {
            callArgs.push(lastArg);
          }
          result = baseFn.apply(sliceArray(arr, startIndex, loop), callArgs);
          if (getResult) {
            result = getResult(result, startIndex, len);
          }
          return result;
        };
      }
    }

    var buildFromIndexMethods_1 = buildFromIndexMethods;

    buildFromIndexMethods_1();

    var everyFromIndex = sugarCore.Array.everyFromIndex;

    var enhancedFilter$1 = enhancedMatcherMethods.enhancedFilter;

    sugarCore.Array.defineInstance({

      'filter': fixArgumentLength_1(enhancedFilter$1)

    }, [ENHANCEMENTS_FLAG, ARRAY_ENHANCEMENTS_FLAG]);

    var filter$2 = sugarCore.Array.filter;

    var filterFromIndex = sugarCore.Array.filterFromIndex;

    var enhancedFind = enhancedMatcherMethods.enhancedFind;

    sugarCore.Array.defineInstance({

      'find': fixArgumentLength_1(enhancedFind)

    }, [ENHANCEMENTS_FLAG, ARRAY_ENHANCEMENTS_FLAG]);

    var find$1 = sugarCore.Array.find;

    var findFromIndex = sugarCore.Array.findFromIndex;

    var enhancedFindIndex = enhancedMatcherMethods.enhancedFindIndex;

    sugarCore.Array.defineInstance({

      'findIndex': fixArgumentLength_1(enhancedFindIndex)

    }, [ENHANCEMENTS_FLAG, ARRAY_ENHANCEMENTS_FLAG]);

    var findIndex = sugarCore.Array.findIndex;

    var findIndexFromIndex = sugarCore.Array.findIndexFromIndex;

    var forEachFromIndex = sugarCore.Array.forEachFromIndex;

    sugarCore.Array.defineInstance({

      'least': function(arr, all, map) {
        return getLeastOrMost_1(arr, all, map);
      }

    });

    var least$1 = sugarCore.Array.least;

    function buildEnhancedMapping(name) {
      return wrapNativeArrayMethod_1(name, enhancedMapping_1);
    }

    var buildEnhancedMapping_1 = buildEnhancedMapping;

    var enhancedMap = buildEnhancedMapping_1('map');

    sugarCore.Array.defineInstance({

      'map': fixArgumentLength_1(enhancedMap)

    }, [ENHANCEMENTS_FLAG, ARRAY_ENHANCEMENTS_FLAG]);

    var map$2 = sugarCore.Array.map;

    var mapFromIndex = sugarCore.Array.mapFromIndex;

    sugarCore.Array.defineInstance({

      'max': function(arr, all, map) {
        return getMinOrMax_1(arr, all, map, true);
      }

    });

    var max$8 = sugarCore.Array.max;

    sugarCore.Array.defineInstance({

      'median': function(arr, map) {
        return median_1(arr, map);
      }

    });

    var median_1$2 = sugarCore.Array.median;

    sugarCore.Array.defineInstance({

      'min': function(arr, all, map) {
        return getMinOrMax_1(arr, all, map);
      }

    });

    var min$5 = sugarCore.Array.min;

    sugarCore.Array.defineInstance({

      'most': function(arr, all, map) {
        return getLeastOrMost_1(arr, all, map, true);
      }

    });

    var most$1 = sugarCore.Array.most;

    var enhancedSome = enhancedMatcherMethods.enhancedSome;

    function arrayNone() {
      return !enhancedSome.apply(this, arguments);
    }

    var arrayNone_1 = arrayNone;

    sugarCore.Array.defineInstance({

      'none': fixArgumentLength_1(arrayNone_1)

    });

    var none$1 = sugarCore.Array.none;

    var reduceFromIndex = sugarCore.Array.reduceFromIndex;

    var reduceRightFromIndex = sugarCore.Array.reduceRightFromIndex;

    var enhancedSome$1 = enhancedMatcherMethods.enhancedSome;

    sugarCore.Array.defineInstance({

      'some': fixArgumentLength_1(enhancedSome$1)

    }, [ENHANCEMENTS_FLAG, ARRAY_ENHANCEMENTS_FLAG]);

    var some$1 = sugarCore.Array.some;

    var someFromIndex = sugarCore.Array.someFromIndex;

    sugarCore.Array.defineInstance({

      'sum': function(arr, map) {
        return sum_1(arr, map);
      }

    });

    var sum_1$2 = sugarCore.Array.sum;

    var getOwnPropertyNames = Object.getOwnPropertyNames;

    var classToString$4 = coreUtilityAliases.classToString,
        isDate$2 = classChecks.isDate,
        isRegExp$4 = classChecks.isRegExp,
        isArray$a = classChecks.isArray;

    function getNewObjectForMerge(source) {
      var klass = classToString$4(source);
      // Primitive types, dates, and regexes have no "empty" state. If they exist
      // at all, then they have an associated value. As we are only creating new
      // objects when they don't exist in the target, these values can come alone
      // for the ride when created.
      if (isArray$a(source, klass)) {
        return [];
      } else if (isPlainObject_1(source, klass)) {
        return {};
      } else if (isDate$2(source, klass)) {
        return new Date(source.getTime());
      } else if (isRegExp$4(source, klass)) {
        return RegExp(source.source, getRegExpFlags_1(source));
      } else if (isPrimitive_1(source && source.valueOf())) {
        return source;
      }
      // If the object is not of a known type, then simply merging its
      // properties into a plain object will result in something different
      // (it will not respond to instanceof operator etc). Similarly we don't
      // want to call a constructor here as we can't know for sure what the
      // original constructor was called with (Events etc), so throw an
      // error here instead. Non-standard types can be handled if either they
      // already exist and simply have their properties merged, if the merge
      // is not deep so their references will simply be copied over, or if a
      // resolve function is used to assist the merge.
      throw new TypeError('Must be a basic data type');
    }

    var getNewObjectForMerge_1 = getNewObjectForMerge;

    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

    function iterateOverKeys(getFn, obj, fn, hidden) {
      var keys = getFn(obj), desc;
      for (var i = 0, key; key = keys[i]; i++) {
        desc = getOwnPropertyDescriptor(obj, key);
        if (desc.enumerable || hidden) {
          fn(obj[key], key);
        }
      }
    }

    var iterateOverKeys_1 = iterateOverKeys;

    var getOwnPropertySymbols = Object.getOwnPropertySymbols;

    var forEachProperty$e = coreUtilityAliases.forEachProperty;

    function iterateOverProperties(hidden, obj, fn) {
      if (getOwnPropertyNames && hidden) {
        iterateOverKeys_1(getOwnPropertyNames, obj, fn, hidden);
      } else {
        forEachProperty$e(obj, fn);
      }
      if (getOwnPropertySymbols) {
        iterateOverKeys_1(getOwnPropertySymbols, obj, fn, hidden);
      }
    }

    var iterateOverProperties_1 = iterateOverProperties;

    var NO_KEYS_IN_STRING_OBJECTS = !('0' in Object('a'));

    function forceStringCoercion(obj) {
      var i = 0, chr;
      while (chr = obj.charAt(i)) {
        obj[i++] = chr;
      }
    }

    var forceStringCoercion_1 = forceStringCoercion;

    var isString$b = classChecks.isString;

    function coercePrimitiveToObject(obj) {
      if (isPrimitive_1(obj)) {
        obj = Object(obj);
      }
      // istanbul ignore next
      if (NO_KEYS_IN_STRING_OBJECTS && isString$b(obj)) {
        forceStringCoercion_1(obj);
      }
      return obj;
    }

    var coercePrimitiveToObject_1 = coercePrimitiveToObject;

    var defineProperty = coreUtilityAliases.defineProperty;

    function mergeByPropertyDescriptor(target, source, prop, sourceVal) {
      var descriptor = getOwnPropertyDescriptor(source, prop);
      if (isDefined_1(descriptor.value)) {
        descriptor.value = sourceVal;
      }
      defineProperty(target, prop, descriptor);
    }

    var mergeByPropertyDescriptor_1 = mergeByPropertyDescriptor;

    var isDate$3 = classChecks.isDate,
        isRegExp$5 = classChecks.isRegExp,
        isFunction$7 = classChecks.isFunction,
        getOwn$5 = coreUtilityAliases.getOwn;

    function objectMerge(target, source, deep, resolve, hidden, descriptor) {
      var resolveByFunction = isFunction$7(resolve), resolveConflicts = resolve !== false;

      if (isUndefined_1(target)) {
        target = getNewObjectForMerge_1(source);
      } else if (resolveConflicts && isDate$3(target) && isDate$3(source)) {
        // A date's timestamp is a property that can only be reached through its
        // methods, so actively set it up front if both are dates.
        target.setTime(source.getTime());
      }

      if (isPrimitive_1(target)) {
        // Will not merge into a primitive type, so simply override.
        return source;
      }

      // If the source object is a primitive
      // type then coerce it into an object.
      if (isPrimitive_1(source)) {
        source = coercePrimitiveToObject_1(source);
      }

      iterateOverProperties_1(hidden, source, function(val, key) {
        var sourceVal, targetVal, resolved, goDeep, result;

        sourceVal = source[key];

        // We are iterating over properties of the source, so hasOwnProperty on
        // it is guaranteed to always be true. However, the target may happen to
        // have properties in its prototype chain that should not be considered
        // as conflicts.
        targetVal = getOwn$5(target, key);

        if (resolveByFunction) {
          result = resolve(key, targetVal, sourceVal, target, source);
          if (isUndefined_1(result)) {
            // Result is undefined so do not merge this property.
            return;
          } else if (isDefined_1(result) && result !== sugarCore) {
            // If the source returns anything except undefined, then the conflict
            // has been resolved, so don't continue traversing into the object. If
            // the returned value is the Sugar global object, then allowing Sugar
            // to resolve the conflict, so continue on.
            sourceVal = result;
            resolved = true;
          }
        } else if (isUndefined_1(sourceVal)) {
          // Will not merge undefined.
          return;
        }

        // Regex properties are read-only, so intentionally disallowing deep
        // merging for now. Instead merge by reference even if deep.
        goDeep = !resolved && deep && isObjectType_1(sourceVal) && !isRegExp$5(sourceVal);

        if (!goDeep && !resolveConflicts && isDefined_1(targetVal)) {
          return;
        }

        if (goDeep) {
          sourceVal = objectMerge(targetVal, sourceVal, deep, resolve, hidden, descriptor);
        }

        // getOwnPropertyNames is standing in as
        // a test for property descriptor support
        if (getOwnPropertyNames && descriptor) {
          mergeByPropertyDescriptor_1(target, source, key, sourceVal);
        } else {
          target[key] = sourceVal;
        }

      });
      return target;
    }

    var objectMerge_1 = objectMerge;

    function clone$1(source, deep) {
      var target = getNewObjectForMerge_1(source);
      return objectMerge_1(target, source, deep, true, true, true);
    }

    var clone_1 = clone$1;

    function mergeWithOptions(target, source, opts) {
      opts = opts || {};
      return objectMerge_1(target, source, opts.deep, opts.resolve, opts.hidden, opts.descriptor);
    }

    var mergeWithOptions_1 = mergeWithOptions;

    sugarCore.Object.defineInstanceAndStatic({

      'add': function(obj1, obj2, opts) {
        return mergeWithOptions_1(clone_1(obj1), obj2, opts);
      }

    });

    var add$1 = sugarCore.Object.add;

    var isArray$b = classChecks.isArray;

    function mergeAll(target, sources, opts) {
      if (!isArray$b(sources)) {
        sources = [sources];
      }
      forEach_1(sources, function(source) {
        return mergeWithOptions_1(target, source, opts);
      });
      return target;
    }

    var mergeAll_1 = mergeAll;

    sugarCore.Object.defineInstanceAndStatic({

      'addAll': function(obj, sources, opts) {
        return mergeAll_1(clone_1(obj), sources, opts);
      }

    });

    var addAll = sugarCore.Object.addAll;

    sugarCore.Object.defineInstanceAndStatic({

      'clone': function(obj, deep) {
        return clone_1(obj, deep);
      }

    });

    var clone_1$1 = sugarCore.Object.clone;

    function defaults$6(target, sources, opts) {
      opts = opts || {};
      opts.resolve = opts.resolve || false;
      return mergeAll_1(target, sources, opts);
    }

    var defaults_1$1 = defaults$6;

    sugarCore.Object.defineInstanceAndStatic({

      'defaults': function(target, sources, opts) {
        return defaults_1$1(target, sources, opts);
      }

    });

    var defaults_1$2 = sugarCore.Object.defaults;

    var forEachProperty$f = coreUtilityAliases.forEachProperty;

    function objectExclude(obj, f) {
      var result = {};
      var matcher = getMatcher_1(f);
      forEachProperty$f(obj, function(val, key) {
        if (!matcher(val, key, obj)) {
          result[key] = val;
        }
      });
      return result;
    }

    var objectExclude_1 = objectExclude;

    sugarCore.Object.defineInstanceAndStatic({

      'exclude': function(obj, f) {
        return objectExclude_1(obj, f);
      }

    });

    var exclude$1 = sugarCore.Object.exclude;

    var DEEP_QUERY_STRING_REG = /^(.+?)(\[.*\])$/;

    var NON_DECIMAL_REG = /[^\d.-]/;

    function stringIsDecimal(str) {
      return str !== '' && !NON_DECIMAL_REG.test(str);
    }

    var stringIsDecimal_1 = stringIsDecimal;

    var getOwn$6 = coreUtilityAliases.getOwn,
        isArray$c = classChecks.isArray;

    function getQueryValueAuto(obj, key, val) {
      if (!val) {
        return null;
      } else if (val === 'true') {
        return true;
      } else if (val === 'false') {
        return false;
      }
      var num = +val;
      if (!isNaN(num) && stringIsDecimal_1(val)) {
        return num;
      }
      var existing = getOwn$6(obj, key);
      if (val && existing) {
        return isArray$c(existing) ? existing.concat(val) : [existing, val];
      }
      return val;
    }

    var getQueryValueAuto_1 = getQueryValueAuto;

    function setQueryProperty(obj, key, val, auto, transform) {
      var fnValue;
      if (transform) {
        fnValue = transform(val, key, obj);
      }
      if (isDefined_1(fnValue)) {
        val = fnValue;
      } else if (auto) {
        val = getQueryValueAuto_1(obj, key, val);
      }
      obj[key] = val;
    }

    var setQueryProperty_1 = setQueryProperty;

    function mapQuerySeparatorToKeys(key, separator) {
      var split = key.split(separator), result = split[0];
      for (var i = 1, len = split.length; i < len; i++) {
        result += '[' + split[i] + ']';
      }
      return result;
    }

    var mapQuerySeparatorToKeys_1 = mapQuerySeparatorToKeys;

    var hasOwn$7 = coreUtilityAliases.hasOwn,
        getOwn$7 = coreUtilityAliases.getOwn;

    function parseDeepQueryComponent(obj, match, val, deep, auto, separator, transform) {
      var key = match[1];
      var inner = match[2].slice(1, -1).split('][');
      forEach_1(inner, function(k) {
        if (!hasOwn$7(obj, key)) {
          obj[key] = k ? {} : [];
        }
        obj = getOwn$7(obj, key);
        key = k ? k : obj.length.toString();
      });
      setQueryProperty_1(obj, key, val, auto, transform);
    }

    var parseDeepQueryComponent_1 = parseDeepQueryComponent;

    function parseQueryComponent(obj, key, val, deep, auto, separator, transform) {
      var match;
      if (separator) {
        key = mapQuerySeparatorToKeys_1(key, separator);
        deep = true;
      }
      if (deep === true && (match = key.match(DEEP_QUERY_STRING_REG))) {
        parseDeepQueryComponent_1(obj, match, val, deep, auto, separator, transform);
      } else {
        setQueryProperty_1(obj, key, val, auto, transform);
      }
    }

    var parseQueryComponent_1 = parseQueryComponent;

    function fromQueryStringWithOptions(obj, opts) {
      var str = String(obj || '').replace(/^.*?\?/, ''), result = {}, auto;
      opts = opts || {};
      if (str) {
        forEach_1(str.split('&'), function(p) {
          var split = p.split('=');
          var key = decodeURIComponent(split[0]);
          var val = split.length === 2 ? decodeURIComponent(split[1]) : '';
          auto = opts.auto !== false;
          parseQueryComponent_1(result, key, val, opts.deep, auto, opts.separator, opts.transform);
        });
      }
      return result;
    }

    var fromQueryStringWithOptions_1 = fromQueryStringWithOptions;

    sugarCore.Object.defineStatic({

      'fromQueryString': function(obj, options) {
        return fromQueryStringWithOptions_1(obj, options);
      }

    });

    var fromQueryString = sugarCore.Object.fromQueryString;

    sugarCore.Object.defineInstanceAndStatic({

      'get': function(obj, key, any) {
        return deepGetProperty_1(obj, key, any);
      }

    });

    var get = sugarCore.Object.get;

    function deepHasProperty(obj, key, any) {
      return handleDeepProperty_1(obj, key, any, true);
    }

    var deepHasProperty_1 = deepHasProperty;

    sugarCore.Object.defineInstanceAndStatic({

      'has': function(obj, key, any) {
        return deepHasProperty_1(obj, key, any);
      }

    });

    var has = sugarCore.Object.has;

    function objectIntersectOrSubtract(obj1, obj2, subtract) {
      if (!isObjectType_1(obj1)) {
        return subtract ? obj1 : {};
      }
      obj2 = coercePrimitiveToObject_1(obj2);
      function resolve(key, val, val1) {
        var exists = key in obj2 && isEqual_1(val1, obj2[key]);
        if (exists !== subtract) {
          return val1;
        }
      }
      return objectMerge_1({}, obj1, false, resolve);
    }

    var objectIntersectOrSubtract_1 = objectIntersectOrSubtract;

    sugarCore.Object.defineInstanceAndStatic({

      'intersect': function(obj1, obj2) {
        return objectIntersectOrSubtract_1(obj1, obj2, false);
      }

    });

    var intersect$1 = sugarCore.Object.intersect;

    var hasOwn$8 = coreUtilityAliases.hasOwn,
        forEachProperty$g = coreUtilityAliases.forEachProperty;

    sugarCore.Object.defineInstanceAndStatic({

      'invert': function(obj, multi) {
        var result = {};
        multi = multi === true;
        forEachProperty$g(obj, function(val, key) {
          if (hasOwn$8(result, val) && multi) {
            result[val].push(key);
          } else if (multi) {
            result[val] = [key];
          } else {
            result[val] = key;
          }
        });
        return result;
      }

    });

    var invert = sugarCore.Object.invert;

    function hasProperty(obj, prop) {
      return !isPrimitive_1(obj) && prop in obj;
    }

    var hasProperty_1 = hasProperty;

    var classToString$5 = coreUtilityAliases.classToString;

    function isArguments(obj, className) {
      className = className || classToString$5(obj);
      // .callee exists on Arguments objects in < IE8
      return hasProperty_1(obj, 'length') && (className === '[object Arguments]' || !!obj.callee);
    }

    var isArguments_1 = isArguments;

    sugarCore.Object.defineInstanceAndStatic({

      'isArguments': function(obj) {
        return isArguments_1(obj);
      }

    });

    var isArguments_1$1 = sugarCore.Object.isArguments;

    var defineInstanceAndStatic = methodDefineAliases.defineInstanceAndStatic;

    function defineInstanceAndStaticSimilar(sugarNamespace, set, fn, flags) {
      defineInstanceAndStatic(sugarNamespace, collectSimilarMethods_1(set, fn), flags);
    }

    var defineInstanceAndStaticSimilar_1 = defineInstanceAndStaticSimilar;

    var isBoolean$5 = classChecks.isBoolean,
        isNumber$3 = classChecks.isNumber,
        isString$c = classChecks.isString,
        isDate$4 = classChecks.isDate,
        isRegExp$6 = classChecks.isRegExp,
        isFunction$8 = classChecks.isFunction,
        isArray$d = classChecks.isArray,
        isSet$2 = classChecks.isSet,
        isMap$2 = classChecks.isMap,
        isError$2 = classChecks.isError,
        sugarObject = namespaceAliases.sugarObject;

    function buildClassCheckMethods() {
      var checks = [isBoolean$5, isNumber$3, isString$c, isDate$4, isRegExp$6, isFunction$8, isArray$d, isError$2, isSet$2, isMap$2];
      defineInstanceAndStaticSimilar_1(sugarObject, NATIVE_TYPES, function(methods, name, i) {
        methods['is' + name] = checks[i];
      });
    }

    var buildClassCheckMethods_1 = buildClassCheckMethods;

    buildClassCheckMethods_1();

    var isArray$e = sugarCore.Object.isArray;

    var isBoolean$6 = sugarCore.Object.isBoolean;

    var isDate$5 = sugarCore.Object.isDate;

    function getKeysWithObjectCoercion(obj) {
      return getKeys_1(coercePrimitiveToObject_1(obj));
    }

    var getKeysWithObjectCoercion_1 = getKeysWithObjectCoercion;

    function objectSize(obj) {
      return getKeysWithObjectCoercion_1(obj).length;
    }

    var objectSize_1 = objectSize;

    sugarCore.Object.defineInstanceAndStatic({

      'isEmpty': function(obj) {
        return objectSize_1(obj) === 0;
      }

    });

    var isEmpty$2 = sugarCore.Object.isEmpty;

    sugarCore.Object.defineInstanceAndStatic({

      'isEqual': function(obj1, obj2) {
        return isEqual_1(obj1, obj2);
      }

    });

    var isEqual_1$2 = sugarCore.Object.isEqual;

    var isError$3 = sugarCore.Object.isError;

    var isFunction$9 = sugarCore.Object.isFunction;

    var isMap$3 = sugarCore.Object.isMap;

    var isNumber$4 = sugarCore.Object.isNumber;

    sugarCore.Object.defineInstanceAndStatic({

      'isObject': function(obj) {
        return isPlainObject_1(obj);
      }

    });

    var isObject = sugarCore.Object.isObject;

    var isRegExp$7 = sugarCore.Object.isRegExp;

    var isSet$3 = sugarCore.Object.isSet;

    var isString$d = sugarCore.Object.isString;

    sugarCore.Object.defineInstanceAndStatic({

      'merge': function(target, source, opts) {
        return mergeWithOptions_1(target, source, opts);
      }

    });

    var merge$3 = sugarCore.Object.merge;

    sugarCore.Object.defineInstanceAndStatic({

      'mergeAll': function(target, sources, opts) {
        return mergeAll_1(target, sources, opts);
      }

    });

    var mergeAll_1$1 = sugarCore.Object.mergeAll;

    var isRegExp$8 = classChecks.isRegExp;

    function matchInObject(match, key) {
      if (isRegExp$8(match)) {
        return match.test(key);
      } else if (isObjectType_1(match)) {
        return key in match;
      } else {
        return key === String(match);
      }
    }

    var matchInObject_1 = matchInObject;

    var forEachProperty$h = coreUtilityAliases.forEachProperty;

    function selectFromObject(obj, f, select) {
      var match, result = {};
      f = [].concat(f);
      forEachProperty$h(obj, function(val, key) {
        match = false;
        for (var i = 0; i < f.length; i++) {
          if (matchInObject_1(f[i], key)) {
            match = true;
          }
        }
        if (match === select) {
          result[key] = val;
        }
      });
      return result;
    }

    var selectFromObject_1 = selectFromObject;

    function objectReject(obj, f) {
      return selectFromObject_1(obj, f, false);
    }

    var objectReject_1 = objectReject;

    sugarCore.Object.defineInstanceAndStatic({

      'reject': function(obj, f) {
        return objectReject_1(obj, f);
      }

    });

    var reject = sugarCore.Object.reject;

    var forEachProperty$i = coreUtilityAliases.forEachProperty;

    function objectRemove(obj, f) {
      var matcher = getMatcher_1(f);
      forEachProperty$i(obj, function(val, key) {
        if (matcher(val, key, obj)) {
          delete obj[key];
        }
      });
      return obj;
    }

    var objectRemove_1 = objectRemove;

    sugarCore.Object.defineInstanceAndStatic({

      'remove': function(obj, f) {
        return objectRemove_1(obj, f);
      }

    });

    var remove$2 = sugarCore.Object.remove;

    function objectSelect(obj, f) {
      return selectFromObject_1(obj, f, true);
    }

    var objectSelect_1 = objectSelect;

    sugarCore.Object.defineInstanceAndStatic({

      'select': function(obj, f) {
        return objectSelect_1(obj, f);
      }

    });

    var select = sugarCore.Object.select;

    function deepSetProperty(obj, key, val) {
      handleDeepProperty_1(obj, key, false, false, true, false, val);
      return obj;
    }

    var deepSetProperty_1 = deepSetProperty;

    sugarCore.Object.defineInstanceAndStatic({

      'set': function(obj, key, val) {
        return deepSetProperty_1(obj, key, val);
      }

    });

    var set = sugarCore.Object.set;

    sugarCore.Object.defineInstanceAndStatic({

      'size': function(obj) {
        return objectSize_1(obj);
      }

    });

    var size = sugarCore.Object.size;

    sugarCore.Object.defineInstanceAndStatic({

      'subtract': function(obj1, obj2) {
        return objectIntersectOrSubtract_1(obj1, obj2, true);
      }

    });

    var subtract$1 = sugarCore.Object.subtract;

    var isFunction$a = classChecks.isFunction;

    function tap(obj, arg) {
      var fn = arg;
      if (!isFunction$a(arg)) {
        fn = function() {
          if (arg) obj[arg]();
        };
      }
      fn.call(obj, obj);
      return obj;
    }

    var tap_1 = tap;

    sugarCore.Object.defineInstanceAndStatic({

      'tap': function(obj, arg) {
        return tap_1(obj, arg);
      }

    });

    var tap_1$1 = sugarCore.Object.tap;

    var internalToString = Object.prototype.toString;

    function sanitizeURIComponent(obj) {
      // undefined, null, and NaN are represented as a blank string,
      // while false and 0 are stringified.
      return !obj && obj !== false && obj !== 0 ? '' : encodeURIComponent(obj);
    }

    var sanitizeURIComponent_1 = sanitizeURIComponent;

    var isDate$6 = classChecks.isDate;

    function getURIComponentValue(obj, prefix, transform) {
      var value;
      if (transform) {
        value = transform(obj, prefix);
      } else if (isDate$6(obj)) {
        value = obj.getTime();
      } else {
        value = obj;
      }
      return sanitizeURIComponent_1(prefix) + '=' + sanitizeURIComponent_1(value);
    }

    var getURIComponentValue_1 = getURIComponentValue;

    var isArray$f = classChecks.isArray,
        forEachProperty$j = coreUtilityAliases.forEachProperty;

    function toQueryString(obj, deep, transform, prefix, separator) {
      if (isArray$f(obj)) {
        return collectArrayAsQueryString(obj, deep, transform, prefix, separator);
      } else if (isObjectType_1(obj) && obj.toString === internalToString) {
        return collectObjectAsQueryString(obj, deep, transform, prefix, separator);
      } else if (prefix) {
        return getURIComponentValue_1(obj, prefix, transform);
      }
      return '';
    }

    function collectArrayAsQueryString(arr, deep, transform, prefix, separator) {
      var el, qc, key, result = [];
      // Intentionally treating sparse arrays as dense here by avoiding map,
      // otherwise indexes will shift during the process of serialization.
      for (var i = 0, len = arr.length; i < len; i++) {
        el = arr[i];
        key = prefix + (prefix && deep ? '[]' : '');
        if (!key && !isObjectType_1(el)) {
          // If there is no key, then the values of the array should be
          // considered as null keys, so use them instead;
          qc = sanitizeURIComponent_1(el);
        } else {
          qc = toQueryString(el, deep, transform, key, separator);
        }
        result.push(qc);
      }
      return result.join('&');
    }

    function collectObjectAsQueryString(obj, deep, transform, prefix, separator) {
      var result = [];
      forEachProperty$j(obj, function(val, key) {
        var fullKey;
        if (prefix && deep) {
          fullKey = prefix + '[' + key + ']';
        } else if (prefix) {
          fullKey = prefix + separator + key;
        } else {
          fullKey = key;
        }
        result.push(toQueryString(val, deep, transform, fullKey, separator));
      });
      return result.join('&');
    }

    var toQueryString_1 = toQueryString;

    function toQueryStringWithOptions(obj, opts) {
      opts = opts || {};
      if (isUndefined_1(opts.separator)) {
        opts.separator = '_';
      }
      return toQueryString_1(obj, opts.deep, opts.transform, opts.prefix || '', opts.separator);
    }

    var toQueryStringWithOptions_1 = toQueryStringWithOptions;

    sugarCore.Object.defineInstanceAndStatic({

      'toQueryString': function(obj, options) {
        return toQueryStringWithOptions_1(obj, options);
      }

    });

    var toQueryString$1 = sugarCore.Object.toQueryString;

    var forEachProperty$k = coreUtilityAliases.forEachProperty;

    function getValues(obj) {
      var values = [];
      forEachProperty$k(obj, function(val) {
        values.push(val);
      });
      return values;
    }

    var getValues_1 = getValues;

    sugarCore.Object.defineInstanceAndStatic({

      'values': function(obj) {
        return getValues_1(obj);
      }

    });

    var values = sugarCore.Object.values;

    sugarCore.Object.defineInstance({

      'keys': function(obj) {
        return getKeys_1(obj);
      }

    });

    var keys = sugarCore.Object.keys;

    var EnglishLocaleBaseDefinition = {
      'code': 'en',
      'plural': true,
      'timeMarkers': 'at',
      'ampm': 'AM|A.M.|a,PM|P.M.|p',
      'units': 'millisecond:|s,second:|s,minute:|s,hour:|s,day:|s,week:|s,month:|s,year:|s',
      'months': 'Jan:uary|,Feb:ruary|,Mar:ch|,Apr:il|,May,Jun:e|,Jul:y|,Aug:ust|,Sep:tember|t|,Oct:ober|,Nov:ember|,Dec:ember|',
      'weekdays': 'Sun:day|,Mon:day|,Tue:sday|,Wed:nesday|,Thu:rsday|,Fri:day|,Sat:urday|+weekend',
      'numerals': 'zero,one|first,two|second,three|third,four:|th,five|fifth,six:|th,seven:|th,eight:|h,nin:e|th,ten:|th',
      'articles': 'a,an,the',
      'tokens': 'the,st|nd|rd|th,of|in,a|an,on',
      'time': '{H}:{mm}',
      'past': '{num} {unit} {sign}',
      'future': '{num} {unit} {sign}',
      'duration': '{num} {unit}',
      'modifiers': [
        { 'name': 'half',   'src': 'half', 'value': .5 },
        { 'name': 'midday', 'src': 'noon', 'value': 12 },
        { 'name': 'midday', 'src': 'midnight', 'value': 24 },
        { 'name': 'day',    'src': 'yesterday', 'value': -1 },
        { 'name': 'day',    'src': 'today|tonight', 'value': 0 },
        { 'name': 'day',    'src': 'tomorrow', 'value': 1 },
        { 'name': 'sign',   'src': 'ago|before', 'value': -1 },
        { 'name': 'sign',   'src': 'from now|after|from|in|later', 'value': 1 },
        { 'name': 'edge',   'src': 'first day|first|beginning', 'value': -2 },
        { 'name': 'edge',   'src': 'last day', 'value': 1 },
        { 'name': 'edge',   'src': 'end|last', 'value': 2 },
        { 'name': 'shift',  'src': 'last', 'value': -1 },
        { 'name': 'shift',  'src': 'the|this', 'value': 0 },
        { 'name': 'shift',  'src': 'next', 'value': 1 }
      ],
      'parse': [
        '(?:just)? now',
        '{shift} {unit:5-7}',
        '{months?} {year}',
        '{midday} {4?} {day|weekday}',
        '{months},?[-.\\/\\s]?{year?}',
        '{edge} of (?:day)? {day|weekday}',
        '{0} {num}{1?} {weekday} {2} {months},? {year?}',
        '{shift?} {day?} {weekday?} (?:at)? {midday}',
        '{sign?} {3?} {half} {3?} {unit:3-4|unit:7} {sign?}',
        '{0?} {edge} {weekday?} {2} {shift?} {unit:4-7?} {months?},? {year?}'
      ],
      'timeParse': [
        '{day|weekday}',
        '{shift} {unit:5?} {weekday}',
        '{0?} {date}{1?} {2?} {months?}',
        '{weekday} {2?} {shift} {unit:5}',
        '{0?} {num} {2?} {months}\\.?,? {year?}',
        '{num?} {unit:4-5} {sign} {day|weekday}',
        '{0|months} {date?}{1?} of {shift} {unit:6-7}',
        '{0?} {num}{1?} {weekday} of {shift} {unit:6}',
        '{year?}[-.\\/\\s]?{months}[-.\\/\\s]{date}',
        '{date}[-.\\/\\s]{months}(?:[-.\\/\\s]{year|yy})?',
        '{weekday?}\\.?,? {months}\\.?,? {date}{1?},? {year?}',
        '{weekday?}\\.?,? {date} {months} {year}'
      ],
      'timeFrontParse': [
        '{sign} {num} {unit}',
        '{num} {unit} {sign}',
        '{4?} {day|weekday}'
      ]
    };

    var EnglishLocaleBaseDefinition_1 = EnglishLocaleBaseDefinition;

    function getEnglishVariant(v) {
      return simpleMerge_1(simpleClone_1(EnglishLocaleBaseDefinition_1), v);
    }

    var getEnglishVariant_1 = getEnglishVariant;

    var BritishEnglishDefinition = getEnglishVariant_1({
      'short':  '{dd}/{MM}/{yyyy}',
      'medium': '{d} {Month} {yyyy}',
      'long':   '{d} {Month} {yyyy} {H}:{mm}',
      'full':   '{Weekday}, {d} {Month}, {yyyy} {time}',
      'stamp':  '{Dow} {d} {Mon} {yyyy} {time}'
    });

    var BritishEnglishDefinition_1 = BritishEnglishDefinition;

    var AmericanEnglishDefinition = getEnglishVariant_1({
      'mdy': true,
      'firstDayOfWeek': 0,
      'firstDayOfWeekYear': 1,
      'short':  '{MM}/{dd}/{yyyy}',
      'medium': '{Month} {d}, {yyyy}',
      'long':   '{Month} {d}, {yyyy} {time}',
      'full':   '{Weekday}, {Month} {d}, {yyyy} {time}',
      'stamp':  '{Dow} {Mon} {d} {yyyy} {time}',
      'time':   '{h}:{mm} {TT}'
    });

    var AmericanEnglishDefinition_1 = AmericanEnglishDefinition;

    var CanadianEnglishDefinition = getEnglishVariant_1({
      'short':  '{yyyy}-{MM}-{dd}',
      'medium': '{d} {Month}, {yyyy}',
      'long':   '{d} {Month}, {yyyy} {H}:{mm}',
      'full':   '{Weekday}, {d} {Month}, {yyyy} {time}',
      'stamp':  '{Dow} {d} {Mon} {yyyy} {time}'
    });

    var CanadianEnglishDefinition_1 = CanadianEnglishDefinition;

    var LazyLoadedLocales = {
      'en-US': AmericanEnglishDefinition_1,
      'en-GB': BritishEnglishDefinition_1,
      'en-AU': BritishEnglishDefinition_1,
      'en-CA': CanadianEnglishDefinition_1
    };

    var LazyLoadedLocales_1 = LazyLoadedLocales;

    var LOCALE_ARRAY_FIELDS = [
      'months', 'weekdays', 'units', 'numerals', 'placeholders',
      'articles', 'tokens', 'timeMarkers', 'ampm', 'timeSuffixes',
      'parse', 'timeParse', 'timeFrontParse', 'modifiers'
    ];

    var LOCALE_ARRAY_FIELDS_1 = LOCALE_ARRAY_FIELDS;

    var ISODefaults = {
      ISO_FIRST_DAY_OF_WEEK: 1,
      ISO_FIRST_DAY_OF_WEEK_YEAR: 4
    };

    var CoreParsingTokens = {
      'yyyy': {
        param: 'year',
        src: '[-−+]?\\d{4,6}'
      },
      'yy': {
        param: 'year',
        src: '\\d{2}'
      },
      'y': {
        param: 'year',
        src: '\\d'
      },
      'ayy': {
        param: 'year',
        src: '\'\\d{2}'
      },
      'MM': {
        param: 'month',
        src: '(?:1[012]|0?[1-9])'
      },
      'dd': {
        param: 'date',
        src: '(?:3[01]|[12][0-9]|0?[1-9])'
      },
      'hh': {
        param: 'hour',
        src: '(?:2[0-4]|[01]?[0-9])'
      },
      'mm': {
        param: 'minute',
        src: '[0-5]\\d'
      },
      'ss': {
        param: 'second',
        src: '[0-5]\\d(?:[,.]\\d+)?'
      },
      'tzHour': {
        src: '[-−+](?:2[0-4]|[01]?[0-9])'
      },
      'tzMinute': {
        src: '[0-5]\\d'
      },
      'iyyyy': {
        param: 'year',
        src: '(?:[-−+]?\\d{4}|[-−+]\\d{5,6})'
      },
      'ihh': {
        param: 'hour',
        src: '(?:2[0-4]|[01][0-9])(?:[,.]\\d+)?'
      },
      'imm': {
        param: 'minute',
        src: '[0-5]\\d(?:[,.]\\d+)?'
      },
      'GMT': {
        param: 'utc',
        src: 'GMT'
      },
      'Z': {
        param: 'utc',
        src: 'Z'
      },
      'timestamp': {
        src: '\\d+'
      }
    };

    var CoreParsingTokens_1 = CoreParsingTokens;

    var CoreParsingFormats = [
      {
        // 12-1978
        // 08-1978 (MDY)
        src: '{MM}[-.\\/]{yyyy}'
      },
      {
        // 12/08/1978
        // 08/12/1978 (MDY)
        time: true,
        src: '{dd}[-\\/]{MM}(?:[-\\/]{yyyy|yy|y})?',
        mdy: '{MM}[-\\/]{dd}(?:[-\\/]{yyyy|yy|y})?'
      },
      {
        // 12.08.1978
        // 08.12.1978 (MDY)
        time: true,
        src: '{dd}\\.{MM}(?:\\.{yyyy|yy|y})?',
        mdy: '{MM}\\.{dd}(?:\\.{yyyy|yy|y})?',
        localeCheck: function(loc) {
          // Do not allow this format if the locale
          // uses a period as a time separator.
          return loc.timeSeparator !== '.';
        }
      },
      {
        // 1975-08-25
        time: true,
        src: '{yyyy}[-.\\/]{MM}(?:[-.\\/]{dd})?'
      },
      {
        // .NET JSON
        src: '\\\\/Date\\({timestamp}(?:[-+]\\d{4,4})?\\)\\\\/'
      },
      {
        // ISO-8601
        src: '{iyyyy}(?:-?{MM}(?:-?{dd}(?:T{ihh}(?::?{imm}(?::?{ss})?)?)?)?)?{tzOffset?}'
      }
    ];

    var CoreParsingFormats_1 = CoreParsingFormats;

    var LocalizedParsingTokens = {
      'year': {
        base: 'yyyy|ayy',
        requiresSuffix: true
      },
      'month': {
        base: 'MM',
        requiresSuffix: true
      },
      'date': {
        base: 'dd',
        requiresSuffix: true
      },
      'hour': {
        base: 'hh',
        requiresSuffixOr: ':'
      },
      'minute': {
        base: 'mm'
      },
      'second': {
        base: 'ss'
      },
      'num': {
        src: '\\d+',
        requiresNumerals: true
      }
    };

    var LocalizedParsingTokens_1 = LocalizedParsingTokens;

    function getArrayWithOffset(arr, n, alternate, offset) {
      var val;
      if (alternate > 1) {
        val = arr[n + (alternate - 1) * offset];
      }
      return val || arr[n];
    }

    var getArrayWithOffset_1 = getArrayWithOffset;

    function getRegNonCapturing(src, opt) {
      if (src.length > 1) {
        src = '(?:' + src + ')';
      }
      if (opt) {
        src += '?';
      }
      return src;
    }

    var getRegNonCapturing_1 = getRegNonCapturing;

    var PRIVATE_PROP_PREFIX = '_sugar_';

    var setProperty$1 = coreUtilityAliases.setProperty;

    function privatePropertyAccessor(key) {
      var privateKey = PRIVATE_PROP_PREFIX + key;
      return function(obj, val) {
        if (arguments.length > 1) {
          setProperty$1(obj, privateKey, val);
          return obj;
        }
        return obj[privateKey];
      };
    }

    var privatePropertyAccessor_1 = privatePropertyAccessor;

    var _utc = privatePropertyAccessor_1('utc');

    function callDateGet(d, method) {
      return d['get' + (_utc(d) ? 'UTC' : '') + method]();
    }

    var callDateGet_1 = callDateGet;

    function getYear(d) {
      return callDateGet_1(d, 'FullYear');
    }

    var getYear_1 = getYear;

    function getMonth(d) {
      return callDateGet_1(d, 'Month');
    }

    var getMonth_1 = getMonth;

    function getDaysInMonth(d) {
      return 32 - callDateGet_1(new Date(getYear_1(d), getMonth_1(d), 32), 'Date');
    }

    var getDaysInMonth_1 = getDaysInMonth;

    var DateUnits = [
      {
        name: 'millisecond',
        method: 'Milliseconds',
        multiplier: 1,
        start: 0,
        end: 999
      },
      {
        name: 'second',
        method: 'Seconds',
        multiplier: 1000,
        start: 0,
        end: 59
      },
      {
        name: 'minute',
        method: 'Minutes',
        multiplier: 60 * 1000,
        start: 0,
        end: 59
      },
      {
        name: 'hour',
        method: 'Hours',
        multiplier: 60 * 60 * 1000,
        start: 0,
        end: 23
      },
      {
        name: 'day',
        alias: 'date',
        method: 'Date',
        ambiguous: true,
        multiplier: 24 * 60 * 60 * 1000,
        start: 1,
        end: function(d) {
          return getDaysInMonth_1(d);
        }
      },
      {
        name: 'week',
        method: 'ISOWeek',
        ambiguous: true,
        multiplier: 7 * 24 * 60 * 60 * 1000
      },
      {
        name: 'month',
        method: 'Month',
        ambiguous: true,
        multiplier: 30.4375 * 24 * 60 * 60 * 1000,
        start: 0,
        end: 11
      },
      {
        name: 'year',
        method: 'FullYear',
        ambiguous: true,
        multiplier: 365.25 * 24 * 60 * 60 * 1000,
        start: 0
      }
    ];

    var DateUnits_1 = DateUnits;

    var DateUnitIndexes = {
      HOURS_INDEX: 3,
      DAY_INDEX: 4,
      WEEK_INDEX: 5,
      MONTH_INDEX: 6,
      YEAR_INDEX: 7
    };

    var YEAR_INDEX = DateUnitIndexes.YEAR_INDEX;

    function iterateOverDateUnits(fn, startIndex, endIndex) {
      endIndex = endIndex || 0;
      if (isUndefined_1(startIndex)) {
        startIndex = YEAR_INDEX;
      }
      for (var index = startIndex; index >= endIndex; index--) {
        if (fn(DateUnits_1[index], index) === false) {
          break;
        }
      }
    }

    var iterateOverDateUnits_1 = iterateOverDateUnits;

    function arrayToRegAlternates(arr) {
      var joined = arr.join('');
      if (!arr || !arr.length) {
        return '';
      }
      if (joined.length === arr.length) {
        return '[' + joined + ']';
      }
      // map handles sparse arrays so no need to compact the array here.
      return map_1(arr, escapeRegExp_1).join('|');
    }

    var arrayToRegAlternates_1 = arrayToRegAlternates;

    var abs$5 = mathAliases.abs;

    function getAdjustedUnit(ms, fn) {
      var unitIndex = 0, value = 0;
      iterateOverDateUnits_1(function(unit, i) {
        value = abs$5(fn(unit));
        if (value >= 1) {
          unitIndex = i;
          return false;
        }
      });
      return [value, unitIndex, ms];
    }

    var getAdjustedUnit_1 = getAdjustedUnit;

    function getAdjustedUnitForNumber(ms) {
      return getAdjustedUnit_1(ms, function(unit) {
        return trunc_1(withPrecision_1(ms / unit.multiplier, 1));
      });
    }

    var getAdjustedUnitForNumber_1 = getAdjustedUnitForNumber;

    function getParsingTokenWithSuffix(field, src, suffix) {
      var token = LocalizedParsingTokens_1[field];
      if (token.requiresSuffix) {
        src = getRegNonCapturing_1(src + getRegNonCapturing_1(suffix));
      } else if (token.requiresSuffixOr) {
        src += getRegNonCapturing_1(token.requiresSuffixOr + '|' + suffix);
      } else {
        src += getRegNonCapturing_1(suffix, true);
      }
      return src;
    }

    var getParsingTokenWithSuffix_1 = getParsingTokenWithSuffix;

    var map$3 = map_1;

    var hasOwn$9 = coreUtilityAliases.hasOwn,
        getOwn$8 = coreUtilityAliases.getOwn,
        forEachProperty$l = coreUtilityAliases.forEachProperty,
        fullWidthNumberMap$2 = fullwidthNumberHelpers.fullWidthNumberMap,
        fullWidthNumbers$1 = fullwidthNumberHelpers.fullWidthNumbers,
        pow$3 = mathAliases.pow,
        max$9 = mathAliases.max,
        ISO_FIRST_DAY_OF_WEEK = ISODefaults.ISO_FIRST_DAY_OF_WEEK,
        ISO_FIRST_DAY_OF_WEEK_YEAR = ISODefaults.ISO_FIRST_DAY_OF_WEEK_YEAR,
        isString$e = classChecks.isString,
        isFunction$b = classChecks.isFunction;

    function getNewLocale(def) {

      function Locale(def) {
        this.init(def);
      }

      Locale.prototype = {

        getMonthName: function(n, alternate) {
          if (this.monthSuffix) {
            return (n + 1) + this.monthSuffix;
          }
          return getArrayWithOffset_1(this.months, n, alternate, 12);
        },

        getWeekdayName: function(n, alternate) {
          return getArrayWithOffset_1(this.weekdays, n, alternate, 7);
        },

        // TODO: rename to parse in next major version
        parseValue: function(str, param) {
          var map = this[param + 'Map'];
          if (hasOwn$9(map, str)) {
            return map[str];
          }
          return this.parseNumber(str, param);
        },

        // TODO: analyze performance of parsing first vs checking
        // numeralMap first.
        parseNumber: function(str, param) {
          var val;

          // Simple numerals such as "one" are mapped directly in
          // the numeral map so catch up front if there is a match.
          if (hasOwn$9(this.numeralMap, str)) {
            val = this.numeralMap[str];
          }

          // TODO: perf test isNaN vs other methods
          if (isNaN(val)) {
            val = this.parseRegularNumerals(str);
          }

          if (isNaN(val)) {
            val = this.parseIrregularNumerals(str);
          }

          if (param === 'month') {
            // Months are the only numeric date field
            // whose value is not the same as its number.
            val -= 1;
          }

          return val;
        },

        // TODO: perf test returning up front if no regular decimals exist
        parseRegularNumerals: function(str) {
          // Allow decimals as commas and the minus-sign as per ISO-8601.
          str = str.replace(/^−/, '-').replace(/,/, '.');

          // The unary plus operator here shows better performance and handles
          // every format that parseFloat does with the exception of trailing
          // characters, which are guaranteed not to be in our string at this point.
          return +str;
        },

        parseIrregularNumerals: function(str) {
          var place = 1, num = 0, lastWasPlace, isPlace, numeral, digit, arr;

          // Note that "numerals" that need to be converted through this method are
          // all considered to be single characters in order to handle CJK. This
          // method is by no means unique to CJK, but the complexity of handling
          // inflections in non-CJK languages adds too much overhead for not enough
          // value, so avoiding for now.
          arr = str.split('');
          for (var i = arr.length - 1; numeral = arr[i]; i--) {
            digit = getOwn$8(this.numeralMap, numeral);
            if (isUndefined_1(digit)) {
              digit = getOwn$8(fullWidthNumberMap$2, numeral) || 0;
            }
            isPlace = digit > 0 && digit % 10 === 0;
            if (isPlace) {
              if (lastWasPlace) {
                num += place;
              }
              if (i) {
                place = digit;
              } else {
                num += digit;
              }
            } else {
              num += digit * place;
              place *= 10;
            }
            lastWasPlace = isPlace;
          }
          return num;
        },

        getOrdinal: function(n) {
          var suffix = this.ordinalSuffix;
          return suffix || getOrdinalSuffix_1(n);
        },

        getRelativeFormat: function(adu, type) {
          return this.convertAdjustedToFormat(adu, type);
        },

        getDuration: function(ms) {
          return this.convertAdjustedToFormat(getAdjustedUnitForNumber_1(max$9(0, ms)), 'duration');
        },

        getFirstDayOfWeek: function() {
          var val = this.firstDayOfWeek;
          return isDefined_1(val) ? val : ISO_FIRST_DAY_OF_WEEK;
        },

        getFirstDayOfWeekYear: function() {
          return this.firstDayOfWeekYear || ISO_FIRST_DAY_OF_WEEK_YEAR;
        },

        convertAdjustedToFormat: function(adu, type) {
          var sign, unit, mult,
              num    = adu[0],
              u      = adu[1],
              ms     = adu[2],
              format = this[type] || this.relative;
          if (isFunction$b(format)) {
            return format.call(this, num, u, ms, type);
          }
          mult = !this.plural || num === 1 ? 0 : 1;
          unit = this.units[mult * 8 + u] || this.units[u];
          sign = this[ms > 0 ? 'fromNow' : 'ago'];
          return format.replace(/\{(.*?)\}/g, function(full, match) {
            switch(match) {
              case 'num': return num;
              case 'unit': return unit;
              case 'sign': return sign;
            }
          });
        },

        cacheFormat: function(dif, i) {
          this.compiledFormats.splice(i, 1);
          this.compiledFormats.unshift(dif);
        },

        addFormat: function(format) {
          var loc = this, src, to;

          function getTokenSrc(token) {
            var suffix, src, tmp,
                opt   = token.match(/\?$/),
                nc    = token.match(/^(\d+)\??$/),
                slice = token.match(/(\d)(?:-(\d))?/),
                param = token.replace(/[^a-z]+$/i, '');

            // Allowing alias tokens such as {time}
            if (tmp = getOwn$8(loc.parsingAliases, param)) {
              src = formatToSrc(tmp);
              if (opt) {
                src = getRegNonCapturing_1(src, true);
              }
              return src;
            }

            if (nc) {
              src = loc.tokens[nc[1]];
            } else if (tmp = getOwn$8(CoreParsingTokens_1, param)) {
              src = tmp.src;
              param = tmp.param || param;
            } else {
              tmp = getOwn$8(loc.parsingTokens, param) || getOwn$8(loc, param);

              // Both the "months" array and the "month" parsing token can be accessed
              // by either {month} or {months}, falling back as necessary, however
              // regardless of whether or not a fallback occurs, the final field to
              // be passed to addRawFormat must be normalized as singular.
              param = param.replace(/s$/, '');

              if (!tmp) {
                tmp = getOwn$8(loc.parsingTokens, param) || getOwn$8(loc, param + 's');
              }

              if (isString$e(tmp)) {
                src = tmp;
                suffix = loc[param + 'Suffix'];
              } else {

                // This is a hack to temporarily disallow parsing of single character
                // weekdays until the format can be changed to allow for this.
                if (param === 'weekday' && loc.code === 'ko') {
                  tmp = filter_1(tmp, function(str) {
                    return str.length > 1;
                  });
                }

                if (slice) {
                  tmp = filter_1(tmp, function(m, i) {
                    var mod = i % (loc.units ? 8 : tmp.length);
                    return mod >= slice[1] && mod <= (slice[2] || slice[1]);
                  });
                }
                src = arrayToRegAlternates_1(tmp);
              }
            }
            if (!src) {
              return '';
            }
            if (nc) {
              // Non-capturing tokens like {0}
              src = getRegNonCapturing_1(src);
            } else {
              // Capturing group and add to parsed tokens
              to.push(param);
              src = '(' + src + ')';
            }
            if (suffix) {
              // Date/time suffixes such as those in CJK
              src = getParsingTokenWithSuffix_1(param, src, suffix);
            }
            if (opt) {
              src += '?';
            }
            return src;
          }

          function formatToSrc(str) {

            // Make spaces optional
            str = str.replace(/ /g, ' ?');

            str = str.replace(/\{([^,]+?)\}/g, function(match, token) {
              var tokens = token.split('|');
              if (tokens.length > 1) {
                return getRegNonCapturing_1(map$3(tokens, getTokenSrc).join('|'));
              } else {
                return getTokenSrc(token);
              }
            });

            return str;
          }

          function parseInputFormat() {
            to = [];
            src = formatToSrc(format);
          }

          parseInputFormat();
          loc.addRawFormat(src, to);
        },

        addRawFormat: function(format, to) {
          this.compiledFormats.unshift({
            reg: RegExp('^ *' + format + ' *$', 'i'),
            to: to
          });
        },

        init: function(def) {
          var loc = this;

          // -- Initialization helpers

          function initFormats() {
            loc.compiledFormats = [];
            loc.parsingAliases = {};
            loc.parsingTokens = {};
          }

          function initDefinition() {
            simpleMerge_1(loc, def);
          }

          function initArrayFields() {
            forEach_1(LOCALE_ARRAY_FIELDS_1, function(name) {
              var val = loc[name];
              if (isString$e(val)) {
                loc[name] = commaSplit_1(val);
              } else if (!val) {
                loc[name] = [];
              }
            });
          }

          // -- Value array build helpers

          function buildValueArray(name, mod, map, fn) {
            var field = name, all = [], setMap;
            if (!loc[field]) {
              field += 's';
            }
            if (!map) {
              map = {};
              setMap = true;
            }
            forAllAlternates(field, function(alt, j, i) {
              var idx = j * mod + i, val;
              val = fn ? fn(i) : i;
              map[alt] = val;
              map[alt.toLowerCase()] = val;
              all[idx] = alt;
            });
            loc[field] = all;
            if (setMap) {
              loc[name + 'Map'] = map;
            }
          }

          function forAllAlternates(field, fn) {
            forEach_1(loc[field], function(str, i) {
              forEachAlternate(str, function(alt, j) {
                fn(alt, j, i);
              });
            });
          }

          function forEachAlternate(str, fn) {
            var arr = map$3(str.split('+'), function(split) {
              return split.replace(/(.+):(.+)$/, function(full, base, suffixes) {
                return map$3(suffixes.split('|'), function(suffix) {
                  return base + suffix;
                }).join('|');
              });
            }).join('|');
            forEach_1(arr.split('|'), fn);
          }

          function buildNumerals() {
            var map = {};
            buildValueArray('numeral', 10, map);
            buildValueArray('article', 1, map, function() {
              return 1;
            });
            buildValueArray('placeholder', 4, map, function(n) {
              return pow$3(10, n + 1);
            });
            loc.numeralMap = map;
          }

          function buildTimeFormats() {
            loc.parsingAliases['time'] = getTimeFormat();
            loc.parsingAliases['tzOffset'] = getTZOffsetFormat();
          }

          function getTimeFormat(standalone) {
            var src, sep;
            sep = getTimeSeparatorSrc();
            if (loc.ampmFront) {
              // "ampmFront" exists mostly for CJK locales, which also presume that
              // time suffixes exist, allowing this to be a simpler regex.
              src = '{ampm?} {hour} (?:{minute} (?::?{second})?)?';
            } else if(loc.ampm.length) {
              src = '{hour}(?:'+sep+'{minute?}(?:'+sep+'{second?})? {ampm?}| {ampm})';
            } else {
              src = '{hour}(?:'+sep+'{minute?}(?:'+sep+'{second?})?)';
            }
            return src;
          }

          function getTimeSeparatorSrc() {
            if (loc.timeSeparator) {
              return '[:' + loc.timeSeparator + ']';
            } else {
              return ':';
            }
          }

          function getTZOffsetFormat() {
            return '(?:{Z}|{GMT?}(?:{tzHour}(?::?{tzMinute}(?: \\([\\w\\s]+\\))?)?)?)?';
          }

          function buildParsingTokens() {
            forEachProperty$l(LocalizedParsingTokens_1, function(token, name) {
              var src = token.base ? getCoreTokensForBase(token.base) : token.src, arr;
              if (token.requiresNumerals || loc.numeralUnits) {
                src += getNumeralSrc();
              }
              arr = loc[name + 's'];
              if (arr && arr.length) {
                src += '|' + arrayToRegAlternates_1(arr);
              }
              loc.parsingTokens[name] = src;
            });
          }

          function getCoreTokensForBase(base) {
            return map$3(base.split('|'), function(key) {
              return CoreParsingTokens_1[key].src;
            }).join('|');
          }

          function getNumeralSrc() {
            var all, src = '';
            all = loc.numerals.concat(loc.placeholders).concat(loc.articles);
            if (loc.allowsFullWidth) {
              all = all.concat(fullWidthNumbers$1.split(''));
            }
            if (all.length) {
              src = '|(?:' + arrayToRegAlternates_1(all) + ')+';
            }
            return src;
          }

          function buildTimeSuffixes() {
            iterateOverDateUnits_1(function(unit, i) {
              var token = loc.timeSuffixes[i];
              if (token) {
                loc[(unit.alias || unit.name) + 'Suffix'] = token;
              }
            });
          }

          function buildModifiers() {
            forEach_1(loc.modifiers, function(modifier) {
              var name = modifier.name, mapKey = name + 'Map', map;
              map = loc[mapKey] || {};
              forEachAlternate(modifier.src, function(alt, j) {
                var token = getOwn$8(loc.parsingTokens, name), val = modifier.value;
                map[alt] = val;
                loc.parsingTokens[name] = token ? token + '|' + alt : alt;
                if (modifier.name === 'sign' && j === 0) {
                  // Hooking in here to set the first "fromNow" or "ago" modifier
                  // directly on the locale, so that it can be reused in the
                  // relative format.
                  loc[val === 1 ? 'fromNow' : 'ago'] = alt;
                }
              });
              loc[mapKey] = map;
            });
          }

          // -- Format adding helpers

          function addCoreFormats() {
            forEach_1(CoreParsingFormats_1, function(df) {
              var src = df.src;
              if (df.localeCheck && !df.localeCheck(loc)) {
                return;
              }
              if (df.mdy && loc.mdy) {
                // Use the mm/dd/yyyy variant if it
                // exists and the locale requires it
                src = df.mdy;
              }
              if (df.time) {
                // Core formats that allow time require the time
                // reg on both sides, so add both versions here.
                loc.addFormat(getFormatWithTime(src, true));
                loc.addFormat(getFormatWithTime(src));
              } else {
                loc.addFormat(src);
              }
            });
            loc.addFormat('{time}');
          }

          function addLocaleFormats() {
            addFormatSet('parse');
            addFormatSet('timeParse', true);
            addFormatSet('timeFrontParse', true, true);
          }

          function addFormatSet(field, allowTime, timeFront) {
            forEach_1(loc[field], function(format) {
              if (allowTime) {
                format = getFormatWithTime(format, timeFront);
              }
              loc.addFormat(format);
            });
          }

          function getFormatWithTime(baseFormat, timeBefore) {
            if (timeBefore) {
              return getTimeBefore() + baseFormat;
            }
            return baseFormat + getTimeAfter();
          }

          function getTimeBefore() {
            return getRegNonCapturing_1('{time}[,\\s\\u3000]', true);
          }

          function getTimeAfter() {
            var markers = ',?[\\s\\u3000]', localized;
            localized = arrayToRegAlternates_1(loc.timeMarkers);
            if (localized) {
              markers += '| (?:' + localized + ') ';
            }
            markers = getRegNonCapturing_1(markers, loc.timeMarkerOptional);
            return getRegNonCapturing_1(markers + '{time}{tzOffset}', true);
          }

          initFormats();
          initDefinition();
          initArrayFields();

          buildValueArray('month', 12);
          buildValueArray('weekday', 7);
          buildValueArray('unit', 8);
          buildValueArray('ampm', 2);

          buildNumerals();
          buildTimeFormats();
          buildParsingTokens();
          buildTimeSuffixes();
          buildModifiers();

          // The order of these formats is important. Order is reversed so formats
          // that are initialized later will take precedence. Generally, this means
          // that more specific formats should come later.
          addCoreFormats();
          addLocaleFormats();

        }

      };

      return new Locale(def);
    }

    var getNewLocale_1 = getNewLocale;

    var English, localeManager;

    function buildLocales() {

      function LocaleManager(loc) {
        this.locales = {};
        this.add(loc);
      }

      LocaleManager.prototype = {

        get: function(code, fallback) {
          var loc = this.locales[code];
          if (!loc && LazyLoadedLocales_1[code]) {
            loc = this.add(code, LazyLoadedLocales_1[code]);
          } else if (!loc && code) {
            loc = this.locales[code.slice(0, 2)];
          }
          return loc || fallback === false ? loc : this.current;
        },

        getAll: function() {
          return this.locales;
        },

        set: function(code) {
          var loc = this.get(code, false);
          if (!loc) {
            throw new TypeError('Invalid Locale: ' + code);
          }
          return this.current = loc;
        },

        add: function(code, def) {
          if (!def) {
            def = code;
            code = def.code;
          } else {
            def.code = code;
          }
          var loc = def.compiledFormats ? def : getNewLocale_1(def);
          this.locales[code] = loc;
          if (!this.current) {
            this.current = loc;
          }
          return loc;
        },

        remove: function(code) {
          if (this.current.code === code) {
            this.current = this.get('en');
          }
          return delete this.locales[code];
        }

      };

      // Sorry about this guys...
      English = getNewLocale_1(AmericanEnglishDefinition_1);
      localeManager = new LocaleManager(English);
    }

    buildLocales();

    var LocaleHelpers = {
      English: English,
      localeManager: localeManager
    };

    var localeManager$1 = LocaleHelpers.localeManager;

    sugarCore.Date.defineStatic({

      'addLocale': function(code, set) {
        return localeManager$1.add(code, set);
      }

    });

    var addLocale = sugarCore.Date.addLocale;

    var MINUTES = 60 * 1000;

    var ABBREVIATED_YEAR_REG = /^'?(\d{1,2})$/;

    function tzOffset(d) {
      return d.getTimezoneOffset();
    }

    var tzOffset_1 = tzOffset;

    function callDateSet(d, method, value, safe) {
      // "Safe" denotes not setting the date if the value is the same as what is
      // currently set. In theory this should be a noop, however it will cause
      // timezone shifts when in the middle of a DST fallback. This is unavoidable
      // as the notation itself is ambiguous (i.e. there are two "1:00ams" on
      // November 1st, 2015 in northern hemisphere timezones that follow DST),
      // however when advancing or rewinding dates this can throw off calculations
      // so avoiding this unintentional shifting on an opt-in basis.
      if (safe && value === callDateGet_1(d, method)) {
        return;
      }
      d['set' + (_utc(d) ? 'UTC' : '') + method](value);
    }

    var callDateSet_1 = callDateSet;

    var HOURS_INDEX = DateUnitIndexes.HOURS_INDEX,
        DAY_INDEX = DateUnitIndexes.DAY_INDEX,
        WEEK_INDEX = DateUnitIndexes.WEEK_INDEX,
        MONTH_INDEX = DateUnitIndexes.MONTH_INDEX;

    function getLowerUnitIndex(index) {
      if (index === MONTH_INDEX) {
        return DAY_INDEX;
      } else if (index === WEEK_INDEX) {
        return HOURS_INDEX;
      }
      return index - 1;
    }

    var getLowerUnitIndex_1 = getLowerUnitIndex;

    function walkUnitDown(unitIndex, fn) {
      while (unitIndex >= 0) {
        if (fn(DateUnits_1[unitIndex], unitIndex) === false) {
          break;
        }
        unitIndex = getLowerUnitIndex_1(unitIndex);
      }
    }

    var walkUnitDown_1 = walkUnitDown;

    var isFunction$c = classChecks.isFunction;

    function setUnitAndLowerToEdge(d, startIndex, stopIndex, end) {
      walkUnitDown_1(startIndex, function(unit, i) {
        var val = end ? unit.end : unit.start;
        if (isFunction$c(val)) {
          val = val(d);
        }
        callDateSet_1(d, unit.method, val);
        return !isDefined_1(stopIndex) || i > stopIndex;
      });
      return d;
    }

    var setUnitAndLowerToEdge_1 = setUnitAndLowerToEdge;

    var HOURS_INDEX$1 = DateUnitIndexes.HOURS_INDEX;

    function resetTime(d) {
      return setUnitAndLowerToEdge_1(d, HOURS_INDEX$1);
    }

    var resetTime_1 = resetTime;

    function defaultNewDate() {
      return new Date;
    }

    var defaultNewDate_1 = defaultNewDate;

    var DATE_OPTIONS = {
      'newDateInternal': defaultNewDate_1
    };

    var DATE_OPTIONS_1 = DATE_OPTIONS;

    var sugarDate = namespaceAliases.sugarDate;

    var _dateOptions = defineOptionsAccessor_1(sugarDate, DATE_OPTIONS_1);

    function getNewDate() {
      return _dateOptions('newDateInternal')();
    }

    var getNewDate_1 = getNewDate;

    function setDate(d, val) {
      callDateSet_1(d, 'Date', val);
    }

    var setDate_1 = setDate;

    function getDate(d) {
      return callDateGet_1(d, 'Date');
    }

    var getDate_1 = getDate;

    function getWeekday(d) {
      return callDateGet_1(d, 'Day');
    }

    var getWeekday_1 = getWeekday;

    var isNumber$5 = classChecks.isNumber,
        abs$6 = mathAliases.abs;

    function setWeekday(d, dow, dir) {
      if (!isNumber$5(dow)) return;
      var currentWeekday = getWeekday_1(d);
      if (dir) {
        // Allow a "direction" parameter to determine whether a weekday can
        // be set beyond the current weekday in either direction.
        var ndir = dir > 0 ? 1 : -1;
        var offset = dow % 7 - currentWeekday;
        if (offset && offset / abs$6(offset) !== ndir) {
          dow += 7 * ndir;
        }
      }
      setDate_1(d, getDate_1(d) + dow - currentWeekday);
      return d.getTime();
    }

    var setWeekday_1 = setWeekday;

    function resetLowerUnits(d, unitIndex) {
      return setUnitAndLowerToEdge_1(d, getLowerUnitIndex_1(unitIndex));
    }

    var resetLowerUnits_1 = resetLowerUnits;

    var DAY_INDEX$1 = DateUnitIndexes.DAY_INDEX,
        MONTH_INDEX$1 = DateUnitIndexes.MONTH_INDEX;

    function getHigherUnitIndex(index) {
      return index === DAY_INDEX$1 ? MONTH_INDEX$1 : index + 1;
    }

    var getHigherUnitIndex_1 = getHigherUnitIndex;

    function setYear(d, val) {
      callDateSet_1(d, 'FullYear', val);
    }

    var setYear_1 = setYear;

    function setMonth(d, val) {
      callDateSet_1(d, 'Month', val);
    }

    var setMonth_1 = setMonth;

    function cloneDate(d) {
      // Rhino environments have a bug where new Date(d) truncates
      // milliseconds so need to call getTime() here.
      var clone = new Date(d.getTime());
      _utc(clone, !!_utc(d));
      return clone;
    }

    var cloneDate_1 = cloneDate;

    var floor$5 = mathAliases.floor;

    function moveToBeginningOfWeek(d, firstDayOfWeek) {
      setWeekday_1(d, floor$5((getWeekday_1(d) - firstDayOfWeek) / 7) * 7 + firstDayOfWeek);
      return d;
    }

    var moveToBeginningOfWeek_1 = moveToBeginningOfWeek;

    var MONTH_INDEX$2 = DateUnitIndexes.MONTH_INDEX;

    function moveToFirstDayOfWeekYear(d, firstDayOfWeek, firstDayOfWeekYear) {
      setUnitAndLowerToEdge_1(d, MONTH_INDEX$2);
      setDate_1(d, firstDayOfWeekYear);
      moveToBeginningOfWeek_1(d, firstDayOfWeek);
    }

    var moveToFirstDayOfWeekYear_1 = moveToFirstDayOfWeekYear;

    var isNumber$6 = classChecks.isNumber,
        ISO_FIRST_DAY_OF_WEEK$1 = ISODefaults.ISO_FIRST_DAY_OF_WEEK,
        ISO_FIRST_DAY_OF_WEEK_YEAR$1 = ISODefaults.ISO_FIRST_DAY_OF_WEEK_YEAR;

    function setISOWeekNumber(d, num) {
      if (isNumber$6(num)) {
        // Intentionally avoiding updateDate here to prevent circular dependencies.
        var isoWeek = cloneDate_1(d), dow = getWeekday_1(d);
        moveToFirstDayOfWeekYear_1(isoWeek, ISO_FIRST_DAY_OF_WEEK$1, ISO_FIRST_DAY_OF_WEEK_YEAR$1);
        setDate_1(isoWeek, getDate_1(isoWeek) + 7 * (num - 1));
        setYear_1(d, getYear_1(isoWeek));
        setMonth_1(d, getMonth_1(isoWeek));
        setDate_1(d, getDate_1(isoWeek));
        setWeekday_1(d, dow || 7);
      }
      return d.getTime();
    }

    var setISOWeekNumber_1 = setISOWeekNumber;

    function callDateSetWithWeek(d, method, value, safe) {
      if (method === 'ISOWeek') {
        setISOWeekNumber_1(d, value);
      } else {
        callDateSet_1(d, method, value, safe);
      }
    }

    var callDateSetWithWeek_1 = callDateSetWithWeek;

    var hasOwn$a = coreUtilityAliases.hasOwn;

    function getOwnKey(obj, key) {
      if (hasOwn$a(obj, key)) {
        return key;
      }
    }

    var getOwnKey_1 = getOwnKey;

    function getDateParamKey(params, key) {
      return getOwnKey_1(params, key) ||
             getOwnKey_1(params, key + 's') ||
             (key === 'day' && getOwnKey_1(params, 'date'));
    }

    var getDateParamKey_1 = getDateParamKey;

    var getOwn$9 = coreUtilityAliases.getOwn;

    function getDateParam(params, key) {
      return getOwn$9(params, getDateParamKey_1(params, key));
    }

    var getDateParam_1 = getDateParam;

    var DAY_INDEX$2 = DateUnitIndexes.DAY_INDEX;

    function iterateOverDateParams(params, fn, startIndex, endIndex) {

      function run(name, unit, i) {
        var val = getDateParam_1(params, name);
        if (isDefined_1(val)) {
          fn(name, val, unit, i);
        }
      }

      iterateOverDateUnits_1(function (unit, i) {
        var result = run(unit.name, unit, i);
        if (result !== false && i === DAY_INDEX$2) {
          // Check for "weekday", which has a distinct meaning
          // in the context of setting a date, but has the same
          // meaning as "day" as a unit of time.
          result = run('weekday', unit, i);
        }
        return result;
      }, startIndex, endIndex);

    }

    var iterateOverDateParams_1 = iterateOverDateParams;

    var DAY_INDEX$3 = DateUnitIndexes.DAY_INDEX,
        WEEK_INDEX$1 = DateUnitIndexes.WEEK_INDEX,
        MONTH_INDEX$3 = DateUnitIndexes.MONTH_INDEX,
        YEAR_INDEX$1 = DateUnitIndexes.YEAR_INDEX,
        round$2 = mathAliases.round,
        isNumber$7 = classChecks.isNumber;

    function updateDate(d, params, reset, advance, prefer, weekdayDir, contextDate) {
      var upperUnitIndex;

      function setUpperUnit(unitName, unitIndex) {
        if (prefer && !upperUnitIndex) {
          if (unitName === 'weekday') {
            upperUnitIndex = WEEK_INDEX$1;
          } else {
            upperUnitIndex = getHigherUnitIndex_1(unitIndex);
          }
        }
      }

      function setSpecificity(unitIndex) {
        // Other functions may preemptively set the specificity before arriving
        // here so concede to them if they have already set more specific units.
        if (unitIndex > params.specificity) {
          return;
        }
        params.specificity = unitIndex;
      }

      function canDisambiguate() {
        if (!upperUnitIndex || upperUnitIndex > YEAR_INDEX$1) {
          return;
        }

        switch(prefer) {
          case -1: return d >= (contextDate || getNewDate_1());
          case  1: return d <= (contextDate || getNewDate_1());
        }
      }

      function disambiguateHigherUnit() {
        var unit = DateUnits_1[upperUnitIndex];
        advance = prefer;
        setUnit(unit.name, 1, unit, upperUnitIndex);
      }

      function handleFraction(unit, unitIndex, fraction) {
        if (unitIndex) {
          var lowerUnit = DateUnits_1[getLowerUnitIndex_1(unitIndex)];
          var val = round$2(unit.multiplier / lowerUnit.multiplier * fraction);
          params[lowerUnit.name] = val;
        }
      }

      function monthHasShifted(d, targetMonth) {
        if (targetMonth < 0) {
          targetMonth = targetMonth % 12 + 12;
        }
        return targetMonth % 12 !== getMonth_1(d);
      }

      function setUnit(unitName, value, unit, unitIndex) {
        var method = unit.method, checkMonth, fraction;

        setUpperUnit(unitName, unitIndex);
        setSpecificity(unitIndex);

        fraction = value % 1;
        if (fraction) {
          handleFraction(unit, unitIndex, fraction);
          value = trunc_1(value);
        }

        if (unitName === 'weekday') {
          if (!advance) {
            // Weekdays are always considered absolute units so simply set them
            // here even if it is an "advance" operation. This is to help avoid
            // ambiguous meanings in "advance" as well as to neatly allow formats
            // like "Wednesday of next week" without more complex logic.
            setWeekday_1(d, value, weekdayDir);
          }
          return;
        }
        checkMonth = unitIndex === MONTH_INDEX$3 && getDate_1(d) > 28;

        // If we are advancing or rewinding, then we need we need to set the
        // absolute time if the unit is "hours" or less. This is due to the fact
        // that setting by method is ambiguous during DST shifts. For example,
        // 1:00am on November 1st 2015 occurs twice in North American timezones
        // with DST, the second time being after the clocks are rolled back at
        // 2:00am. When springing forward this is automatically handled as there
        // is no 2:00am so the date automatically jumps to 3:00am. However, when
        // rolling back, setHours(2) will always choose the first "2am" even if
        // the date is currently set to the second, causing unintended jumps.
        // This ambiguity is unavoidable when setting dates as the notation is
        // ambiguous. However when advancing, we clearly want the resulting date
        // to be an acutal hour ahead, which can only be accomplished by setting
        // the absolute time. Conversely, any unit higher than "hours" MUST use
        // the internal set methods, as they are ambiguous as absolute units of
        // time. Years may be 365 or 366 days depending on leap years, months are
        // all over the place, and even days may be 23-25 hours depending on DST
        // shifts. Finally, note that the kind of jumping described above will
        // occur when calling ANY "set" method on the date and will occur even if
        // the value being set is identical to the one currently set (i.e.
        // setHours(2) on a date at 2am may not be a noop). This is precarious,
        // so avoiding this situation in callDateSet by checking up front that
        // the value is not the same before setting.
        if (advance && !unit.ambiguous) {
          d.setTime(d.getTime() + (value * advance * unit.multiplier));
          return;
        } else if (advance) {
          if (unitIndex === WEEK_INDEX$1) {
            value *= 7;
            method = DateUnits_1[DAY_INDEX$3].method;
          }
          value = (value * advance) + callDateGet_1(d, method);
        }
        callDateSetWithWeek_1(d, method, value, advance);
        if (checkMonth && monthHasShifted(d, value)) {
          // As we are setting the units in reverse order, there is a chance that
          // our date may accidentally traverse into a new month, such as setting
          // { month: 1, date 15 } on January 31st. Check for this here and reset
          // the date to the last day of the previous month if this has happened.
          setDate_1(d, 0);
        }
      }

      if (isNumber$7(params) && advance) {
        // If param is a number and advancing, the number is in milliseconds.
        params = { millisecond: params };
      } else if (isNumber$7(params)) {
        // Otherwise just set the timestamp and return.
        d.setTime(params);
        return d;
      }

      iterateOverDateParams_1(params, setUnit);

      if (reset && params.specificity) {
        resetLowerUnits_1(d, params.specificity);
      }

      // If past or future is preferred, then the process of "disambiguation" will
      // ensure that an ambiguous time/date ("4pm", "thursday", "June", etc.) will
      // be in the past or future. Weeks are only considered ambiguous if there is
      // a weekday, i.e. "thursday" is an ambiguous week, but "the 4th" is an
      // ambiguous month.
      if (canDisambiguate()) {
        disambiguateHigherUnit();
      }
      return d;
    }

    var updateDate_1 = updateDate;

    function advanceDate(d, unit, num, reset) {
      var set = {};
      set[unit] = num;
      return updateDate_1(d, set, reset, 1);
    }

    var advanceDate_1 = advanceDate;

    function dateIsValid(d) {
      return !isNaN(d.getTime());
    }

    var dateIsValid_1 = dateIsValid;

    var ceil$6 = mathAliases.ceil;

    function moveToEndOfWeek(d, firstDayOfWeek) {
      var target = firstDayOfWeek - 1;
      setWeekday_1(d, ceil$6((getWeekday_1(d) - target) / 7) * 7 + target);
      return d;
    }

    var moveToEndOfWeek_1 = moveToEndOfWeek;

    var WEEK_INDEX$2 = DateUnitIndexes.WEEK_INDEX,
        localeManager$2 = LocaleHelpers.localeManager;

    function moveToEndOfUnit(d, unitIndex, localeCode, stopIndex) {
      if (unitIndex === WEEK_INDEX$2) {
        moveToEndOfWeek_1(d, localeManager$2.get(localeCode).getFirstDayOfWeek());
      }
      return setUnitAndLowerToEdge_1(d, getLowerUnitIndex_1(unitIndex), stopIndex, true);
    }

    var moveToEndOfUnit_1 = moveToEndOfUnit;

    function deleteDateParam(params, key) {
      delete params[getDateParamKey_1(params, key)];
    }

    var deleteDateParam_1 = deleteDateParam;

    var WEEK_INDEX$3 = DateUnitIndexes.WEEK_INDEX,
        localeManager$3 = LocaleHelpers.localeManager;

    function moveToBeginningOfUnit(d, unitIndex, localeCode) {
      if (unitIndex === WEEK_INDEX$3) {
        moveToBeginningOfWeek_1(d, localeManager$3.get(localeCode).getFirstDayOfWeek());
      }
      return setUnitAndLowerToEdge_1(d, getLowerUnitIndex_1(unitIndex));
    }

    var moveToBeginningOfUnit_1 = moveToBeginningOfUnit;

    var abs$7 = mathAliases.abs;

    function getYearFromAbbreviation(str, d, prefer) {
      // Following IETF here, adding 1900 or 2000 depending on the last two digits.
      // Note that this makes no accordance for what should happen after 2050, but
      // intentionally ignoring this for now. https://www.ietf.org/rfc/rfc2822.txt
      var val = +str, delta;
      val += val < 50 ? 2000 : 1900;
      if (prefer) {
        delta = val - getYear_1(d);
        if (delta / abs$7(delta) !== prefer) {
          val += prefer * 100;
        }
      }
      return val;
    }

    var getYearFromAbbreviation_1 = getYearFromAbbreviation;

    var DAY_INDEX$4 = DateUnitIndexes.DAY_INDEX,
        YEAR_INDEX$2 = DateUnitIndexes.YEAR_INDEX;

    function iterateOverHigherDateParams(params, fn) {
      iterateOverDateParams_1(params, fn, YEAR_INDEX$2, DAY_INDEX$4);
    }

    var iterateOverHigherDateParams_1 = iterateOverHigherDateParams;

    var isNumber$8 = classChecks.isNumber,
        isString$f = classChecks.isString,
        isDate$7 = classChecks.isDate,
        getOwn$a = coreUtilityAliases.getOwn,
        English$1 = LocaleHelpers.English,
        localeManager$4 = LocaleHelpers.localeManager,
        DAY_INDEX$5 = DateUnitIndexes.DAY_INDEX,
        WEEK_INDEX$4 = DateUnitIndexes.WEEK_INDEX,
        MONTH_INDEX$4 = DateUnitIndexes.MONTH_INDEX,
        YEAR_INDEX$3 = DateUnitIndexes.YEAR_INDEX;

    function getExtendedDate(contextDate, d, opt, forceClone) {

      // Locals
      var date, set, loc, afterCallbacks, relative, weekdayDir;

      // Options
      var optPrefer, optLocale, optFromUTC, optSetUTC, optParams, optClone;

      afterCallbacks = [];

      setupOptions(opt);

      function setupOptions(opt) {
        opt = isString$f(opt) ? { locale: opt } : opt || {};
        optPrefer  = +!!getOwn$a(opt, 'future') - +!!getOwn$a(opt, 'past');
        optLocale  = getOwn$a(opt, 'locale');
        optFromUTC = getOwn$a(opt, 'fromUTC');
        optSetUTC  = getOwn$a(opt, 'setUTC');
        optParams  = getOwn$a(opt, 'params');
        optClone   = getOwn$a(opt, 'clone');
      }

      function parseFormatValues(match, dif) {
        var set = optParams || {};
        forEach_1(dif.to, function(param, i) {
          var str = match[i + 1], val;
          if (!str) return;

          val = parseIrregular(str, param);

          if (isUndefined_1(val)) {
            val = loc.parseValue(str, param);
          }

          set[param] = val;
        });
        return set;
      }

      function parseIrregular(str, param) {
        if (param === 'utc') {
          return 1;
        } else if (param === 'year') {
          var match = str.match(ABBREVIATED_YEAR_REG);
          if (match) {
            return getYearFromAbbreviation_1(match[1], date, optPrefer);
          }
        }
      }

      // Force the UTC flags to be true if the source date
      // date is UTC, as they will be overwritten later.
      function cloneDateByFlag(d, clone) {
        if (_utc(d) && !isDefined_1(optFromUTC)) {
          optFromUTC = true;
        }
        if (_utc(d) && !isDefined_1(optSetUTC)) {
          optSetUTC = true;
        }
        if (clone) {
          d = new Date(d.getTime());
        }
        return d;
      }

      function afterDateSet(fn) {
        afterCallbacks.push(fn);
      }

      function fireCallbacks() {
        forEach_1(afterCallbacks, function(fn) {
          fn.call();
        });
      }

      function parseStringDate(str) {

        str = str.toLowerCase();

        // The act of getting the locale will initialize
        // if it is missing and add the required formats.
        loc = localeManager$4.get(optLocale);

        for (var i = 0, dif, match; dif = loc.compiledFormats[i]; i++) {
          match = str.match(dif.reg);
          if (match) {

            // Note that caching the format will modify the compiledFormats array
            // which is not a good idea to do inside its for loop, however we
            // know at this point that we have a matched format and that we will
            // break out below, so simpler to do it here.
            loc.cacheFormat(dif, i);

            set = parseFormatValues(match, dif);

            if (isDefined_1(set.timestamp)) {
              date.setTime(set.timestamp);
              break;
            }

            if (isDefined_1(set.ampm)) {
              handleAmpm(set.ampm);
            }

            if (set.utc || isDefined_1(set.tzHour)) {
              handleTimezoneOffset(set.tzHour, set.tzMinute);
            }

            if (isDefined_1(set.shift) && isUndefined_1(set.unit)) {
              // "next january", "next monday", etc
              handleUnitlessShift();
            }

            if (isDefined_1(set.num) && isUndefined_1(set.unit)) {
              // "the second of January", etc
              handleUnitlessNum(set.num);
            }

            if (set.midday) {
              // "noon" and "midnight"
              handleMidday(set.midday);
            }

            if (isDefined_1(set.day)) {
              // Relative day localizations such as "today" and "tomorrow".
              handleRelativeDay(set.day);
            }

            if (isDefined_1(set.unit)) {
              // "3 days ago", etc
              handleRelativeUnit(set.unit);
            }

            if (set.edge) {
              // "the end of January", etc
              handleEdge(set.edge, set);
            }

            break;
          }
        }

        if (!set) {
          // TODO: remove in next major version
          // Fall back to native parsing
          date = new Date(str);
          if (optFromUTC && dateIsValid_1(date)) {
            // Falling back to system date here which cannot be parsed as UTC,
            // so if we're forcing UTC then simply add the offset.
            date.setTime(date.getTime() + (tzOffset_1(date) * MINUTES));
          }
        } else if (relative) {
          updateDate_1(date, set, false, 1);
        } else {
          updateDate_1(date, set, true, 0, optPrefer, weekdayDir, contextDate);
        }
        fireCallbacks();
        return date;
      }

      function handleAmpm(ampm) {
        if (ampm === 1 && set.hour < 12) {
          // If the time is 1pm-11pm advance the time by 12 hours.
          set.hour += 12;
        } else if (ampm === 0 && set.hour === 12) {
          // If it is 12:00am then set the hour to 0.
          set.hour = 0;
        }
      }

      function handleTimezoneOffset(tzHour, tzMinute) {
        // Adjust for timezone offset
        _utc(date, true);

        // Sign is parsed as part of the hour, so flip
        // the minutes if it's negative.

        if (tzHour < 0) {
          tzMinute *= -1;
        }

        var offset = tzHour * 60 + (tzMinute || 0);
        if (offset) {
          set.minute = (set.minute || 0) - offset;
        }
      }

      function handleUnitlessShift() {
        if (isDefined_1(set.month)) {
          // "next January"
          set.unit = YEAR_INDEX$3;
        } else if (isDefined_1(set.weekday)) {
          // "next Monday"
          set.unit = WEEK_INDEX$4;
        }
      }

      function handleUnitlessNum(num) {
        if (isDefined_1(set.weekday)) {
          // "The second Tuesday of March"
          setOrdinalWeekday(num);
        } else if (isDefined_1(set.month)) {
          // "The second of March"
          set.date = set.num;
        }
      }

      function handleMidday(hour) {
        set.hour = hour % 24;
        if (hour > 23) {
          // If the date has hours past 24, we need to prevent it from traversing
          // into a new day as that would make it being part of a new week in
          // ambiguous dates such as "Monday".
          afterDateSet(function() {
            advanceDate_1(date, 'date', trunc_1(hour / 24));
          });
        }
      }

      function handleRelativeDay() {
        resetTime_1(date);
        if (isUndefined_1(set.unit)) {
          set.unit = DAY_INDEX$5;
          set.num  = set.day;
          delete set.day;
        }
      }

      function handleRelativeUnit(unitIndex) {
        var num;

        if (isDefined_1(set.num)) {
          num = set.num;
        } else if (isDefined_1(set.edge) && isUndefined_1(set.shift)) {
          num = 0;
        } else {
          num = 1;
        }

        // If a weekday is defined, there are 3 possible formats being applied:
        //
        // 1. "the day after monday": unit is days
        // 2. "next monday": short for "next week monday", unit is weeks
        // 3. "the 2nd monday of next month": unit is months
        //
        // In the first case, we need to set the weekday up front, as the day is
        // relative to it. The second case also needs to be handled up front for
        // formats like "next monday at midnight" which will have its weekday reset
        // if not set up front. The last case will set up the params necessary to
        // shift the weekday and allow separateAbsoluteUnits below to handle setting
        // it after the date has been shifted.
        if(isDefined_1(set.weekday)) {
          if(unitIndex === MONTH_INDEX$4) {
            setOrdinalWeekday(num);
            num = 1;
          } else {
            updateDate_1(date, { weekday: set.weekday }, true);
            delete set.weekday;
          }
        }

        if (set.half) {
          // Allow localized "half" as a standalone colloquialism. Purposely avoiding
          // the locale number system to reduce complexity. The units "month" and
          // "week" are purposely excluded in the English date formats below, as
          // "half a week" and "half a month" are meaningless as exact dates.
          num *= set.half;
        }

        if (isDefined_1(set.shift)) {
          // Shift and unit, ie "next month", "last week", etc.
          num *= set.shift;
        } else if (set.sign) {
          // Unit and sign, ie "months ago", "weeks from now", etc.
          num *= set.sign;
        }

        if (isDefined_1(set.day)) {
          // "the day after tomorrow"
          num += set.day;
          delete set.day;
        }

        // Formats like "the 15th of last month" or "6:30pm of next week"
        // contain absolute units in addition to relative ones, so separate
        // them here, remove them from the params, and set up a callback to
        // set them after the relative ones have been set.
        separateAbsoluteUnits(unitIndex);

        // Finally shift the unit.
        set[English$1.units[unitIndex]] = num;
        relative = true;
      }

      function handleEdge(edge, params) {
        var edgeIndex = params.unit, weekdayOfMonth;
        if (!edgeIndex) {
          // If we have "the end of January", then we need to find the unit index.
          iterateOverHigherDateParams_1(params, function(unitName, val, unit, i) {
            if (unitName === 'weekday' && isDefined_1(params.month)) {
              // If both a month and weekday exist, then we have a format like
              // "the last tuesday in November, 2012", where the "last" is still
              // relative to the end of the month, so prevent the unit "weekday"
              // from taking over.
              return;
            }
            edgeIndex = i;
          });
        }
        if (edgeIndex === MONTH_INDEX$4 && isDefined_1(params.weekday)) {
          // If a weekday in a month exists (as described above),
          // then set it up to be set after the date has been shifted.
          weekdayOfMonth = params.weekday;
          delete params.weekday;
        }
        afterDateSet(function() {
          var stopIndex;
          // "edge" values that are at the very edge are "2" so the beginning of the
          // year is -2 and the end of the year is 2. Conversely, the "last day" is
          // actually 00:00am so it is 1. -1 is reserved but unused for now.
          if (edge < 0) {
            moveToBeginningOfUnit_1(date, edgeIndex, optLocale);
          } else if (edge > 0) {
            if (edge === 1) {
              stopIndex = DAY_INDEX$5;
              moveToBeginningOfUnit_1(date, DAY_INDEX$5);
            }
            moveToEndOfUnit_1(date, edgeIndex, optLocale, stopIndex);
          }
          if (isDefined_1(weekdayOfMonth)) {
            setWeekday_1(date, weekdayOfMonth, -edge);
            resetTime_1(date);
          }
        });
        if (edgeIndex === MONTH_INDEX$4) {
          params.specificity = DAY_INDEX$5;
        } else {
          params.specificity = edgeIndex - 1;
        }
      }

      function setOrdinalWeekday(num) {
        // If we have "the 2nd Tuesday of June", then pass the "weekdayDir"
        // flag along to updateDate so that the date does not accidentally traverse
        // into the previous month. This needs to be independent of the "prefer"
        // flag because we are only ensuring that the weekday is in the future, not
        // the entire date.
        set.weekday = 7 * (num - 1) + set.weekday;
        set.date = 1;
        weekdayDir = 1;
      }

      function separateAbsoluteUnits(unitIndex) {
        var params;

        iterateOverDateParams_1(set, function(name, val, unit, i) {
          // If there is a time unit set that is more specific than
          // the matched unit we have a string like "5:30am in 2 minutes",
          // which is meaningless, so invalidate the date...
          if (i >= unitIndex) {
            date.setTime(NaN);
            return false;
          } else if (i < unitIndex) {
            // ...otherwise set the params to set the absolute date
            // as a callback after the relative date has been set.
            params = params || {};
            params[name] = val;
            deleteDateParam_1(set, name);
          }
        });
        if (params) {
          afterDateSet(function() {
            updateDate_1(date, params, true, 0, false, weekdayDir);
            if (optParams) {
              simpleMerge_1(optParams, params);
            }
          });
          if (set.edge) {
            // "the end of March of next year"
            handleEdge(set.edge, params);
            delete set.edge;
          }
        }
      }

      if (contextDate && d) {
        // If a context date is passed ("get" and "unitsFromNow"),
        // then use it as the starting point.
        date = cloneDateByFlag(contextDate, true);
      } else {
        date = getNewDate_1();
      }

      _utc(date, optFromUTC);

      if (isString$f(d)) {
        date = parseStringDate(d);
      } else if (isDate$7(d)) {
        date = cloneDateByFlag(d, optClone || forceClone);
      } else if (isObjectType_1(d)) {
        set = simpleClone_1(d);
        updateDate_1(date, set, true);
      } else if (isNumber$8(d) || d === null) {
        date.setTime(d);
      }
      // A date created by parsing a string presumes that the format *itself* is
      // UTC, but not that the date, once created, should be manipulated as such. In
      // other words, if you are creating a date object from a server time
      // "2012-11-15T12:00:00Z", in the majority of cases you are using it to create
      // a date that will, after creation, be manipulated as local, so reset the utc
      // flag here unless "setUTC" is also set.
      _utc(date, !!optSetUTC);
      return {
        set: set,
        date: date
      };
    }

    var getExtendedDate_1 = getExtendedDate;

    function createDate(d, options, forceClone) {
      return getExtendedDate_1(null, d, options, forceClone).date;
    }

    var createDate_1 = createDate;

    var sugarDate$1 = namespaceAliases.sugarDate;

    function setDateChainableConstructor() {
      setChainableConstructor_1(sugarDate$1, createDate_1);
    }

    var setDateChainableConstructor_1 = setDateChainableConstructor;

    setDateChainableConstructor_1();

    sugarCore.Date.defineStatic({

      'create': function(d, options) {
        return createDate_1(d, options);
      }

    });

    var create$1 = sugarCore.Date.create;

    var localeManager$5 = LocaleHelpers.localeManager;

    sugarCore.Date.defineStatic({

      'getAllLocaleCodes': function() {
        return getKeys_1(localeManager$5.getAll());
      }

    });

    var getAllLocaleCodes = sugarCore.Date.getAllLocaleCodes;

    var localeManager$6 = LocaleHelpers.localeManager;

    sugarCore.Date.defineStatic({

      'getAllLocales': function() {
        return localeManager$6.getAll();
      }

    });

    var getAllLocales = sugarCore.Date.getAllLocales;

    var localeManager$7 = LocaleHelpers.localeManager;

    sugarCore.Date.defineStatic({

      'getLocale': function(code) {
        return localeManager$7.get(code, !code);
      }

    });

    var getLocale = sugarCore.Date.getLocale;

    var localeManager$8 = LocaleHelpers.localeManager;

    sugarCore.Date.defineStatic({

      'removeLocale': function(code) {
        return localeManager$8.remove(code);
      }

    });

    var removeLocale = sugarCore.Date.removeLocale;

    var localeManager$9 = LocaleHelpers.localeManager;

    sugarCore.Date.defineStatic({

      'setLocale': function(code) {
        return localeManager$9.set(code);
      }

    });

    var setLocale = sugarCore.Date.setLocale;

    var sugarNumber$2 = namespaceAliases.sugarNumber,
        round$3 = mathAliases.round;

    function buildNumberUnitMethods() {
      defineInstanceSimilar_1(sugarNumber$2, DateUnits_1, function(methods, unit) {
        var name = unit.name, base, after, before;
        base = function(n) {
          return round$3(n * unit.multiplier);
        };
        after = function(n, d, options) {
          return advanceDate_1(createDate_1(d, options, true), name, n);
        };
        before = function(n, d, options) {
          return advanceDate_1(createDate_1(d, options, true), name, -n);
        };
        methods[name] = base;
        methods[name + 's'] = base;
        methods[name + 'Before'] = before;
        methods[name + 'sBefore'] = before;
        methods[name + 'Ago'] = before;
        methods[name + 'sAgo'] = before;
        methods[name + 'After'] = after;
        methods[name + 'sAfter'] = after;
        methods[name + 'FromNow'] = after;
        methods[name + 'sFromNow'] = after;
      });
    }

    var buildNumberUnitMethods_1 = buildNumberUnitMethods;

    buildNumberUnitMethods_1();

    var day = sugarCore.Number.day;

    var dayAfter = sugarCore.Number.dayAfter;

    var dayAgo = sugarCore.Number.dayAgo;

    var dayBefore = sugarCore.Number.dayBefore;

    var dayFromNow = sugarCore.Number.dayFromNow;

    var days = sugarCore.Number.days;

    var daysAfter = sugarCore.Number.daysAfter;

    var daysAgo = sugarCore.Number.daysAgo;

    var daysBefore = sugarCore.Number.daysBefore;

    var daysFromNow = sugarCore.Number.daysFromNow;

    var localeManager$a = LocaleHelpers.localeManager;

    sugarCore.Number.defineInstance({

      'duration': function(n, localeCode) {
        return localeManager$a.get(localeCode).getDuration(n);
      }

    });

    var duration = sugarCore.Number.duration;

    var hour = sugarCore.Number.hour;

    var hourAfter = sugarCore.Number.hourAfter;

    var hourAgo = sugarCore.Number.hourAgo;

    var hourBefore = sugarCore.Number.hourBefore;

    var hourFromNow = sugarCore.Number.hourFromNow;

    var hours = sugarCore.Number.hours;

    var hoursAfter = sugarCore.Number.hoursAfter;

    var hoursAgo = sugarCore.Number.hoursAgo;

    var hoursBefore = sugarCore.Number.hoursBefore;

    var hoursFromNow = sugarCore.Number.hoursFromNow;

    var millisecond = sugarCore.Number.millisecond;

    var millisecondAfter = sugarCore.Number.millisecondAfter;

    var millisecondAgo = sugarCore.Number.millisecondAgo;

    var millisecondBefore = sugarCore.Number.millisecondBefore;

    var millisecondFromNow = sugarCore.Number.millisecondFromNow;

    var milliseconds = sugarCore.Number.milliseconds;

    var millisecondsAfter = sugarCore.Number.millisecondsAfter;

    var millisecondsAgo = sugarCore.Number.millisecondsAgo;

    var millisecondsBefore = sugarCore.Number.millisecondsBefore;

    var millisecondsFromNow = sugarCore.Number.millisecondsFromNow;

    var minute = sugarCore.Number.minute;

    var minuteAfter = sugarCore.Number.minuteAfter;

    var minuteAgo = sugarCore.Number.minuteAgo;

    var minuteBefore = sugarCore.Number.minuteBefore;

    var minuteFromNow = sugarCore.Number.minuteFromNow;

    var minutes = sugarCore.Number.minutes;

    var minutesAfter = sugarCore.Number.minutesAfter;

    var minutesAgo = sugarCore.Number.minutesAgo;

    var minutesBefore = sugarCore.Number.minutesBefore;

    var minutesFromNow = sugarCore.Number.minutesFromNow;

    var month = sugarCore.Number.month;

    var monthAfter = sugarCore.Number.monthAfter;

    var monthAgo = sugarCore.Number.monthAgo;

    var monthBefore = sugarCore.Number.monthBefore;

    var monthFromNow = sugarCore.Number.monthFromNow;

    var months = sugarCore.Number.months;

    var monthsAfter = sugarCore.Number.monthsAfter;

    var monthsAgo = sugarCore.Number.monthsAgo;

    var monthsBefore = sugarCore.Number.monthsBefore;

    var monthsFromNow = sugarCore.Number.monthsFromNow;

    var second = sugarCore.Number.second;

    var secondAfter = sugarCore.Number.secondAfter;

    var secondAgo = sugarCore.Number.secondAgo;

    var secondBefore = sugarCore.Number.secondBefore;

    var secondFromNow = sugarCore.Number.secondFromNow;

    var seconds = sugarCore.Number.seconds;

    var secondsAfter = sugarCore.Number.secondsAfter;

    var secondsAgo = sugarCore.Number.secondsAgo;

    var secondsBefore = sugarCore.Number.secondsBefore;

    var secondsFromNow = sugarCore.Number.secondsFromNow;

    var week = sugarCore.Number.week;

    var weekAfter = sugarCore.Number.weekAfter;

    var weekAgo = sugarCore.Number.weekAgo;

    var weekBefore = sugarCore.Number.weekBefore;

    var weekFromNow = sugarCore.Number.weekFromNow;

    var weeks = sugarCore.Number.weeks;

    var weeksAfter = sugarCore.Number.weeksAfter;

    var weeksAgo = sugarCore.Number.weeksAgo;

    var weeksBefore = sugarCore.Number.weeksBefore;

    var weeksFromNow = sugarCore.Number.weeksFromNow;

    var year = sugarCore.Number.year;

    var yearAfter = sugarCore.Number.yearAfter;

    var yearAgo = sugarCore.Number.yearAgo;

    var yearBefore = sugarCore.Number.yearBefore;

    var yearFromNow = sugarCore.Number.yearFromNow;

    var years = sugarCore.Number.years;

    var yearsAfter = sugarCore.Number.yearsAfter;

    var yearsAgo = sugarCore.Number.yearsAgo;

    var yearsBefore = sugarCore.Number.yearsBefore;

    var yearsFromNow = sugarCore.Number.yearsFromNow;

    var MONTH_INDEX$5 = DateUnitIndexes.MONTH_INDEX;

    function compareDate(date, d, margin, localeCode, options) {
      var loMargin = 0, hiMargin = 0, timezoneShift, compareEdges, override, min, max, p, t;

      function getTimezoneShift() {
        // If there is any specificity in the date then we're implicitly not
        // checking absolute time, so ignore timezone shifts.
        if (p.set && p.set.specificity) {
          return 0;
        }
        return (tzOffset_1(p.date) - tzOffset_1(date)) * MINUTES;
      }

      function addSpecificUnit() {
        var unit = DateUnits_1[p.set.specificity];
        return advanceDate_1(cloneDate_1(p.date), unit.name, 1).getTime() - 1;
      }

      if (_utc(date)) {
        options = options || {};
        options.fromUTC = true;
        options.setUTC = true;
      }

      p = getExtendedDate_1(null, d, options, true);

      if (margin > 0) {
        loMargin = hiMargin = margin;
        override = true;
      }
      if (!dateIsValid_1(p.date)) return false;
      if (p.set && p.set.specificity) {
        if (isDefined_1(p.set.edge) || isDefined_1(p.set.shift)) {
          compareEdges = true;
          moveToBeginningOfUnit_1(p.date, p.set.specificity, localeCode);
        }
        if (compareEdges || p.set.specificity === MONTH_INDEX$5) {
          max = moveToEndOfUnit_1(cloneDate_1(p.date), p.set.specificity, localeCode).getTime();
        } else {
          max = addSpecificUnit();
        }
        if (!override && isDefined_1(p.set.sign) && p.set.specificity) {
          // If the time is relative, there can occasionally be an disparity between
          // the relative date and "now", which it is being compared to, so set an
          // extra margin to account for this.
          loMargin = 50;
          hiMargin = -50;
        }
      }
      t   = date.getTime();
      min = p.date.getTime();
      max = max || min;
      timezoneShift = getTimezoneShift();
      // istanbul ignore if
      if (timezoneShift) {
        min -= timezoneShift;
        max -= timezoneShift;
      }
      return t >= (min - loMargin) && t <= (max + hiMargin);
    }

    var compareDate_1 = compareDate;

    function getTimeDistanceForUnit(d1, d2, unit) {
      var fwd = d2 > d1, num, tmp;
      if (!fwd) {
        tmp = d2;
        d2  = d1;
        d1  = tmp;
      }
      num = d2 - d1;
      if (unit.multiplier > 1) {
        num = trunc_1(num / unit.multiplier);
      }
      // For higher order with potential ambiguity, use the numeric calculation
      // as a starting point, then iterate until we pass the target date. Decrement
      // starting point by 1 to prevent overshooting the date due to inconsistencies
      // in ambiguous units numerically. For example, calculating the number of days
      // from the beginning of the year to August 5th at 11:59:59 by doing a simple
      // d2 - d1 will produce different results depending on whether or not a
      // timezone shift was encountered due to DST, however that should not have an
      // effect on our calculation here, so subtract by 1 to ensure that the
      // starting point has not already overshot our target date.
      if (unit.ambiguous) {
        d1 = cloneDate_1(d1);
        if (num) {
          num -= 1;
          advanceDate_1(d1, unit.name, num);
        }
        while (d1 < d2) {
          advanceDate_1(d1, unit.name, 1);
          if (d1 > d2) {
            break;
          }
          num += 1;
        }
      }
      return fwd ? -num : num;
    }

    var getTimeDistanceForUnit_1 = getTimeDistanceForUnit;

    var sugarDate$2 = namespaceAliases.sugarDate,
        HOURS_INDEX$2 = DateUnitIndexes.HOURS_INDEX,
        DAY_INDEX$6 = DateUnitIndexes.DAY_INDEX;

    function buildDateUnitMethods() {

      defineInstanceSimilar_1(sugarDate$2, DateUnits_1, function(methods, unit, index) {
        var name = unit.name, caps = simpleCapitalize_1(name);

        if (index > DAY_INDEX$6) {
          forEach_1(['Last','This','Next'], function(shift) {
            methods['is' + shift + caps] = function(d, localeCode) {
              return compareDate_1(d, shift + ' ' + name, 0, localeCode, { locale: 'en' });
            };
          });
        }
        if (index > HOURS_INDEX$2) {
          methods['beginningOf' + caps] = function(d, localeCode) {
            return moveToBeginningOfUnit_1(d, index, localeCode);
          };
          methods['endOf' + caps] = function(d, localeCode) {
            return moveToEndOfUnit_1(d, index, localeCode);
          };
        }

        methods['add' + caps + 's'] = function(d, num, reset) {
          return advanceDate_1(d, name, num, reset);
        };

        var since = function(date, d, options) {
          return getTimeDistanceForUnit_1(date, createDate_1(d, options, true), unit);
        };
        var until = function(date, d, options) {
          return getTimeDistanceForUnit_1(createDate_1(d, options, true), date, unit);
        };

        methods[name + 'sAgo']   = methods[name + 'sUntil']   = until;
        methods[name + 'sSince'] = methods[name + 'sFromNow'] = since;

      });

    }

    var buildDateUnitMethods_1 = buildDateUnitMethods;

    buildDateUnitMethods_1();

    var addDays = sugarCore.Date.addDays;

    var addHours = sugarCore.Date.addHours;

    var addMilliseconds = sugarCore.Date.addMilliseconds;

    var addMinutes = sugarCore.Date.addMinutes;

    var addMonths = sugarCore.Date.addMonths;

    var addSeconds = sugarCore.Date.addSeconds;

    var addWeeks = sugarCore.Date.addWeeks;

    var addYears = sugarCore.Date.addYears;

    function getDateParamsFromString(str) {
      var match, num, params = {};
      match = str.match(/^(-?\d*[\d.]\d*)?\s?(\w+?)s?$/i);
      if (match) {
        if (isUndefined_1(num)) {
          num = match[1] ? +match[1] : 1;
        }
        params[match[2].toLowerCase()] = num;
      }
      return params;
    }

    var getDateParamsFromString_1 = getDateParamsFromString;

    var YEAR_INDEX$4 = DateUnitIndexes.YEAR_INDEX;

    function collectDateParamsFromArguments(args) {
      var params = {}, index = 0;
      walkUnitDown_1(YEAR_INDEX$4, function(unit) {
        var arg = args[index++];
        if (isDefined_1(arg)) {
          params[unit.name] = arg;
        }
      });
      return params;
    }

    var collectDateParamsFromArguments_1 = collectDateParamsFromArguments;

    var isNumber$9 = classChecks.isNumber,
        isString$g = classChecks.isString;

    function collectUpdateDateArguments(args, allowDuration) {
      var arg1 = args[0], arg2 = args[1], params, reset;
      if (allowDuration && isString$g(arg1)) {
        params = getDateParamsFromString_1(arg1);
        reset  = arg2;
      } else if (isNumber$9(arg1) && isNumber$9(arg2)) {
        params = collectDateParamsFromArguments_1(args);
      } else {
        params = isObjectType_1(arg1) ? simpleClone_1(arg1) : arg1;
        reset  = arg2;
      }
      return [params, reset];
    }

    var collectUpdateDateArguments_1 = collectUpdateDateArguments;

    function advanceDateWithArgs(d, args, dir) {
      args = collectUpdateDateArguments_1(args, true);
      return updateDate_1(d, args[0], args[1], dir);
    }

    var advanceDateWithArgs_1 = advanceDateWithArgs;

    sugarCore.Date.defineInstanceWithArguments({

      'advance': function(d, args) {
        return advanceDateWithArgs_1(d, args, 1);
      }

    });

    var advance = sugarCore.Date.advance;

    var beginningOfDay = sugarCore.Date.beginningOfDay;

    sugarCore.Date.defineInstance({

      'beginningOfISOWeek': function(date) {
        var day = getWeekday_1(date);
        if (day === 0) {
          day = -6;
        } else if (day !== 1) {
          day = 1;
        }
        setWeekday_1(date, day);
        return resetTime_1(date);
      }

    });

    var beginningOfISOWeek = sugarCore.Date.beginningOfISOWeek;

    var beginningOfMonth = sugarCore.Date.beginningOfMonth;

    var beginningOfWeek = sugarCore.Date.beginningOfWeek;

    var beginningOfYear = sugarCore.Date.beginningOfYear;

    sugarCore.Date.defineInstance({

      'clone': function(date) {
        return cloneDate_1(date);
      }

    });

    var clone$2 = sugarCore.Date.clone;

    var daysAgo$1 = sugarCore.Date.daysAgo;

    var daysFromNow$1 = sugarCore.Date.daysFromNow;

    sugarCore.Date.defineInstance({

      'daysInMonth': function(date) {
        return getDaysInMonth_1(date);
      }

    });

    var daysInMonth = sugarCore.Date.daysInMonth;

    var daysSince = sugarCore.Date.daysSince;

    var daysUntil = sugarCore.Date.daysUntil;

    var endOfDay = sugarCore.Date.endOfDay;

    var DAY_INDEX$7 = DateUnitIndexes.DAY_INDEX;

    sugarCore.Date.defineInstance({

      'endOfISOWeek': function(date) {
        if (getWeekday_1(date) !== 0) {
          setWeekday_1(date, 7);
        }
        return moveToEndOfUnit_1(date, DAY_INDEX$7);
      }

    });

    var endOfISOWeek = sugarCore.Date.endOfISOWeek;

    var endOfMonth = sugarCore.Date.endOfMonth;

    var endOfWeek = sugarCore.Date.endOfWeek;

    var endOfYear = sugarCore.Date.endOfYear;

    var CoreOutputFormats = {
      'ISO8601': '{yyyy}-{MM}-{dd}T{HH}:{mm}:{ss}.{SSS}{Z}',
      'RFC1123': '{Dow}, {dd} {Mon} {yyyy} {HH}:{mm}:{ss} {ZZ}',
      'RFC1036': '{Weekday}, {dd}-{Mon}-{yy} {HH}:{mm}:{ss} {ZZ}'
    };

    var CoreOutputFormats_1 = CoreOutputFormats;

    var TIMEZONE_ABBREVIATION_REG = /\(([-+]\d{2,4}|\w{3,5})\)$/;

    function getHours(d) {
      return callDateGet_1(d, 'Hours');
    }

    var getHours_1 = getHours;

    var ISO_FIRST_DAY_OF_WEEK$2 = ISODefaults.ISO_FIRST_DAY_OF_WEEK,
        ISO_FIRST_DAY_OF_WEEK_YEAR$2 = ISODefaults.ISO_FIRST_DAY_OF_WEEK_YEAR;

    function getWeekNumber(d, allowPrevious, firstDayOfWeek, firstDayOfWeekYear) {
      var isoWeek, n = 0;
      if (isUndefined_1(firstDayOfWeek)) {
        firstDayOfWeek = ISO_FIRST_DAY_OF_WEEK$2;
      }
      if (isUndefined_1(firstDayOfWeekYear)) {
        firstDayOfWeekYear = ISO_FIRST_DAY_OF_WEEK_YEAR$2;
      }
      // Moving to the end of the week allows for forward year traversal, ie
      // Dec 29 2014 is actually week 01 of 2015.
      isoWeek = moveToEndOfWeek_1(cloneDate_1(d), firstDayOfWeek);
      moveToFirstDayOfWeekYear_1(isoWeek, firstDayOfWeek, firstDayOfWeekYear);
      if (allowPrevious && d < isoWeek) {
        // If the date is still before the start of the year, then it should be
        // the last week of the previous year, ie Jan 1 2016 is actually week 53
        // of 2015, so move to the beginning of the week to traverse the year.
        isoWeek = moveToBeginningOfWeek_1(cloneDate_1(d), firstDayOfWeek);
        moveToFirstDayOfWeekYear_1(isoWeek, firstDayOfWeek, firstDayOfWeekYear);
      }
      while (isoWeek <= d) {
        // Doing a very simple walk to get the week number.
        setDate_1(isoWeek, getDate_1(isoWeek) + 7);
        n++;
      }
      return n;
    }

    var getWeekNumber_1 = getWeekNumber;

    var localeManager$b = LocaleHelpers.localeManager;

    function getWeekYear(d, localeCode, iso) {
      var year, month, firstDayOfWeek, firstDayOfWeekYear, week, loc;
      year = getYear_1(d);
      month = getMonth_1(d);
      if (month === 0 || month === 11) {
        if (!iso) {
          loc = localeManager$b.get(localeCode);
          firstDayOfWeek = loc.getFirstDayOfWeek(localeCode);
          firstDayOfWeekYear = loc.getFirstDayOfWeekYear(localeCode);
        }
        week = getWeekNumber_1(d, false, firstDayOfWeek, firstDayOfWeekYear);
        if (month === 0 && week === 0) {
          year -= 1;
        } else if (month === 11 && week === 1) {
          year += 1;
        }
      }
      return year;
    }

    var getWeekYear_1 = getWeekYear;

    var abs$8 = mathAliases.abs;

    function getUTCOffset(d, iso) {
      var offset = _utc(d) ? 0 : tzOffset_1(d), hours, mins, colon;
      colon  = iso === true ? ':' : '';
      if (!offset && iso) return 'Z';
      hours = padNumber_1(trunc_1(-offset / 60), 2, true);
      mins = padNumber_1(abs$8(offset % 60), 2);
      return  hours + colon + mins;
    }

    var getUTCOffset_1 = getUTCOffset;

    var DAY_INDEX$8 = DateUnitIndexes.DAY_INDEX;

    function getDaysSince(d1, d2) {
      return getTimeDistanceForUnit_1(d1, d2, DateUnits_1[DAY_INDEX$8]);
    }

    var getDaysSince_1 = getDaysSince;

    var localeManager$c = LocaleHelpers.localeManager;

    function getMeridiemToken(d, localeCode) {
      var hours = getHours_1(d);
      return localeManager$c.get(localeCode).ampm[trunc_1(hours / 12)] || '';
    }

    var getMeridiemToken_1 = getMeridiemToken;

    var localeManager$d = LocaleHelpers.localeManager,
        MONTH_INDEX$6 = DateUnitIndexes.MONTH_INDEX,
        ceil$7 = mathAliases.ceil;

    var FormatTokensBase = [
      {
        ldml: 'Dow',
        strf: 'a',
        lowerToken: 'dow',
        get: function(d, localeCode) {
          return localeManager$d.get(localeCode).getWeekdayName(getWeekday_1(d), 2);
        }
      },
      {
        ldml: 'Weekday',
        strf: 'A',
        lowerToken: 'weekday',
        allowAlternates: true,
        get: function(d, localeCode, alternate) {
          return localeManager$d.get(localeCode).getWeekdayName(getWeekday_1(d), alternate);
        }
      },
      {
        ldml: 'Mon',
        strf: 'b h',
        lowerToken: 'mon',
        get: function(d, localeCode) {
          return localeManager$d.get(localeCode).getMonthName(getMonth_1(d), 2);
        }
      },
      {
        ldml: 'Month',
        strf: 'B',
        lowerToken: 'month',
        allowAlternates: true,
        get: function(d, localeCode, alternate) {
          return localeManager$d.get(localeCode).getMonthName(getMonth_1(d), alternate);
        }
      },
      {
        strf: 'C',
        get: function(d) {
          return getYear_1(d).toString().slice(0, 2);
        }
      },
      {
        ldml: 'd date day',
        strf: 'd',
        strfPadding: 2,
        ldmlPaddedToken: 'dd',
        ordinalToken: 'do',
        get: function(d) {
          return getDate_1(d);
        }
      },
      {
        strf: 'e',
        get: function(d) {
          return padNumber_1(getDate_1(d), 2, false, 10, ' ');
        }
      },
      {
        ldml: 'H 24hr',
        strf: 'H',
        strfPadding: 2,
        ldmlPaddedToken: 'HH',
        get: function(d) {
          return getHours_1(d);
        }
      },
      {
        ldml: 'h hours 12hr',
        strf: 'I',
        strfPadding: 2,
        ldmlPaddedToken: 'hh',
        get: function(d) {
          return getHours_1(d) % 12 || 12;
        }
      },
      {
        ldml: 'D',
        strf: 'j',
        strfPadding: 3,
        ldmlPaddedToken: 'DDD',
        get: function(d) {
          var s = setUnitAndLowerToEdge_1(cloneDate_1(d), MONTH_INDEX$6);
          return getDaysSince_1(d, s) + 1;
        }
      },
      {
        ldml: 'M',
        strf: 'm',
        strfPadding: 2,
        ordinalToken: 'Mo',
        ldmlPaddedToken: 'MM',
        get: function(d) {
          return getMonth_1(d) + 1;
        }
      },
      {
        ldml: 'm minutes',
        strf: 'M',
        strfPadding: 2,
        ldmlPaddedToken: 'mm',
        get: function(d) {
          return callDateGet_1(d, 'Minutes');
        }
      },
      {
        ldml: 'Q',
        get: function(d) {
          return ceil$7((getMonth_1(d) + 1) / 3);
        }
      },
      {
        ldml: 'TT',
        strf: 'p',
        get: function(d, localeCode) {
          return getMeridiemToken_1(d, localeCode);
        }
      },
      {
        ldml: 'tt',
        strf: 'P',
        get: function(d, localeCode) {
          return getMeridiemToken_1(d, localeCode).toLowerCase();
        }
      },
      {
        ldml: 'T',
        lowerToken: 't',
        get: function(d, localeCode) {
          return getMeridiemToken_1(d, localeCode).charAt(0);
        }
      },
      {
        ldml: 's seconds',
        strf: 'S',
        strfPadding: 2,
        ldmlPaddedToken: 'ss',
        get: function(d) {
          return callDateGet_1(d, 'Seconds');
        }
      },
      {
        ldml: 'S ms',
        strfPadding: 3,
        ldmlPaddedToken: 'SSS',
        get: function(d) {
          return callDateGet_1(d, 'Milliseconds');
        }
      },
      {
        ldml: 'e',
        strf: 'u',
        ordinalToken: 'eo',
        get: function(d) {
          return getWeekday_1(d) || 7;
        }
      },
      {
        strf: 'U',
        strfPadding: 2,
        get: function(d) {
          // Sunday first, 0-53
          return getWeekNumber_1(d, false, 0);
        }
      },
      {
        ldml: 'W',
        strf: 'V',
        strfPadding: 2,
        ordinalToken: 'Wo',
        ldmlPaddedToken: 'WW',
        get: function(d) {
          // Monday first, 1-53 (ISO8601)
          return getWeekNumber_1(d, true);
        }
      },
      {
        strf: 'w',
        get: function(d) {
          return getWeekday_1(d);
        }
      },
      {
        ldml: 'w',
        ordinalToken: 'wo',
        ldmlPaddedToken: 'ww',
        get: function(d, localeCode) {
          // Locale dependent, 1-53
          var loc = localeManager$d.get(localeCode),
              dow = loc.getFirstDayOfWeek(localeCode),
              doy = loc.getFirstDayOfWeekYear(localeCode);
          return getWeekNumber_1(d, true, dow, doy);
        }
      },
      {
        strf: 'W',
        strfPadding: 2,
        get: function(d) {
          // Monday first, 0-53
          return getWeekNumber_1(d, false);
        }
      },
      {
        ldmlPaddedToken: 'gggg',
        ldmlTwoDigitToken: 'gg',
        get: function(d, localeCode) {
          return getWeekYear_1(d, localeCode);
        }
      },
      {
        strf: 'G',
        strfPadding: 4,
        strfTwoDigitToken: 'g',
        ldmlPaddedToken: 'GGGG',
        ldmlTwoDigitToken: 'GG',
        get: function(d, localeCode) {
          return getWeekYear_1(d, localeCode, true);
        }
      },
      {
        ldml: 'year',
        ldmlPaddedToken: 'yyyy',
        ldmlTwoDigitToken: 'yy',
        strf: 'Y',
        strfPadding: 4,
        strfTwoDigitToken: 'y',
        get: function(d) {
          return getYear_1(d);
        }
      },
      {
        ldml: 'ZZ',
        strf: 'z',
        get: function(d) {
          return getUTCOffset_1(d);
        }
      },
      {
        ldml: 'X',
        get: function(d) {
          return trunc_1(d.getTime() / 1000);
        }
      },
      {
        ldml: 'x',
        get: function(d) {
          return d.getTime();
        }
      },
      {
        ldml: 'Z',
        get: function(d) {
          return getUTCOffset_1(d, true);
        }
      },
      {
        ldml: 'z',
        strf: 'Z',
        get: function(d) {
          // Note that this is not accurate in all browsing environments!
          // https://github.com/moment/moment/issues/162
          // It will continue to be supported for Node and usage with the
          // understanding that it may be blank.
          var match = d.toString().match(TIMEZONE_ABBREVIATION_REG);
          // istanbul ignore next
          return match ? match[1] : '';
        }
      },
      {
        strf: 'D',
        alias: '%m/%d/%y'
      },
      {
        strf: 'F',
        alias: '%Y-%m-%d'
      },
      {
        strf: 'r',
        alias: '%I:%M:%S %p'
      },
      {
        strf: 'R',
        alias: '%H:%M'
      },
      {
        strf: 'T',
        alias: '%H:%M:%S'
      },
      {
        strf: 'x',
        alias: '{short}'
      },
      {
        strf: 'X',
        alias: '{time}'
      },
      {
        strf: 'c',
        alias: '{stamp}'
      }
    ];

    var FormatTokensBase_1 = FormatTokensBase;

    var localeManager$e = LocaleHelpers.localeManager,
        hasOwn$b = coreUtilityAliases.hasOwn,
        getOwn$b = coreUtilityAliases.getOwn,
        forEachProperty$m = coreUtilityAliases.forEachProperty,
        sugarDate$3 = namespaceAliases.sugarDate;

    var ldmlTokens, strfTokens;

    function buildDateFormatTokens() {

      function addFormats(target, tokens, fn) {
        if (tokens) {
          forEach_1(spaceSplit_1(tokens), function(token) {
            target[token] = fn;
          });
        }
      }

      function buildLowercase(get) {
        return function(d, localeCode) {
          return get(d, localeCode).toLowerCase();
        };
      }

      function buildOrdinal(get) {
        return function(d, localeCode) {
          var n = get(d, localeCode);
          return n + localeManager$e.get(localeCode).getOrdinal(n);
        };
      }

      function buildPadded(get, padding) {
        return function(d, localeCode) {
          return padNumber_1(get(d, localeCode), padding);
        };
      }

      function buildTwoDigits(get) {
        return function(d, localeCode) {
          return get(d, localeCode) % 100;
        };
      }

      function buildAlias(alias) {
        return function(d, localeCode) {
          return dateFormatMatcher(alias, d, localeCode);
        };
      }

      function buildAlternates(f) {
        for (var n = 1; n <= 5; n++) {
          buildAlternate(f, n);
        }
      }

      function buildAlternate(f, n) {
        var alternate = function(d, localeCode) {
          return f.get(d, localeCode, n);
        };
        addFormats(ldmlTokens, f.ldml + n, alternate);
        if (f.lowerToken) {
          ldmlTokens[f.lowerToken + n] = buildLowercase(alternate);
        }
      }

      function getIdentityFormat(name) {
        return function(d, localeCode) {
          var loc = localeManager$e.get(localeCode);
          return dateFormatMatcher(loc[name], d, localeCode);
        };
      }

      ldmlTokens = {};
      strfTokens = {};

      forEach_1(FormatTokensBase_1, function(f) {
        var get = f.get, getPadded;
        if (f.lowerToken) {
          ldmlTokens[f.lowerToken] = buildLowercase(get);
        }
        if (f.ordinalToken) {
          ldmlTokens[f.ordinalToken] = buildOrdinal(get);
        }
        if (f.ldmlPaddedToken) {
          ldmlTokens[f.ldmlPaddedToken] = buildPadded(get, f.ldmlPaddedToken.length);
        }
        if (f.ldmlTwoDigitToken) {
          ldmlTokens[f.ldmlTwoDigitToken] = buildPadded(buildTwoDigits(get), 2);
        }
        if (f.strfTwoDigitToken) {
          strfTokens[f.strfTwoDigitToken] = buildPadded(buildTwoDigits(get), 2);
        }
        if (f.strfPadding) {
          getPadded = buildPadded(get, f.strfPadding);
        }
        if (f.alias) {
          get = buildAlias(f.alias);
        }
        if (f.allowAlternates) {
          buildAlternates(f);
        }
        addFormats(ldmlTokens, f.ldml, get);
        addFormats(strfTokens, f.strf, getPadded || get);
      });

      forEachProperty$m(CoreOutputFormats_1, function(src, name) {
        addFormats(ldmlTokens, name, buildAlias(src));
      });

      defineInstanceSimilar_1(sugarDate$3, 'short medium long full', function(methods, name) {
        var fn = getIdentityFormat(name);
        addFormats(ldmlTokens, name, fn);
        methods[name] = fn;
      });

      addFormats(ldmlTokens, 'time', getIdentityFormat('time'));
      addFormats(ldmlTokens, 'stamp', getIdentityFormat('stamp'));
    }

    var dateFormatMatcher;

    function buildDateFormatMatcher() {

      function getLdml(d, token, localeCode) {
        return getOwn$b(ldmlTokens, token)(d, localeCode);
      }

      function getStrf(d, token, localeCode) {
        return getOwn$b(strfTokens, token)(d, localeCode);
      }

      function checkDateToken(ldml, strf) {
        return hasOwn$b(ldmlTokens, ldml) || hasOwn$b(strfTokens, strf);
      }

      // Format matcher for LDML or STRF tokens.
      dateFormatMatcher = createFormatMatcher_1(getLdml, getStrf, checkDateToken);
    }

    buildDateFormatTokens();

    buildDateFormatMatcher();

    var formattingTokens = {
      ldmlTokens: ldmlTokens,
      strfTokens: strfTokens,
      dateFormatMatcher: dateFormatMatcher
    };

    function assertDateIsValid(d) {
      if (!dateIsValid_1(d)) {
        throw new TypeError('Date is not valid');
      }
    }

    var assertDateIsValid_1 = assertDateIsValid;

    var dateFormatMatcher$1 = formattingTokens.dateFormatMatcher;

    function dateFormat(d, format, localeCode) {
      assertDateIsValid_1(d);
      format = CoreOutputFormats_1[format] || format || '{long}';
      return dateFormatMatcher$1(format, d, localeCode);
    }

    var dateFormat_1 = dateFormat;

    sugarCore.Date.defineInstance({

      'format': function(date, f, localeCode) {
        return dateFormat_1(date, f, localeCode);
      }

    });

    var format$3 = sugarCore.Date.format;

    function createDateWithContext(contextDate, d, options, forceClone) {
      return getExtendedDate_1(contextDate, d, options, forceClone).date;
    }

    var createDateWithContext_1 = createDateWithContext;

    sugarCore.Date.defineInstance({

      'get': function(date, d, options) {
        return createDateWithContext_1(date, d, options);
      }

    });

    var get$1 = sugarCore.Date.get;

    sugarCore.Date.defineInstance({

      'getISOWeek': function(date) {
        return getWeekNumber_1(date, true);
      }

    });

    var getISOWeek = sugarCore.Date.getISOWeek;

    sugarCore.Date.defineInstance({

      'getUTCOffset': function(date, iso) {
        return getUTCOffset_1(date, iso);
      }

    });

    var getUTCOffset_1$1 = sugarCore.Date.getUTCOffset;

    sugarCore.Date.defineInstance({

      'getUTCWeekday': function(date) {
        return date.getUTCDay();
      }

    });

    var getUTCWeekday = sugarCore.Date.getUTCWeekday;

    sugarCore.Date.defineInstance({

      'getWeekday': function(date) {
        return getWeekday_1(date);
      }

    });

    var getWeekday_1$1 = sugarCore.Date.getWeekday;

    var hoursAgo$1 = sugarCore.Date.hoursAgo;

    var hoursFromNow$1 = sugarCore.Date.hoursFromNow;

    var hoursSince = sugarCore.Date.hoursSince;

    var hoursUntil = sugarCore.Date.hoursUntil;

    function compareDay(d, shift) {
      var comp = getNewDate_1();
      if (shift) {
        setDate_1(comp, getDate_1(comp) + shift);
      }
      return getYear_1(d) === getYear_1(comp) &&
             getMonth_1(d) === getMonth_1(comp) &&
             getDate_1(d) === getDate_1(comp);
    }

    var compareDay_1 = compareDay;

    var isString$h = classChecks.isString,
        English$2 = LocaleHelpers.English;

    function fullCompareDate(date, d, margin) {
      var tmp;
      if (!dateIsValid_1(date)) return;
      if (isString$h(d)) {
        d = trim_1(d).toLowerCase();
        switch(true) {
          case d === 'future':    return date.getTime() > getNewDate_1().getTime();
          case d === 'past':      return date.getTime() < getNewDate_1().getTime();
          case d === 'today':     return compareDay_1(date);
          case d === 'tomorrow':  return compareDay_1(date,  1);
          case d === 'yesterday': return compareDay_1(date, -1);
          case d === 'weekday':   return getWeekday_1(date) > 0 && getWeekday_1(date) < 6;
          case d === 'weekend':   return getWeekday_1(date) === 0 || getWeekday_1(date) === 6;

          case (isDefined_1(tmp = English$2.weekdayMap[d])):
            return getWeekday_1(date) === tmp;
          case (isDefined_1(tmp = English$2.monthMap[d])):
            return getMonth_1(date) === tmp;
        }
      }
      return compareDate_1(date, d, margin);
    }

    var fullCompareDate_1 = fullCompareDate;

    sugarCore.Date.defineInstance({

      'is': function(date, d, margin) {
        return fullCompareDate_1(date, d, margin);
      }

    });

    var is = sugarCore.Date.is;

    sugarCore.Date.defineInstance({

      'isAfter': function(date, d, margin) {
        return date.getTime() > createDate_1(d).getTime() - (margin || 0);
      }

    });

    var isAfter = sugarCore.Date.isAfter;

    sugarCore.Date.defineInstance({

      'isBefore': function(date, d, margin) {
        return date.getTime() < createDate_1(d).getTime() + (margin || 0);
      }

    });

    var isBefore = sugarCore.Date.isBefore;

    var min$6 = mathAliases.min,
        max$a = mathAliases.max;

    sugarCore.Date.defineInstance({

      'isBetween': function(date, d1, d2, margin) {
        var t  = date.getTime();
        var t1 = createDate_1(d1).getTime();
        var t2 = createDate_1(d2).getTime();
        var lo = min$6(t1, t2);
        var hi = max$a(t1, t2);
        margin = margin || 0;
        return (lo - margin <= t) && (hi + margin >= t);
      }

    });

    var isBetween = sugarCore.Date.isBetween;

    var English$3 = LocaleHelpers.English,
        sugarDate$4 = namespaceAliases.sugarDate;

    function buildRelativeAliases() {
      var special  = spaceSplit_1('Today Yesterday Tomorrow Weekday Weekend Future Past');
      var weekdays = English$3.weekdays.slice(0, 7);
      var months   = English$3.months.slice(0, 12);
      var together = special.concat(weekdays).concat(months);
      defineInstanceSimilar_1(sugarDate$4, together, function(methods, name) {
        methods['is'+ name] = function(d) {
          return fullCompareDate_1(d, name);
        };
      });
    }

    var buildRelativeAliases_1 = buildRelativeAliases;

    buildRelativeAliases_1();

    var isFriday = sugarCore.Date.isFriday;

    var isFuture = sugarCore.Date.isFuture;

    var isLastMonth = sugarCore.Date.isLastMonth;

    var isLastWeek = sugarCore.Date.isLastWeek;

    var isLastYear = sugarCore.Date.isLastYear;

    sugarCore.Date.defineInstance({

      'isLeapYear': function(date) {
        var year = getYear_1(date);
        return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
      }

    });

    var isLeapYear = sugarCore.Date.isLeapYear;

    var isMonday = sugarCore.Date.isMonday;

    var isNextMonth = sugarCore.Date.isNextMonth;

    var isNextWeek = sugarCore.Date.isNextWeek;

    var isNextYear = sugarCore.Date.isNextYear;

    var isPast = sugarCore.Date.isPast;

    var isSaturday = sugarCore.Date.isSaturday;

    var isSunday = sugarCore.Date.isSunday;

    var isThisMonth = sugarCore.Date.isThisMonth;

    var isThisWeek = sugarCore.Date.isThisWeek;

    var isThisYear = sugarCore.Date.isThisYear;

    var isThursday = sugarCore.Date.isThursday;

    var isToday = sugarCore.Date.isToday;

    var isTomorrow = sugarCore.Date.isTomorrow;

    var isTuesday = sugarCore.Date.isTuesday;

    function isUTC(d) {
      return !!_utc(d) || tzOffset_1(d) === 0;
    }

    var isUTC_1 = isUTC;

    sugarCore.Date.defineInstance({

      'isUTC': function(date) {
        return isUTC_1(date);
      }

    });

    var isUTC_1$1 = sugarCore.Date.isUTC;

    sugarCore.Date.defineInstance({

      'isValid': function(date) {
        return dateIsValid_1(date);
      }

    });

    var isValid = sugarCore.Date.isValid;

    var isWednesday = sugarCore.Date.isWednesday;

    var isWeekday = sugarCore.Date.isWeekday;

    var isWeekend = sugarCore.Date.isWeekend;

    var isYesterday = sugarCore.Date.isYesterday;

    sugarCore.Date.defineInstance({

      'iso': function(date) {
        return date.toISOString();
      }

    });

    var iso = sugarCore.Date.iso;

    var millisecondsAgo$1 = sugarCore.Date.millisecondsAgo;

    var millisecondsFromNow$1 = sugarCore.Date.millisecondsFromNow;

    var millisecondsSince = sugarCore.Date.millisecondsSince;

    var millisecondsUntil = sugarCore.Date.millisecondsUntil;

    var minutesAgo$1 = sugarCore.Date.minutesAgo;

    var minutesFromNow$1 = sugarCore.Date.minutesFromNow;

    var minutesSince = sugarCore.Date.minutesSince;

    var minutesUntil = sugarCore.Date.minutesUntil;

    var monthsAgo$1 = sugarCore.Date.monthsAgo;

    var monthsFromNow$1 = sugarCore.Date.monthsFromNow;

    var monthsSince = sugarCore.Date.monthsSince;

    var monthsUntil = sugarCore.Date.monthsUntil;

    var abs$9 = mathAliases.abs;

    function getAdjustedUnitForDate(d, dRelative) {
      var ms;
      if (!dRelative) {
        dRelative = getNewDate_1();
        if (d > dRelative) {
          // If our date is greater than the one that we got from getNewDate, it
          // means that we are finding the unit for a date that is in the future
          // relative to now. However, often the incoming date was created in
          // the same cycle as our comparison, but our "now" date will have been
          // created an instant after it, creating situations where "5 minutes from
          // now" becomes "4 minutes from now" in the same tick. To prevent this,
          // subtract a buffer of 10ms to compensate.
          dRelative = new Date(dRelative.getTime() - 10);
        }
      }
      ms = d - dRelative;
      return getAdjustedUnit_1(ms, function(u) {
        return abs$9(getTimeDistanceForUnit_1(d, dRelative, u));
      });
    }

    var getAdjustedUnitForDate_1 = getAdjustedUnitForDate;

    var isFunction$d = classChecks.isFunction,
        localeManager$f = LocaleHelpers.localeManager;

    function dateRelative(d, dRelative, arg1, arg2) {
      var adu, format, type, localeCode, fn;
      assertDateIsValid_1(d);
      if (isFunction$d(arg1)) {
        fn = arg1;
      } else {
        localeCode = arg1;
        fn = arg2;
      }
      adu = getAdjustedUnitForDate_1(d, dRelative);
      if (fn) {
        format = fn.apply(d, adu.concat(localeManager$f.get(localeCode)));
        if (format) {
          return dateFormat_1(d, format, localeCode);
        }
      }
      // Adjust up if time is in ms, as this doesn't
      // look very good for a standard relative date.
      if (adu[1] === 0) {
        adu[1] = 1;
        adu[0] = 1;
      }
      if (dRelative) {
        type = 'duration';
      } else if (adu[2] > 0) {
        type = 'future';
      } else {
        type = 'past';
      }
      return localeManager$f.get(localeCode).getRelativeFormat(adu, type);
    }

    var dateRelative_1 = dateRelative;

    sugarCore.Date.defineInstance({

      'relative': function(date, localeCode, relativeFn) {
        return dateRelative_1(date, null, localeCode, relativeFn);
      }

    });

    var relative = sugarCore.Date.relative;

    sugarCore.Date.defineInstance({

      'relativeTo': function(date, d, localeCode) {
        return dateRelative_1(date, createDate_1(d), localeCode);
      }

    });

    var relativeTo = sugarCore.Date.relativeTo;

    function getUnitIndexForParamName(name) {
      var params = {}, unitIndex;
      params[name] = 1;
      iterateOverDateParams_1(params, function(name, val, unit, i) {
        unitIndex = i;
        return false;
      });
      return unitIndex;
    }

    var getUnitIndexForParamName_1 = getUnitIndexForParamName;

    var DAY_INDEX$9 = DateUnitIndexes.DAY_INDEX;

    sugarCore.Date.defineInstance({

      'reset': function(date, unit, localeCode) {
        var unitIndex = unit ? getUnitIndexForParamName_1(unit) : DAY_INDEX$9;
        moveToBeginningOfUnit_1(date, unitIndex, localeCode);
        return date;
      }

    });

    var reset = sugarCore.Date.reset;

    sugarCore.Date.defineInstanceWithArguments({

      'rewind': function(d, args) {
        return advanceDateWithArgs_1(d, args, -1);
      }

    });

    var rewind = sugarCore.Date.rewind;

    var secondsAgo$1 = sugarCore.Date.secondsAgo;

    var secondsFromNow$1 = sugarCore.Date.secondsFromNow;

    var secondsSince = sugarCore.Date.secondsSince;

    var secondsUntil = sugarCore.Date.secondsUntil;

    sugarCore.Date.defineInstanceWithArguments({

      'set': function(d, args) {
        args = collectUpdateDateArguments_1(args);
        return updateDate_1(d, args[0], args[1]);
      }

    });

    var set$1 = sugarCore.Date.set;

    sugarCore.Date.defineInstance({

      'setISOWeek': function(date, num) {
        return setISOWeekNumber_1(date, num);
      }

    });

    var setISOWeek = sugarCore.Date.setISOWeek;

    sugarCore.Date.defineInstance({

      'setUTC': function(date, on) {
        return _utc(date, on);
      }

    });

    var setUTC = sugarCore.Date.setUTC;

    sugarCore.Date.defineInstance({

      'setWeekday': function(date, dow) {
        return setWeekday_1(date, dow);
      }

    });

    var setWeekday_1$1 = sugarCore.Date.setWeekday;

    var weeksAgo$1 = sugarCore.Date.weeksAgo;

    var weeksFromNow$1 = sugarCore.Date.weeksFromNow;

    var weeksSince = sugarCore.Date.weeksSince;

    var weeksUntil = sugarCore.Date.weeksUntil;

    var yearsAgo$1 = sugarCore.Date.yearsAgo;

    var yearsFromNow$1 = sugarCore.Date.yearsFromNow;

    var yearsSince = sugarCore.Date.yearsSince;

    var yearsUntil = sugarCore.Date.yearsUntil;

    var getOption$2 = sugarCore.Date.getOption;

    var setOption$2 = sugarCore.Date.setOption;

    var isDate$8 = classChecks.isDate;

    function getRangeMemberPrimitiveValue(m) {
      if (m == null) return m;
      return isDate$8(m) ? m.getTime() : m.valueOf();
    }

    var getRangeMemberPrimitiveValue_1 = getRangeMemberPrimitiveValue;

    var isDate$9 = classChecks.isDate;

    function cloneRangeMember(m) {
      if (isDate$9(m)) {
        return new Date(m.getTime());
      } else {
        return getRangeMemberPrimitiveValue_1(m);
      }
    }

    var cloneRangeMember_1 = cloneRangeMember;

    function Range(start, end) {
      this.start = cloneRangeMember_1(start);
      this.end   = cloneRangeMember_1(end);
    }

    var Range_1 = Range;

    var isDate$a = classChecks.isDate,
        sugarDate$5 = namespaceAliases.sugarDate;

    function getDateForRange(d) {
      if (isDate$a(d)) {
        return d;
      } else if (d == null) {
        return new Date();
      } else if (sugarDate$5.create) {
        return sugarDate$5.create(d);
      }
      return new Date(d);
    }

    var getDateForRange_1 = getDateForRange;

    var DURATION_UNITS = 'year|month|week|day|hour|minute|second|millisecond';

    var FULL_CAPTURED_DURATION = '((?:\\d+)?\\s*(?:' + DURATION_UNITS + '))s?';

    var DurationTextFormats = {
      RANGE_REG_FROM_TO: /(?:from)?\s*(.+)\s+(?:to|until)\s+(.+)$/i,
      RANGE_REG_REAR_DURATION: RegExp('(.+)\\s*for\\s*' + FULL_CAPTURED_DURATION, 'i'),
      RANGE_REG_FRONT_DURATION: RegExp('(?:for)?\\s*'+ FULL_CAPTURED_DURATION +'\\s*(?:starting)?\\s(?:at\\s)?(.+)', 'i')
    };

    var MULTIPLIERS = {
      'Hours': 60 * 60 * 1000,
      'Minutes': 60 * 1000,
      'Seconds': 1000,
      'Milliseconds': 1
    };

    var MULTIPLIERS_1 = MULTIPLIERS;

    function incrementDate(src, amount, unit) {
      var mult = MULTIPLIERS_1[unit], d;
      if (mult) {
        d = new Date(src.getTime() + (amount * mult));
      } else {
        d = new Date(src);
        callDateSet_1(d, unit, callDateGet_1(src, unit) + amount);
      }
      return d;
    }

    var incrementDate_1 = incrementDate;

    var DURATION_REG = RegExp('(\\d+)?\\s*('+ DURATION_UNITS +')s?', 'i');

    var isNumber$a = classChecks.isNumber;

    function getDateIncrementObject(amt) {
      var match, val, unit;
      if (isNumber$a(amt)) {
        return [amt, 'Milliseconds'];
      }
      match = amt.match(DURATION_REG);
      val = +match[1] || 1;
      unit = simpleCapitalize_1(match[2].toLowerCase());
      if (unit.match(/hour|minute|second/i)) {
        unit += 's';
      } else if (unit === 'Year') {
        unit = 'FullYear';
      } else if (unit === 'Week') {
        unit = 'Date';
        val *= 7;
      } else if (unit === 'Day') {
        unit = 'Date';
      }
      return [val, unit];
    }

    var getDateIncrementObject_1 = getDateIncrementObject;

    var sugarDate$6 = namespaceAliases.sugarDate,
        RANGE_REG_FROM_TO = DurationTextFormats.RANGE_REG_FROM_TO,
        RANGE_REG_REAR_DURATION = DurationTextFormats.RANGE_REG_REAR_DURATION,
        RANGE_REG_FRONT_DURATION = DurationTextFormats.RANGE_REG_FRONT_DURATION;

    function createDateRangeFromString(str) {
      var match, datetime, duration, dio, start, end;
      if (sugarDate$6.get && (match = str.match(RANGE_REG_FROM_TO))) {
        start = getDateForRange_1(match[1].replace('from', 'at'));
        end = sugarDate$6.get(start, match[2]);
        return new Range_1(start, end);
      }
      if (match = str.match(RANGE_REG_FRONT_DURATION)) {
        duration = match[1];
        datetime = match[2];
      }
      if (match = str.match(RANGE_REG_REAR_DURATION)) {
        datetime = match[1];
        duration = match[2];
      }
      if (datetime && duration) {
        start = getDateForRange_1(datetime);
        dio = getDateIncrementObject_1(duration);
        end = incrementDate_1(start, dio[0], dio[1]);
      } else {
        start = str;
      }
      return new Range_1(getDateForRange_1(start), getDateForRange_1(end));
    }

    var createDateRangeFromString_1 = createDateRangeFromString;

    var isString$i = classChecks.isString;

    var DateRangeConstructor = function(start, end) {
      if (arguments.length === 1 && isString$i(start)) {
        return createDateRangeFromString_1(start);
      }
      return new Range_1(getDateForRange_1(start), getDateForRange_1(end));
    };

    var DateRangeConstructor_1 = DateRangeConstructor;

    sugarCore.Date.defineStatic({

      'range': DateRangeConstructor_1

    });

    var range = sugarCore.Date.range;

    var PrimitiveRangeConstructor = function(start, end) {
      return new Range_1(start, end);
    };

    var PrimitiveRangeConstructor_1 = PrimitiveRangeConstructor;

    sugarCore.Number.defineStatic({

      'range': PrimitiveRangeConstructor_1

    });

    var range$1 = sugarCore.Number.range;

    sugarCore.String.defineStatic({

      'range': PrimitiveRangeConstructor_1

    });

    var range$2 = sugarCore.String.range;

    function rangeClamp(range, obj) {
      var clamped,
          start = range.start,
          end = range.end,
          min = end < start ? end : start,
          max = start > end ? start : end;
      if (obj < min) {
        clamped = min;
      } else if (obj > max) {
        clamped = max;
      } else {
        clamped = obj;
      }
      return cloneRangeMember_1(clamped);
    }

    var rangeClamp_1 = rangeClamp;

    sugarCore.Number.defineInstance({

      'cap': function(n, max) {
        return rangeClamp_1(new Range_1(undefined, max), n);
      }

    });

    var cap = sugarCore.Number.cap;

    sugarCore.Number.defineInstance({

      'clamp': function(n, start, end) {
        return rangeClamp_1(new Range_1(start, end), n);
      }

    });

    var clamp = sugarCore.Number.clamp;

    function valueIsNotInfinite(m) {
      return m !== -Infinity && m !== Infinity;
    }

    var valueIsNotInfinite_1 = valueIsNotInfinite;

    function isValidRangeMember(m) {
      var val = getRangeMemberPrimitiveValue_1(m);
      return (!!val || val === 0) && valueIsNotInfinite_1(m);
    }

    var isValidRangeMember_1 = isValidRangeMember;

    function rangeIsValid(range) {
      return isValidRangeMember_1(range.start) &&
             isValidRangeMember_1(range.end) &&
             typeof range.start === typeof range.end;
    }

    var rangeIsValid_1 = rangeIsValid;

    function incrementNumber(current, amount, precision) {
      return withPrecision_1(current + amount, precision);
    }

    var incrementNumber_1 = incrementNumber;

    function incrementString(current, amount) {
      return chr(current.charCodeAt(0) + amount);
    }

    var incrementString_1 = incrementString;

    function getPrecision(n) {
      var split = periodSplit_1(n.toString());
      return split[1] ? split[1].length : 0;
    }

    var getPrecision_1 = getPrecision;

    var max$b = mathAliases.max;

    function getGreaterPrecision(n1, n2) {
      return max$b(getPrecision_1(n1), getPrecision_1(n2));
    }

    var getGreaterPrecision_1 = getGreaterPrecision;

    var isNumber$b = classChecks.isNumber,
        isString$j = classChecks.isString,
        isDate$b = classChecks.isDate,
        isFunction$e = classChecks.isFunction;

    function rangeEvery(range, step, countOnly, fn) {
      var increment,
          precision,
          dio,
          unit,
          start   = range.start,
          end     = range.end,
          inverse = end < start,
          current = start,
          index   = 0,
          result  = [];

      if (!rangeIsValid_1(range)) {
        return countOnly ? NaN : [];
      }
      if (isFunction$e(step)) {
        fn = step;
        step = null;
      }
      step = step || 1;
      if (isNumber$b(start)) {
        precision = getGreaterPrecision_1(start, step);
        increment = function() {
          return incrementNumber_1(current, step, precision);
        };
      } else if (isString$j(start)) {
        increment = function() {
          return incrementString_1(current, step);
        };
      } else if (isDate$b(start)) {
        dio  = getDateIncrementObject_1(step);
        step = dio[0];
        unit = dio[1];
        increment = function() {
          return incrementDate_1(current, step, unit);
        };
      }
      // Avoiding infinite loops
      if (inverse && step > 0) {
        step *= -1;
      }
      while(inverse ? current >= end : current <= end) {
        if (!countOnly) {
          result.push(current);
        }
        if (fn) {
          fn(current, index, range);
        }
        current = increment();
        index++;
      }
      return countOnly ? index - 1 : result;
    }

    var rangeEvery_1 = rangeEvery;

    sugarCore.Number.defineInstance({

      'upto': function(n, num, step, everyFn) {
        return rangeEvery_1(new Range_1(n, num), step, false, everyFn);
      }

    });

    var upto = sugarCore.Number.upto;

    var forEachProperty$n = coreUtilityAliases.forEachProperty;

    function defineOnPrototype(ctor, methods) {
      var proto = ctor.prototype;
      forEachProperty$n(methods, function(val, key) {
        proto[key] = val;
      });
    }

    var defineOnPrototype_1 = defineOnPrototype;

    defineOnPrototype_1(Range_1, {

      'clamp': function(el) {
        return rangeClamp_1(this, el);
      }

    });

    defineOnPrototype_1(Range_1, {

      'clone': function() {
        return new Range_1(this.start, this.end);
      }

    });

    defineOnPrototype_1(Range_1, {

      'contains': function(el) {
        if (el == null) return false;
        if (el.start && el.end) {
          return el.start >= this.start && el.start <= this.end &&
                 el.end   >= this.start && el.end   <= this.end;
        } else {
          return el >= this.start && el <= this.end;
        }
      }

    });

    function buildDateRangeUnits() {
      var methods = {};
      forEach_1(DURATION_UNITS.split('|'), function(unit, i) {
        var name = unit + 's', mult, fn;
        if (i < 4) {
          fn = function() {
            return rangeEvery_1(this, unit, true);
          };
        } else {
          mult = MULTIPLIERS_1[simpleCapitalize_1(name)];
          fn = function() {
            return trunc_1((this.end - this.start) / mult);
          };
        }
        methods[name] = fn;
      });
      defineOnPrototype_1(Range_1, methods);
    }

    var buildDateRangeUnits_1 = buildDateRangeUnits;

    buildDateRangeUnits_1();

    defineOnPrototype_1(Range_1, {

      'every': function(amount, everyFn) {
        return rangeEvery_1(this, amount, false, everyFn);
      }

    });

    defineOnPrototype_1(Range_1, {

      'intersect': function(range) {
        if (range.start > this.end || range.end < this.start) {
          return new Range_1(NaN, NaN);
        }
        return new Range_1(
          this.start > range.start ? this.start : range.start,
          this.end   < range.end   ? this.end   : range.end
        );
      }

    });

    defineOnPrototype_1(Range_1, {

      'isValid': function() {
        return rangeIsValid_1(this);
      }

    });

    var isString$k = classChecks.isString;

    function getRangeMemberNumericValue(m) {
      return isString$k(m) ? m.charCodeAt(0) : m;
    }

    var getRangeMemberNumericValue_1 = getRangeMemberNumericValue;

    var abs$a = mathAliases.abs;

    defineOnPrototype_1(Range_1, {

      'span': function() {
        var n = getRangeMemberNumericValue_1(this.end) - getRangeMemberNumericValue_1(this.start);
        return rangeIsValid_1(this) ? abs$a(n) + 1 : NaN;
      }

    });

    defineOnPrototype_1(Range_1, {

      'toArray': function() {
        return rangeEvery_1(this);
      }

    });

    defineOnPrototype_1(Range_1, {

      'toString': function() {
        return rangeIsValid_1(this) ? this.start + '..' + this.end : 'Invalid Range';
      }

    });

    defineOnPrototype_1(Range_1, {

      'union': function(range) {
        return new Range_1(
          this.start < range.start ? this.start : range.start,
          this.end   > range.end   ? this.end   : range.end
        );
      }

    });

    sugarCore.Number.alias('downto', 'upto');

    var downto = sugarCore.Number.downto;

    sugarCore.Function.defineInstance({

      'after': function(fn, num) {
        var count = 0, collectedArgs = [];
        num = coercePositiveInteger_1(num);
        return function() {
          // Optimized: no leaking arguments
          var args = []; for(var $i = 0, $len = arguments.length; $i < $len; $i++) args.push(arguments[$i]);
          collectedArgs.push(args);
          count++;
          if (count >= num) {
            return fn.call(this, collectedArgs);
          }
        };
      }

    });

    var after = sugarCore.Function.after;

    var _timers = privatePropertyAccessor_1('timers');

    var _canceled = privatePropertyAccessor_1('canceled');

    var isArray$g = classChecks.isArray;

    function cancelFunction(fn) {
      var timers = _timers(fn), timer;
      if (isArray$g(timers)) {
        while(timer = timers.shift()) {
          clearTimeout(timer);
        }
      }
      _canceled(fn, true);
      return fn;
    }

    var cancelFunction_1 = cancelFunction;

    sugarCore.Function.defineInstance({

      'cancel': function(fn) {
        return cancelFunction_1(fn);
      }

    });

    var cancel = sugarCore.Function.cancel;

    function setDelay(fn, ms, after, scope, args) {
      // Delay of infinity is never called of course...
      ms = coercePositiveInteger_1(ms || 0);
      if (!_timers(fn)) {
        _timers(fn, []);
      }
      // This is a workaround for <= IE8, which apparently has the
      // ability to call timeouts in the queue on the same tick (ms?)
      // even if functionally they have already been cleared.
      _canceled(fn, false);
      _timers(fn).push(setTimeout(function() {
        if (!_canceled(fn)) {
          after.apply(scope, args || []);
        }
      }, ms));
    }

    var setDelay_1 = setDelay;

    sugarCore.Function.defineInstance({

      'debounce': function(fn, ms) {
        function debounced() {
          // Optimized: no leaking arguments
          var args = []; for(var $i = 0, $len = arguments.length; $i < $len; $i++) args.push(arguments[$i]);
          cancelFunction_1(debounced);
          setDelay_1(debounced, ms, fn, this, args);
        }
        return debounced;
      }

    });

    var debounce$2 = sugarCore.Function.debounce;

    sugarCore.Function.defineInstanceWithArguments({

      'delay': function(fn, ms, args) {
        setDelay_1(fn, ms, fn, fn, args);
        return fn;
      }

    });

    var delay = sugarCore.Function.delay;

    sugarCore.Function.defineInstanceWithArguments({

      'every': function(fn, ms, args) {
        function execute () {
          // Set the delay first here, so that cancel
          // can be called within the executing function.
          setDelay_1(fn, ms, execute);
          fn.apply(fn, args);
        }
        setDelay_1(fn, ms, execute);
        return fn;
      }

    });

    var every$2 = sugarCore.Function.every;

    var max$c = mathAliases.max,
        ceil$8 = mathAliases.ceil,
        round$4 = mathAliases.round;

    function createLazyFunction(fn, ms, immediate, limit) {
      var queue = [], locked = false, execute, rounded, perExecution, result;
      ms = ms || 1;
      limit = limit || Infinity;
      rounded = ceil$8(ms);
      perExecution = round$4(rounded / ms) || 1;
      execute = function() {
        var queueLength = queue.length, maxPerRound;
        if (queueLength == 0) return;
        // Allow fractions of a millisecond by calling
        // multiple times per actual timeout execution
        maxPerRound = max$c(queueLength - perExecution, 0);
        while(queueLength > maxPerRound) {
          // Getting uber-meta here...
          result = Function.prototype.apply.apply(fn, queue.shift());
          queueLength--;
        }
        setDelay_1(lazy, rounded, function() {
          locked = false;
          execute();
        });
      };
      function lazy() {
        // If the execution has locked and it's immediate, then
        // allow 1 less in the queue as 1 call has already taken place.
        if (queue.length < limit - (locked && immediate ? 1 : 0)) {
          // Optimized: no leaking arguments
          var args = []; for(var $i = 0, $len = arguments.length; $i < $len; $i++) args.push(arguments[$i]);
          queue.push([this, args]);
        }
        if (!locked) {
          locked = true;
          if (immediate) {
            execute();
          } else {
            setDelay_1(lazy, rounded, execute);
          }
        }
        // Return the memoized result
        return result;
      }
      return lazy;
    }

    var createLazyFunction_1 = createLazyFunction;

    sugarCore.Function.defineInstance({

      'lazy': function(fn, ms, immediate, limit) {
        return createLazyFunction_1(fn, ms, immediate, limit);
      }

    });

    var lazy = sugarCore.Function.lazy;

    var _lock = privatePropertyAccessor_1('lock');

    var _partial = privatePropertyAccessor_1('partial');

    var isNumber$c = classChecks.isNumber,
        min$7 = mathAliases.min;

    sugarCore.Function.defineInstance({

      'lock': function(fn, n) {
        var lockedFn;
        if (_partial(fn)) {
          _lock(fn, isNumber$c(n) ? n : null);
          return fn;
        }
        lockedFn = function() {
          arguments.length = min$7(_lock(lockedFn), arguments.length);
          return fn.apply(this, arguments);
        };
        _lock(lockedFn, isNumber$c(n) ? n : fn.length);
        return lockedFn;
      }

    });

    var lock = sugarCore.Function.lock;

    function collectArguments() {
      var args = arguments, i = args.length, arr = new Array(i);
      while (i--) {
        arr[i] = args[i];
      }
      return arr;
    }

    var collectArguments_1 = collectArguments;

    var hasOwn$c = coreUtilityAliases.hasOwn,
        getOwn$c = coreUtilityAliases.getOwn;

    function createHashedMemoizeFunction(fn, hashFn, limit) {
      var map = {}, refs = [], counter = 0;
      return function() {
        var hashObj = hashFn.apply(this, arguments);
        var key = serializeInternal_1(hashObj, refs);
        if (hasOwn$c(map, key)) {
          return getOwn$c(map, key);
        }
        if (counter === limit) {
          map = {};
          refs = [];
          counter = 0;
        }
        counter++;
        return map[key] = fn.apply(this, arguments);
      };
    }

    var createHashedMemoizeFunction_1 = createHashedMemoizeFunction;

    var isNumber$d = classChecks.isNumber,
        isString$l = classChecks.isString;

    sugarCore.Function.defineInstance({

      'memoize': function(fn, arg1, arg2) {
        var hashFn, limit, prop;
        if (isNumber$d(arg1)) {
          limit = arg1;
        } else {
          hashFn = arg1;
          limit  = arg2;
        }
        if (isString$l(hashFn)) {
          prop = hashFn;
          hashFn = function(obj) {
            return deepGetProperty_1(obj, prop);
          };
        } else if (!hashFn) {
          hashFn = collectArguments_1;
        }
        return createHashedMemoizeFunction_1(fn, hashFn, limit);
      }

    });

    var memoize = sugarCore.Function.memoize;

    sugarCore.Function.defineInstance({

      'once': function(fn) {
        var called = false, val;
        return function() {
          if (called) {
            return val;
          }
          called = true;
          return val = fn.apply(this, arguments);
        };
      }

    });

    var once = sugarCore.Function.once;

    var createInstanceFromPrototype = Object.create || function(prototype) {
      var ctor = function() {};
      ctor.prototype = prototype;
      return new ctor;
    };

    var createInstanceFromPrototype_1 = createInstanceFromPrototype;

    var isNumber$e = classChecks.isNumber,
        min$8 = mathAliases.min;

    sugarCore.Function.defineInstanceWithArguments({

      'partial': function(fn, curriedArgs) {
        var curriedLen = curriedArgs.length;
        var partialFn = function() {
          var argIndex = 0, applyArgs = [], self = this, lock = _lock(partialFn), result, i;
          for (i = 0; i < curriedLen; i++) {
            var arg = curriedArgs[i];
            if (isDefined_1(arg)) {
              applyArgs[i] = arg;
            } else {
              applyArgs[i] = arguments[argIndex++];
            }
          }
          for (i = argIndex; i < arguments.length; i++) {
            applyArgs.push(arguments[i]);
          }
          if (lock === null) {
            lock = curriedLen;
          }
          if (isNumber$e(lock)) {
            applyArgs.length = min$8(applyArgs.length, lock);
          }
          // If the bound "this" object is an instance of the partialed
          // function, then "new" was used, so preserve the prototype
          // so that constructor functions can also be partialed.
          if (self instanceof partialFn) {
            self = createInstanceFromPrototype_1(fn.prototype);
            result = fn.apply(self, applyArgs);
            // An explicit return value is allowed from constructors
            // as long as they are of "object" type, so return the
            // correct result here accordingly.
            return isObjectType_1(result) ? result : self;
          }
          return fn.apply(self, applyArgs);
        };
        _partial(partialFn, true);
        return partialFn;
      }

    });

    var partial = sugarCore.Function.partial;

    sugarCore.Function.defineInstance({

      'throttle': function(fn, ms) {
        return createLazyFunction_1(fn, ms, true, 1);
      }

    });

    var throttle = sugarCore.Function.throttle;

    sugarCore.RegExp.defineStatic({

      'escape': function(str) {
        return escapeRegExp_1(str);
      }

    });

    var _escape = sugarCore.RegExp.escape;

    sugarCore.RegExp.defineInstance({

      'addFlags': function(r, flags) {
        return RegExp(r.source, getRegExpFlags_1(r, flags));
      }

    });

    var addFlags = sugarCore.RegExp.addFlags;

    sugarCore.RegExp.defineInstance({

      'getFlags': function(r) {
        return getRegExpFlags_1(r);
      }

    });

    var getFlags = sugarCore.RegExp.getFlags;

    sugarCore.RegExp.defineInstance({

      'removeFlags': function(r, flags) {
        var reg = allCharsReg_1(flags);
        return RegExp(r.source, getRegExpFlags_1(r).replace(reg, ''));
      }

    });

    var removeFlags = sugarCore.RegExp.removeFlags;

    sugarCore.RegExp.defineInstance({

      'setFlags': function(r, flags) {
        return RegExp(r.source, flags);
      }

    });

    var setFlags = sugarCore.RegExp.setFlags;

    var sugar = sugarCore;

    var Inflections$1 = {};

    function getAcronym$1(str) {
      // istanbul ignore next
      return Inflections$1.acronyms && Inflections$1.acronyms.find(str);
    }

    var getAcronym_1$1 = getAcronym$1;

    function getHumanWord(str) {
      // istanbul ignore next
      return Inflections$1.human && Inflections$1.human.find(str);
    }

    var getHumanWord_1 = getHumanWord;

    var NATIVE_TYPES$1 = 'Boolean Number String Date RegExp Function Array Error Set Map';

    function isArrayIndex$1(n) {
      return n >>> 0 == n && n != 0xFFFFFFFF;
    }

    var isArrayIndex_1$1 = isArrayIndex$1;

    function getSparseArrayIndexes$1(arr, fromIndex, loop, fromRight) {
      var indexes = [], i;
      for (i in arr) {
        // istanbul ignore next
        if (isArrayIndex_1$1(i) && (loop || (fromRight ? i <= fromIndex : i >= fromIndex))) {
          indexes.push(+i);
        }
      }
      indexes.sort(function(a, b) {
        var aLoop = a > fromIndex;
        var bLoop = b > fromIndex;
        // This block cannot be reached unless ES5 methods are being shimmed.
        // istanbul ignore if
        if (aLoop !== bLoop) {
          return aLoop ? -1 : 1;
        }
        return a - b;
      });
      return indexes;
    }

    var getSparseArrayIndexes_1$1 = getSparseArrayIndexes$1;

    function iterateOverSparseArray$1(arr, fn, fromIndex, loop) {
      var indexes = getSparseArrayIndexes_1$1(arr, fromIndex, loop), index;
      for (var i = 0, len = indexes.length; i < len; i++) {
        index = indexes[i];
        fn.call(arr, arr[index], index, arr);
      }
      return arr;
    }

    var iterateOverSparseArray_1$1 = iterateOverSparseArray$1;

    function forEach$3(arr, fn) {
      for (var i = 0, len = arr.length; i < len; i++) {
        if (!(i in arr)) {
          return iterateOverSparseArray_1$1(arr, fn, i);
        }
        fn(arr[i], i);
      }
    }

    var forEach_1$1 = forEach$3;

    var coreUtilityAliases$1 = {
      hasOwn: sugarCore.util.hasOwn,
      getOwn: sugarCore.util.getOwn,
      setProperty: sugarCore.util.setProperty,
      classToString: sugarCore.util.classToString,
      defineProperty: sugarCore.util.defineProperty,
      forEachProperty: sugarCore.util.forEachProperty,
      mapNativeToChainable: sugarCore.util.mapNativeToChainable
    };

    var classToString$6 = coreUtilityAliases$1.classToString;

    function isClass$1(obj, className, str) {
      if (!str) {
        str = classToString$6(obj);
      }
      return str === '[object '+ className +']';
    }

    var isClass_1$1 = isClass$1;

    function spaceSplit$1(str) {
      return str.split(' ');
    }

    var spaceSplit_1$1 = spaceSplit$1;

    function isObjectType$1(obj, type) {
      return !!obj && (type || typeof obj) === 'object';
    }

    var isObjectType_1$1 = isObjectType$1;

    var hasOwn$d = coreUtilityAliases$1.hasOwn;

    function hasOwnEnumeratedProperties$1(obj) {
      // Plain objects are generally defined as having enumerated properties
      // all their own, however in early IE environments without defineProperty,
      // there may also be enumerated methods in the prototype chain, so check
      // for both of these cases.
      var objectProto = Object.prototype;
      for (var key in obj) {
        var val = obj[key];
        if (!hasOwn$d(obj, key) && val !== objectProto[key]) {
          return false;
        }
      }
      return true;
    }

    var hasOwnEnumeratedProperties_1$1 = hasOwnEnumeratedProperties$1;

    var hasOwn$e = coreUtilityAliases$1.hasOwn;

    function hasValidPlainObjectPrototype$1(obj) {
      var hasToString = 'toString' in obj;
      var hasConstructor = 'constructor' in obj;
      // An object created with Object.create(null) has no methods in the
      // prototype chain, so check if any are missing. The additional hasToString
      // check is for false positives on some host objects in old IE which have
      // toString but no constructor. If the object has an inherited constructor,
      // then check if it is Object (the "isPrototypeOf" tapdance here is a more
      // robust way of ensuring this if the global has been hijacked). Note that
      // accessing the constructor directly (without "in" or "hasOwnProperty")
      // will throw a permissions error in IE8 on cross-domain windows.
      return (!hasConstructor && !hasToString) ||
              (hasConstructor && !hasOwn$e(obj, 'constructor') &&
               hasOwn$e(obj.constructor.prototype, 'isPrototypeOf'));
    }

    var hasValidPlainObjectPrototype_1$1 = hasValidPlainObjectPrototype$1;

    function isPlainObject$1(obj, className) {
      return isObjectType_1$1(obj) &&
             isClass_1$1(obj, 'Object', className) &&
             hasValidPlainObjectPrototype_1$1(obj) &&
             hasOwnEnumeratedProperties_1$1(obj);
    }

    var isPlainObject_1$1 = isPlainObject$1;

    var isSerializable$3,
        isBoolean$7, isNumber$f, isString$m,
        isDate$c, isRegExp$9, isFunction$f,
        isArray$h, isSet$4, isMap$4, isError$4;

    function buildClassChecks$1() {

      var knownTypes = {};

      function addCoreTypes() {

        var names = spaceSplit_1$1(NATIVE_TYPES$1);

        isBoolean$7 = buildPrimitiveClassCheck(names[0]);
        isNumber$f  = buildPrimitiveClassCheck(names[1]);
        isString$m  = buildPrimitiveClassCheck(names[2]);

        isDate$c   = buildClassCheck(names[3]);
        isRegExp$9 = buildClassCheck(names[4]);

        // Wanted to enhance performance here by using simply "typeof"
        // but Firefox has two major issues that make this impossible,
        // one fixed, the other not, so perform a full class check here.
        //
        // 1. Regexes can be typeof "function" in FF < 3
        //    https://bugzilla.mozilla.org/show_bug.cgi?id=61911 (fixed)
        //
        // 2. HTMLEmbedElement and HTMLObjectElement are be typeof "function"
        //    https://bugzilla.mozilla.org/show_bug.cgi?id=268945 (won't fix)
        isFunction$f = buildClassCheck(names[5]);

        // istanbul ignore next
        isArray$h = Array.isArray || buildClassCheck(names[6]);
        isError$4 = buildClassCheck(names[7]);

        isSet$4 = buildClassCheck(names[8], typeof Set !== 'undefined' && Set);
        isMap$4 = buildClassCheck(names[9], typeof Map !== 'undefined' && Map);

        // Add core types as known so that they can be checked by value below,
        // notably excluding Functions and adding Arguments and Error.
        addKnownType('Arguments');
        addKnownType(names[0]);
        addKnownType(names[1]);
        addKnownType(names[2]);
        addKnownType(names[3]);
        addKnownType(names[4]);
        addKnownType(names[6]);

      }

      function addArrayTypes() {
        var types = 'Int8 Uint8 Uint8Clamped Int16 Uint16 Int32 Uint32 Float32 Float64';
        forEach_1$1(spaceSplit_1$1(types), function(str) {
          addKnownType(str + 'Array');
        });
      }

      function addKnownType(className) {
        var str = '[object '+ className +']';
        knownTypes[str] = true;
      }

      function isKnownType(className) {
        return knownTypes[className];
      }

      function buildClassCheck(className, globalObject) {
        // istanbul ignore if
        if (globalObject && isClass_1$1(new globalObject, 'Object')) {
          return getConstructorClassCheck(globalObject);
        } else {
          return getToStringClassCheck(className);
        }
      }

      // Map and Set may be [object Object] in certain IE environments.
      // In this case we need to perform a check using the constructor
      // instead of Object.prototype.toString.
      // istanbul ignore next
      function getConstructorClassCheck(obj) {
        var ctorStr = String(obj);
        return function(obj) {
          return String(obj.constructor) === ctorStr;
        };
      }

      function getToStringClassCheck(className) {
        return function(obj, str) {
          // perf: Returning up front on instanceof appears to be slower.
          return isClass_1$1(obj, className, str);
        };
      }

      function buildPrimitiveClassCheck(className) {
        var type = className.toLowerCase();
        return function(obj) {
          var t = typeof obj;
          return t === type || t === 'object' && isClass_1$1(obj, className);
        };
      }

      addCoreTypes();
      addArrayTypes();

      isSerializable$3 = function(obj, className) {
        // Only known objects can be serialized. This notably excludes functions,
        // host objects, Symbols (which are matched by reference), and instances
        // of classes. The latter can arguably be matched by value, but
        // distinguishing between these and host objects -- which should never be
        // compared by value -- is very tricky so not dealing with it here.
        return isKnownType(className) || isPlainObject_1$1(obj, className);
      };

    }

    buildClassChecks$1();

    var classChecks$1 = {
      isSerializable: isSerializable$3,
      isBoolean: isBoolean$7,
      isNumber: isNumber$f,
      isString: isString$m,
      isDate: isDate$c,
      isRegExp: isRegExp$9,
      isFunction: isFunction$f,
      isArray: isArray$h,
      isSet: isSet$4,
      isMap: isMap$4,
      isError: isError$4
    };

    var isString$n = classChecks$1.isString,
        getOwn$d = coreUtilityAliases$1.getOwn;

    var InflectionSet;

    function buildInflectionSet() {

      InflectionSet = function() {
        this.map = {};
        this.rules = [];
      };

      InflectionSet.prototype = {

        add: function(rule, replacement) {
          if (isString$n(rule)) {
            this.map[rule] = replacement;
          } else {
            this.rules.unshift({
              rule: rule,
              replacement: replacement
            });
          }
        },

        inflect: function(str) {
          var arr, idx, word;

          arr = str.split(' ');
          idx = arr.length - 1;
          word = arr[idx];

          arr[idx] = this.find(word) || this.runRules(word);
          return arr.join(' ');
        },

        find: function(str) {
          return getOwn$d(this.map, str);
        },

        runRules: function(str) {
          for (var i = 0, r; r = this.rules[i]; i++) {
            if (r.rule.test(str)) {
              str = str.replace(r.rule, r.replacement);
              break;
            }
          }
          return str;
        }

      };

    }

    buildInflectionSet();

    var InflectionSet_1 = InflectionSet;

    function addInflection(type, rule, replacement) {
      if (!Inflections$1[type]) {
        Inflections$1[type] = new InflectionSet_1;
      }
      Inflections$1[type].add(rule, replacement);
    }

    var addInflection_1 = addInflection;

    function addHuman(src, humanized) {
      addInflection_1('human', src, humanized);
    }

    var addHuman_1 = addHuman;

    function runHumanRules$1(str) {
      // istanbul ignore next
      return Inflections$1.human && Inflections$1.human.runRules(str) || str;
    }

    var runHumanRules_1$1 = runHumanRules$1;

    var inflectHumans;

    function buildCommonHumans() {

      inflectHumans = runHumanRules_1$1;

      addHuman_1(/_id$/g, '');
    }

    buildCommonHumans();

    var inflectHumans_1 = inflectHumans;

    function simpleCapitalize$1(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    var simpleCapitalize_1$1 = simpleCapitalize$1;

    sugarCore.String.defineInstance({

      'humanize': function(str) {
        str = inflectHumans_1(str);
        str = str.replace(/(_)?([a-z\d]*)/gi, function(match, _, word) {
          word = getHumanWord_1(word) || word;
          word = getAcronym_1$1(word) || word.toLowerCase();
          return (_ ? ' ' : '') + word;
        });
        return simpleCapitalize_1$1(str);
      }

    });

    var humanize = sugarCore.String.humanize;

    function addSingular(plural, singular) {
      addInflection_1('singular', plural, singular);
    }

    var addSingular_1 = addSingular;

    var isString$o = classChecks$1.isString;

    function addPlural(singular, plural) {
      plural = plural || singular;
      addInflection_1('plural', singular, plural);
      if (isString$o(singular)) {
        addSingular_1(plural, singular);
      }
    }

    var addPlural_1 = addPlural;

    function addIrregular(singular, plural) {
      var sReg = RegExp(singular + '$', 'i');
      var pReg = RegExp(plural + '$', 'i');
      addPlural_1(sReg, plural);
      addPlural_1(pReg, plural);
      addSingular_1(pReg, singular);
      addSingular_1(sReg, singular);
    }

    var addIrregular_1 = addIrregular;

    function addUncountable(set) {
      forEach_1$1(spaceSplit_1$1(set), function(str) {
        addPlural_1(str);
      });
    }

    var addUncountable_1 = addUncountable;

    var inflectPlurals;

    function buildCommonPlurals() {

      inflectPlurals = function(type, str) {
        return Inflections$1[type] && Inflections$1[type].inflect(str) || str;
      };

      addPlural_1(/$/, 's');
      addPlural_1(/s$/i, 's');
      addPlural_1(/(ax|test)is$/i, '$1es');
      addPlural_1(/(octop|fung|foc|radi|alumn|cact)(i|us)$/i, '$1i');
      addPlural_1(/(census|alias|status|fetus|genius|virus)$/i, '$1es');
      addPlural_1(/(bu)s$/i, '$1ses');
      addPlural_1(/(buffal|tomat)o$/i, '$1oes');
      addPlural_1(/([ti])um$/i, '$1a');
      addPlural_1(/([ti])a$/i, '$1a');
      addPlural_1(/sis$/i, 'ses');
      addPlural_1(/f+e?$/i, 'ves');
      addPlural_1(/(cuff|roof)$/i, '$1s');
      addPlural_1(/([ht]ive)$/i, '$1s');
      addPlural_1(/([^aeiouy]o)$/i, '$1es');
      addPlural_1(/([^aeiouy]|qu)y$/i, '$1ies');
      addPlural_1(/(x|ch|ss|sh)$/i, '$1es');
      addPlural_1(/(tr|vert)(?:ix|ex)$/i, '$1ices');
      addPlural_1(/([ml])ouse$/i, '$1ice');
      addPlural_1(/([ml])ice$/i, '$1ice');
      addPlural_1(/^(ox)$/i, '$1en');
      addPlural_1(/^(oxen)$/i, '$1');
      addPlural_1(/(quiz)$/i, '$1zes');
      addPlural_1(/(phot|cant|hom|zer|pian|portic|pr|quart|kimon)o$/i, '$1os');
      addPlural_1(/(craft)$/i, '$1');
      addPlural_1(/([ft])[eo]{2}(th?)$/i, '$1ee$2');

      addSingular_1(/s$/i, '');
      addSingular_1(/([pst][aiu]s)$/i, '$1');
      addSingular_1(/([aeiouy])ss$/i, '$1ss');
      addSingular_1(/(n)ews$/i, '$1ews');
      addSingular_1(/([ti])a$/i, '$1um');
      addSingular_1(/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, '$1$2sis');
      addSingular_1(/(^analy)ses$/i, '$1sis');
      addSingular_1(/(i)(f|ves)$/i, '$1fe');
      addSingular_1(/([aeolr]f?)(f|ves)$/i, '$1f');
      addSingular_1(/([ht]ive)s$/i, '$1');
      addSingular_1(/([^aeiouy]|qu)ies$/i, '$1y');
      addSingular_1(/(s)eries$/i, '$1eries');
      addSingular_1(/(m)ovies$/i, '$1ovie');
      addSingular_1(/(x|ch|ss|sh)es$/i, '$1');
      addSingular_1(/([ml])(ous|ic)e$/i, '$1ouse');
      addSingular_1(/(bus)(es)?$/i, '$1');
      addSingular_1(/(o)es$/i, '$1');
      addSingular_1(/(shoe)s?$/i, '$1');
      addSingular_1(/(cris|ax|test)[ie]s$/i, '$1is');
      addSingular_1(/(octop|fung|foc|radi|alumn|cact)(i|us)$/i, '$1us');
      addSingular_1(/(census|alias|status|fetus|genius|virus)(es)?$/i, '$1');
      addSingular_1(/^(ox)(en)?/i, '$1');
      addSingular_1(/(vert)(ex|ices)$/i, '$1ex');
      addSingular_1(/tr(ix|ices)$/i, 'trix');
      addSingular_1(/(quiz)(zes)?$/i, '$1');
      addSingular_1(/(database)s?$/i, '$1');
      addSingular_1(/ee(th?)$/i, 'oo$1');

      addIrregular_1('person', 'people');
      addIrregular_1('man', 'men');
      addIrregular_1('human', 'humans');
      addIrregular_1('child', 'children');
      addIrregular_1('sex', 'sexes');
      addIrregular_1('move', 'moves');
      addIrregular_1('save', 'saves');
      addIrregular_1('goose', 'geese');
      addIrregular_1('zombie', 'zombies');

      addUncountable_1('equipment information rice money species series fish deer sheep jeans');

    }

    buildCommonPlurals();

    var inflectPlurals_1 = inflectPlurals;

    sugarCore.String.defineInstance({

      'pluralize': function(str, num) {
        str = String(str);
        // Reminder that this pretty much holds true only for English.
        return num === 1 || str.length === 0 ? str : inflectPlurals_1('plural', str);
      }

    });

    var pluralize = sugarCore.String.pluralize;

    sugarCore.String.defineInstance({

      'singularize': function(str) {
        return inflectPlurals_1('singular', String(str));
      }

    });

    var singularize = sugarCore.String.singularize;

    var forEachProperty$o = coreUtilityAliases$1.forEachProperty;

    function buildAcronymReg() {
      var tokens = [];
      forEachProperty$o(Inflections$1.acronyms.map, function(val, key) {
        if (key === val) {
          tokens.push(val);
        }
      });
      // Sort by length to ensure that tokens
      // like HTTPS take precedence over HTTP.
      tokens.sort(function(a, b) {
        return b.length - a.length;
      });
      Inflections$1.acronyms.reg = RegExp('\\b' + tokens.join('|') + '\\b', 'g');
    }

    var buildAcronymReg_1 = buildAcronymReg;

    function addAcronym(str) {
      addInflection_1('acronyms', str, str);
      addInflection_1('acronyms', str.toLowerCase(), str);
      buildAcronymReg_1();
    }

    var addAcronym_1 = addAcronym;

    var setProperty$2 = coreUtilityAliases$1.setProperty;

    function defineAccessor$1(namespace, name, fn) {
      setProperty$2(namespace, name, fn);
    }

    var defineAccessor_1$1 = defineAccessor$1;

    var namespaceAliases$1 = {
      sugarObject: sugarCore.Object,
      sugarArray: sugarCore.Array,
      sugarDate: sugarCore.Date,
      sugarString: sugarCore.String,
      sugarNumber: sugarCore.Number,
      sugarFunction: sugarCore.Function,
      sugarRegExp: sugarCore.RegExp
    };

    var sugarString = namespaceAliases$1.sugarString;

    function buildInflectionAccessors() {
      defineAccessor_1$1(sugarString, 'addAcronym', addAcronym_1);
      defineAccessor_1$1(sugarString, 'addPlural', addPlural_1);
      defineAccessor_1$1(sugarString, 'addHuman', addHuman_1);
    }

    var buildInflectionAccessors_1 = buildInflectionAccessors;

    buildInflectionAccessors_1();

    var addAcronym$1 = sugarCore.String.addAcronym;

    var addHuman$1 = sugarCore.String.addHuman;

    var addPlural$1 = sugarCore.String.addPlural;

    var Sugar;

    Sugar = sugar;



    // Array
    Sugar.Array.defineInstance({
      toName: function(array) {
        return array.join(" ").compact();
      },
      toFamilyName: function(array) {
        var lastName;
        lastName = array.pop() + ",";
        array.splice(0, 0, lastName);
        return array.join(" ").compact();
      }
    });

    Sugar.Array.defineInstanceWithArguments({
      pluck: function(array, args) {
        return array.map(function(item) {
          return Object.select(item, args);
        });
      }
    });

    // Number
    Sugar.Number.defineInstance({
      msToSeconds: function(num) {
        return num * 1000;
      },
      msToMinutes: function(num) {
        return num.msToSeconds() / 60;
      },
      msToHours: function(num) {
        return num.msToMinutes() / 60;
      },
      msToDays: function(num) {
        return num.toHours() / 24;
      },
      sToMilliseconds: function(num) {
        return num * 1000;
      },
      mToMilliseconds: function(num) {
        return num.sToMilliseconds() * 60;
      },
      hToMilliseconds: function(num) {
        return num.mToMilliseconds() * 60;
      }
    });

    Sugar.Number.defineInstanceWithArguments({
      isBetween: function(num, args) {
        if (args.length === 2) {
          return (num >= args.min()) && (num <= args.max());
        } else {
          throw "2 numeric arguments are required";
        }
      }
    });

    // Date
    Sugar.Date.defineInstance({
      isBusinessDay: function(date) {
        return date.getWeekday().isBetween(1, 5);
      },
      getIsoWeek: function(date) {
        var week1;
        date.setHours(0, 0, 0, 0);
        // Thursday in current week decides the year.
        date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
        // January 4 is always in week 1.
        week1 = new Date(date.getFullYear(), 0, 4);
        // Adjust to Thursday in week 1 and count number of weeks from date to week1.
        return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
      },
      getIsoYear: function(date) {
        date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
        return date.getFullYear();
      },
      getOrdinalWeek: function(date) {
        var elapsed, start;
        start = date.clone().beginningOfYear().beginningOfDay();
        elapsed = date.daysSince(start);
        return (elapsed / 7).floor();
      },
      getOrdinalWeekNumber: function(date) {
        return date.getOrdinalWeek() + 1;
      },
      getWeekDayNumber: function(date) {
        return date.getWeekday() + 1;
      },
      getMonthNumber: function(date) {
        return date.getMonth() + 1;
      },
      getQuarterNumber: function(date) {
        switch (parseInt(date.format("%m"))) {
          case 1:
          case 2:
          case 3:
            return 1;
          case 4:
          case 5:
          case 6:
            return 2;
          case 7:
          case 8:
          case 9:
            return 3;
          case 10:
          case 11:
          case 12:
            return 4;
        }
      },
      toDateId: function(date) {
        return parseInt(date.format("%Y%m%d"));
      },
      toMonthId: function(date) {
        return parseInt(date.format("%Y%m"));
      },
      toQuarterId: function(date) {
        return parseInt(`${date.format("%Y%m")}${date.getQuarterNumber()}`);
      },
      toTimestampId: function(date) {
        return parseInt(date.format("%Y%m%d%H%M%S"));
      },
      posted: function(date) {},
      // relative date with a few more rules for posting dates\
      toObject: function(date) {
        return {
          date: date,
          year: date.getYear(),
          month: date.getMonthNumber(),
          monthName: date.format("%B"),
          monthAbbreviation: date.format("%b"),
          day: date.getDate(),
          dayOfWeek: date.getDay() + 1,
          weekday: date.format("%A"),
          weekdayAbbreviation: date.format("%a")
        };
      },
      toWeekCalendar: function(date) {
        var calendarEnd, calendarStart, range, runningDate;
        calendarStart = date.clone().beginningOfWeek();
        calendarEnd = date.clone().endOfWeek();
        runningDate = calendarStart.clone();
        range = Date.range(calendarStart, calendarEnd);
        //while runningDate.isBetween(calendarStart, calendarEnd)
        //  days.push runningDate.clone().toObject()
        //  runningDate.addDays(1)
        return range.every("day").map(function(d) {
          return d.toObject();
        });
      },
      toMonthCalendar: function(date) {
        var calendarEnd, calendarStart, range;
        // generate data for a month view
        // calendars always start on sun and end on sat
        // this will produce dates before and after the date's month where applicable
        // because the most common usage will be in a standard calendar

        // todo: this can be refactored using to WeekCalendar
        // todo: add additional info to the calendar
        // * selected date
        // * in selected dates' month
        calendarStart = date.clone().beginningOfMonth().beginningOfWeek();
        calendarEnd = date.clone().endOfMonth().endOfWeek();
        range = Date.range(calendarStart, calendarEnd);
        return range.every("day").map(function(d) {
          return d.toObject();
        });
      }
    });

    Sugar.Date.defineInstanceWithArguments({
      diffDays: function(date, args) {
        var end, start;
        // arg 1: second date
        start = date.clone().beginningOfDay();
        end = args.first().clone().beginningOfDay();
        return end.daysSince(start);
      },
      diffWeeks: function(date, args) {
        var end, start;
        // arg 1: second date
        start = date.clone().beginningOfDay();
        end = args.first().clone().beginningOfDay();
        return end.weeksSince(start);
      },
      diffMonths: function(date, args) {
        var end, start;
        // arg 1: second date
        start = date.clone().beginningOfDay();
        end = args.first().clone().beginningOfDay();
        return end.monthsSince(start);
      },
      diffQuarters: function(date, args) {
        // todo
        console.log("to be implemented");
        return 0;
      },
      diffYears: function(date, args) {
        var end, start;
        // arg 1: second date
        start = date.clone().beginningOfDay();
        end = args.first().clone().beginningOfDay();
        return end.yearsSince(start);
      },
      dbDate: function(date) { // db friendly date
        return date.format("%Y-%m-%d");
      },
      isSameDayAs: function(date, args) {
        return date.toDateId() === args[0].toDateId();
      },
      isSameMonthAs: function(date, args) {
        return date.toMonthId() === args[0].toMonthId();
      },
      isSameQuarterAs: function(date, args) {
        return date.toQuarterId() === args[0].toDQuarterId();
      },
      isSameYearAs: function(date, args) {
        return date.getYear() === args[0].getYear();
      },
      isSameOrdinalWeekAs: function(date, args) {
        if (date.isSameYearAs(args.first())) {
          return date.getOrdinalWeek() === args.first().getOrdinalWeek();
        } else {
          return false;
        }
      },
      isSameIsoWeekAs: function(date, args) {
        if (date.getISOYear() === args.first().getISOYear()) {
          return date.getISOWeek() === args.first().getISOWeek();
        } else {
          return false;
        }
      },
      isOnOrBefore: function(date, args) {
        return date.toDateId() <= args.first().toDateId();
      },
      comparedTo: function(date, args) {
        // return a string compared to arg[0]
        // can be used for class names for styling
        if (date.isSameDayAs(args.first())) {
          return "on";
        } else {
          if (date.toDateId() < args.first().toDateId()) {
            return "before";
          } else {
            return "after";
          }
        }
      },
      weekdaysSince: function(date, args) {
        var calendarEnd, calendarStart, range;
        calendarStart = date;
        calendarEnd = args.first();
        range = Date.range(calendarStart, calendarEnd);
        return range.every("day").sum(function(day) {
          if (day.getDay().isBetween(1, 5)) {
            return 1;
          } else {
            return 0;
          }
        });
      },
      relativeDateToNow: function(date, args) { // does not factor time
        var today;
        // this, next and last have some ambiguity and mixed use in English
        today = Date.create();
        if (date.isToday()) {
          return "Today";
        } else if (date.isTomorrow()) {
          return "Tomorrow";
        } else if (date.isYesterday()) {
          return "Yesterday";
        } else if (date.isBetween(today, today.endOfWeek())) { // now until Saturday, just use weekday name
          return date.format("%A");
        } else if (date.isBetween(today.addWeeks(1).beginningOfWeek(), today.addWeeks(1).endOfWeek())) { // anything after saturday in the next week has "Next" prefix
          return date.format("Next %A"); // just show the date
        } else {
          return date.format("%a, %b {d}, %Y");
        }
      }
    });

    // String

    // Custom Pluralizations
    Sugar.String.addPlural("is", "are");

    Sugar.Date.defineInstance({
      validateNumber: function(string) {
        // is a valid number
        return true;
      },
      validateInteger: function(string) {
        // is an integer
        return true;
      },
      validateDate: function(string) {
        // is a valid date
        return true;
      },
      validatePresent: function(string) {}
    });

    // not blank
    Sugar.Object.defineInstance({
      toJSON: function(obj) {
        return JSON.stringify(obj, null, 2);
      }
    });

    var sugarAndSpice = Sugar;

    var rngBrowser = createCommonjsModule(function (module) {
    // Unique ID creation requires a high quality random # generator.  In the
    // browser this is a little complicated due to unknown quality of Math.random()
    // and inconsistent support for the `crypto` API.  We do the best we can via
    // feature-detection

    // getRandomValues needs to be invoked in a context where "this" is a Crypto
    // implementation. Also, find the complete implementation of crypto on IE11.
    var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                          (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

    if (getRandomValues) {
      // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
      var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      // Math.random()-based (RNG)
      //
      // If all else fails, use Math.random().  It's fast, but is of unspecified
      // quality.
      var rnds = new Array(16);

      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
          rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
        }

        return rnds;
      };
    }
    });

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */
    var byteToHex = [];
    for (var i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 0x100).toString(16).substr(1);
    }

    function bytesToUuid(buf, offset) {
      var i = offset || 0;
      var bth = byteToHex;
      // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
      return ([bth[buf[i++]], bth[buf[i++]], 
    	bth[buf[i++]], bth[buf[i++]], '-',
    	bth[buf[i++]], bth[buf[i++]], '-',
    	bth[buf[i++]], bth[buf[i++]], '-',
    	bth[buf[i++]], bth[buf[i++]], '-',
    	bth[buf[i++]], bth[buf[i++]],
    	bth[buf[i++]], bth[buf[i++]],
    	bth[buf[i++]], bth[buf[i++]]]).join('');
    }

    var bytesToUuid_1 = bytesToUuid;

    // **`v1()` - Generate time-based UUID**
    //
    // Inspired by https://github.com/LiosK/UUID.js
    // and http://docs.python.org/library/uuid.html

    var _nodeId;
    var _clockseq;

    // Previous uuid creation time
    var _lastMSecs = 0;
    var _lastNSecs = 0;

    // See https://github.com/broofa/node-uuid for API details
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];

      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

      // node and clockseq need to be initialized to random values if they're not
      // specified.  We do this lazily to minimize issues related to insufficient
      // system entropy.  See #189
      if (node == null || clockseq == null) {
        var seedBytes = rngBrowser();
        if (node == null) {
          // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
          node = _nodeId = [
            seedBytes[0] | 0x01,
            seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
          ];
        }
        if (clockseq == null) {
          // Per 4.2.2, randomize (14 bit) clockseq
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
      }

      // UUID timestamps are 100 nano-second units since the Gregorian epoch,
      // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
      // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
      // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
      var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

      // Per 4.2.1.2, use count of uuid's generated during the current clock
      // cycle to simulate higher resolution clock
      var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

      // Time since last uuid creation (in msecs)
      var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

      // Per 4.2.1.2, Bump clockseq on clock regression
      if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
      }

      // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
      // time interval
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
      }

      // Per 4.2.1.2 Throw error if too many uuids are requested
      if (nsecs >= 10000) {
        throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
      }

      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;

      // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
      msecs += 12219292800000;

      // `time_low`
      var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
      b[i++] = tl >>> 24 & 0xff;
      b[i++] = tl >>> 16 & 0xff;
      b[i++] = tl >>> 8 & 0xff;
      b[i++] = tl & 0xff;

      // `time_mid`
      var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
      b[i++] = tmh >>> 8 & 0xff;
      b[i++] = tmh & 0xff;

      // `time_high_and_version`
      b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
      b[i++] = tmh >>> 16 & 0xff;

      // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
      b[i++] = clockseq >>> 8 | 0x80;

      // `clock_seq_low`
      b[i++] = clockseq & 0xff;

      // `node`
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }

      return buf ? buf : bytesToUuid_1(b);
    }

    var v1_1 = v1;

    function v4(options, buf, offset) {
      var i = buf && offset || 0;

      if (typeof(options) == 'string') {
        buf = options === 'binary' ? new Array(16) : null;
        options = null;
      }
      options = options || {};

      var rnds = options.random || (options.rng || rngBrowser)();

      // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
      rnds[6] = (rnds[6] & 0x0f) | 0x40;
      rnds[8] = (rnds[8] & 0x3f) | 0x80;

      // Copy bytes to buffer, if provided
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }

      return buf || bytesToUuid_1(rnds);
    }

    var v4_1 = v4;

    var uuid$1 = v4_1;
    uuid$1.v1 = v1_1;
    uuid$1.v4 = v4_1;

    var uuid_1 = uuid$1;

    sugarAndSpice.extend();
    window.uuid = uuid_1;

    // App here

    const app = new App({
    	target: document.body,
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
